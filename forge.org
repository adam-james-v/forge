* ;;
#+Title: forge
#+SUBTITLE: build solid modeling programs
#+AUTHOR: adam-james
#+STARTUP: overview
#+EXCLUDE_TAGS: nx
#+PROPERTY: header-args :cache yes :noweb yes :results none :mkdirp yes :padline yes :async
#+HTML_DOCTYPE: html5
#+OPTIONS: toc:2 num:nil html-style:nil html-postamble:nil html-preamble:nil html5-fancy:t

** deps.edn
#+NAME: deps.edn
#+begin_src clojure :tangle ./deps.edn
{:deps 
 {org.clojure/clojure            {:mvn/version "1.10.3"}
  org.clojure/test.check         {:mvn/version "0.9.0"}
  org.clojure/math.numeric-tower {:mvn/version "0.0.4"}
  hiccup/hiccup                  {:mvn/version "2.0.0-alpha2"}
  same/ish                       {:mvn/version "0.1.4"}
  svg-clj/svg-clj                {:local/root "/Users/adam/dev/svg-clj"}}}

#+end_src

** readme
#+BEGIN_SRC markdown :tangle ./readme.md
# Forge

Forge is a library for 3D CAD data. The aim is to provide functions for representing 3D data with Functional Representatin (FREP, similar to Signed Distance Functions), and Boundary Representation (BREP, using parametric curves and Clojure maps to store topological information).

Using basic Clojure functions, an internal representation is emitted, which can then be compiled or exported. Currently, this internal representation is a Hiccup-style tree, but the form of data may evolve as the library develops.

Compilation currently targets .scad files, and is a near copy of [scad-clj](https://github.com/farrellm/scad-clj). There is a FreeCAD compilation prototype available that emits a python script and uses FreeCAD to export a STEP file from OpenSCAD code. It's not perfect yet, but it's an indication of the direction I want to take this library.

OpenSCAD is a great tool, but it only exports triangulated 3D files, which may not be suitable for all CAD workflows. STEP export is a nice way to use programmatic CAD tools as an input into commercial CAD packages that can import STEP files.

## Status

Alpha. Changes are very likely to occur as I continue to build and discover the best design for this library.

## Usage

Use the git deps dependency:

```clojure
io.github.adam-james-v/forge {:git/sha "0647a1445261e0c9c10d112877f0aa1d622e3688"}
```


#+END_SRC

* design
** intro
*** Pitch
Forge is a powerful Design library that enhances the work of designers and engineers by providing a concise, powerful set of design documentation and creation tools.

It works with the following flow:
- create a text document
- write your specs, design ideas, scope, and any other necessary documentation in plain text
- enter code descriptions of all parts and assemblies in the same document, right with the documentation
- Forge 'renders' this text document to an html file
- view, interact with, change parameters, and export from this html file

*** Emphasis and Values
The design and implementation of Forge focuses heavily on:

- Simplicity
- Composition
- Discipline
- Documentation as Design
- Pragmatic Correctness and Completeness
- Open Source
- User Empowerment

*** Motivation
Design is a difficult task for the craftsperson, and the tools should be as integral to the design work as any final components. At the same time, effective design is communicative of purpose, intent, and method. Designs solve problems as elegantly as possible, taking into primary consideration the context in which the design will live. With such a broad yet critical task, designers must be given the power to create solutions and build abstractions at every layer of their process; from tools to final design.

Solid Modeling is fundamentally a method of communicating the form, function, and interactions of physical objects. Modern CAD programs are extremely powerful and expressive tools which facilitate effective capture of many design needs. Where CAD tools fall short is in expressiveness of parametric design needs, computational approaches to modeling, and reusability of complex and parametric assembly data.

Instead of focusing on the direct manipulation of 3D objects in a user interface, forge favours flexibility and specificity by embracing the functional programming approach. Visual aids are critical for the proper understanding of a solid model, but a visual approach alone is insufficient for fully describing advanced design ideas or parametric aspects of a design. Forge effectively blends the visual elements of design with the expressive power of programming to empower designers to more fully communicate design intent and to enhance problem solving in general.

*** What is Forge?
Forge is a tool that embraces the dynamic and evolving nature of complexity in design by enabling engineers and designers to directly program their designs.

Forge is a Clojure and ClojureScript library for building 3D modeling programs, inspired by [[https://libfive.com/][libfive]], [[http://www.openscad.org/][OpenSCAD]], and [[https://github.com/CadQuery/cadquery][CadQuery]].

*** Intended Workflow
The intended workflow of the Forge library is very simple and is meant to 'get out of the way' of designers and engineers.

The following workflow is assumed to be 'fuzzy' at the transition boundaries from one phase to the next. Additionally, it should be assumed that iteration loops between any number of steps may need to occur. For example, it is often the case in real-world projects that the spec and design phases change dynamically even as programming nears completion. 

**** Spec
Write a specification document capturing the problem being solved and the intended scope of the solution being designed.

**** Design
Document the design in words, pictures, existing 3d models, links to other Forge documents, etc.
For small projects, the spec and design steps can be combined, or even skipped altogether. It is, however, always recommended to at least provide a small explanation section prior to implementing any solutions, to give context to future users.

**** Program
Use all of the Clojure/Clojurescript ecosystem alongside the Forge library to implement scripts and programs that can produce a fully parametric solid model of all parts and assemblies for the design.

This phase can additionally be used to add analytic modelling capabilities and advanced engineering calculations into the model directly using the built in Forge engineering capabilities or pairing with external math, numerics, solver, and AI libraries. The limit is the user's imagination and confidence.

**** Render
Forge is used to read, parse, and compile the design document, which at this point is a full design journal of prose and code which all define the design.

The output of this render process is a powerful html document that fully embeds the working model code alongside the text explaining the design. This is presented to the user as an 'interactive essay' where every part and assembly is shown in 3D and can be manipulated live. All programmed parameters become available as interface elements such as sliders, radio buttons, and drop-down menus where the user can dynamically change the displayed design.

**** Export
From within the rendered html, once a user is satisfied with any parameter changes and is confident the code is 'production ready', it is possible to export final files.

If no commercial CAD software is available, Forge can serve as a perfectly viable commercial tool as it can fully render and export 2D drawing packages suitable for manufacturing.

If designers wish to add or change designs in a tool they are familiar with, commercial CAD export options exist: STEP files (generic, safe export option), SW vba script files, Inventor vba script files, and AutoCAD LISP files are all producible. These scripts, when run in their appropriate software, will render a fully native part/assembly file.

**** Iterate
The design of a solution is fully described in text and code, and so is quick to change, fast to load, and easy to manipulate. With Forge's 'watch and render' capabilities, a very tight design loop is formed where the designer can create changes to text and code and see them reflected live in the rendered document. 

This is excellent for design work which can be completed by an individual. Iteration however, often occurs over the course of days and weeks and includes many different stakeholders. Forge's intended workflow is designed so that the canonical design is always captured in the text. If a CAD file is lost, it can be re-produced easily from the text. If stakeholders make custom, one-time tweaks to CAD files or drawings, they do not 'filter back' and cause problems with the original design. 

The 'change arrow' always occurs one way. txt -> html -> CAD
This mono-directional change seems like a hinderance, but forces the user(s) to capture design intent at the lowest level, always ensuring correctness downstream.

** architecture
The Forge library is architected around an idea of *functional layering.* Layering begins with a *kernel* of necessary functionality and wraps on additional functionality. Each added layer depends upon prior layers, but adds value to the unit as a whole. This implies that:
 - a *kernel* is the minimum set of functionality that can provide value
 - any layer on its own provides no utility, due to its dependence on prior layers

The layering concept is useful at varying levels of abstraction and is used liberally throughout the Forge Library.

*** Code Units
Layering provides structure to *code units* which are well-designed sets of functions that provide utility in some context. 

Extending the idea of a code unit is a *design document* which is a document that fully captures the problem, and the design intent of the unit. 

It is not strictly necessary to realize every layer to produce a valid code unit, with the exception of the kernel. Nevertheless, a code unit becomes more valuable with each layer implemented.

With this in mind, the layers of a code unit are as follows:
 
 1. *design*
    A document explaining the need for the unit and the approach being taken to address it. A fully developed design will include elements familiar to engineers like a problem statement, assumptions, unknowns, constraints, and parameters.

 2. *kernel*
    The set of functions that implement the required functionality. The most direct realization of an algorithm or procedure for meeting the requirements.

 3. *guard*
    Validation functions or specs that ensure any data passed into the kernel is correctly shaped and logically correct according to the intended use cases. Error handling functions that protect and communicate errors that originate in the kernel.

 4. *instrumentation*
    The set of functions that perform useful measurement tasks such as logging, debugging, and timing.

 5. *optimization*
    The set of functions that can use additional logic to create functionally equivalent versions of data and/or functions that run more optimally than the default kernel.

 6. *interface*
    The set of functions that wrap all prior layers into a package that can be appropriately and easily used by users. Different users may use different interfaces such as dev. and user interfaces.

 7. *test*
    The set of functions which run unit tests on all prior layers as well as integration tests for the fully wrapped kernel.

*** Library Structure
The layering of the Forge Library begins at the *solid model* and extends up to the *test harness* layer.

The layers:
 1. design
 2. solid model
 3. guard
 4. analytic model
 5. optimizer
 6. interface
 7. test harness

**** design
The design of the Forge Library is captured in the form of a literate program. In fact, it lives in this very document. Additional notes and diagrams are added into the project's directory and linked into this document as needed.

**** solid model
The solid model is a *script* using the *domain specific language (DSL)* provided by ~forge.lang~ to describe the shape and dimensions of an object. This is the minimum required element for creating a useful design with Forge. The DSL is embedded within Clojure/Clojurescript permitting full use of the entire Clojure ecosystem of libraries.

User facing functions are geometric, transforms, constructive, topological, math, and utility functions which can all be used to accurately describe parts and assemblies. In all cases, the user is not required to consider the underlying implementation of any functions.

A solid model is *executable*. When run, a solid model program will produce an *enriched abstract syntax tree (AST)* which forms the main data structure on which all subsequent layers operate.

**** guard
The guard layer provides *validation* of data entering the solid model and *error handling* to properly manage errors that occur when the solid model is executed.

Beyond simple validation and error handling, Forge's guard layer consists of a parameter and constraint handling set of functions. These functions allow the user to specify many types of parametric relationships between dimensions and variables defined in the solid model, as well as constraints.

If no guards are explicitly designed, the constraints and parameters default to be fixed at the intial values programmed into the solid model.

**** analytic model
The analytic model provides advanced functionality for describing high level requirements which are typically derived from engineering analysis considerations.

The analytical model has two pathways for affecting the solid model: *interfacing* or *integrating*. 

Interfacing is the simpler approach as it adjusts the model strictly through the guard layer; the results from an analysis run will only ever change parameter and constraint values.

Integrating is a much more complex mode as it can directly alter the solid model's code. This may be desireable for highly complex logical transformations of a model based on a very involved analysis approach. It is more complex because changing the solid model necessarily requires that the analytic model has logic for updating the parameters and constraints in the guard layer.

Both modes of analytic interaction are fully supported and encouraged by the Forge library.

**** optimizer
The optimizer is capable of altering the AST to improve on various key metrics such as generation speed, memory use, renderability, exportability, and complexity.

The optimizer performs these improvements heuristically. It is important to allow the optimizer to be tuned appropriately for the use case because some optimizations may lead to lossy alterations. This is of particular importance for highly parametric designs as geometric simplification may accidentally erase design intent.

The main optimizations focus on AST simplification by swapping nested structures for volumetrically equivalent flat calls.

**** interface
The interface layer has a high degree of optionality as it contains diverse functionality:
 - graphical views
 - GUI forms
 - minimal viewers
 - web app producers
 - compilers/transpilers
 - exporters

All interface functionality is intended to be used as pieces for the designer to be able to build a program which can fully express the design intent of *all possible* variants of the design.

**** test harness
The guard layer is intended to handle data related validation and to enforce appropriate constraints and parameter limits, but it is not a sufficient layer for fully testing the entire design program. The test harness layer provides a suite of useful tests which can be run against any Forge prorgam.

The test harness also provides a simple interface for designers to define their own tests and run them with the rest of the test suite.

*** A Diagram
To keep it all straight.

#+begin_src text

   design
     doc
      |
      V
+-----------+
|   solid   |<--(ns forge.lang)<-+--(ns forge.brep)
|   model   |                     `-(ns forge.frep)
+-----------+
      |
      V
+-----------+
|   guard   |<--(ns forge.guard)
|           |
+-----------+
      |
      V
+-----------+
| analytic  |<--(ns forge.analytic)
|   model   |
+-----------+
      |
      V
+-----------+
| optimizer |<--(ns forge.optimize)
|           |
+-----------+
      |
      V                            ,-(ns forge.app)
+-----------+                     |--(ns forge.gui)
| interface |<--(ns forge.build)<-+--(ns forge.impl)
|           |                     |--(ns forge.view)
+-----------+                     |--(ns forge.compile)
      |                            `-(ns forge.web)
      V
+-----------+
|   test    |<--(ns forge.test)
|  harness  |
+-----------+
      |
      V
 integration

#+end_src
** notes
I need to productize fairly quickly.

Necessary features for acceptable 'paid prototyping':
- STEP export 
  - do this by creating a Server/Client Webapp. FreeCAD first as STEP backend
  - upgrade from FreeCAD to proper Kernel (OCCT...)
  - alternatively, use CadQuery 2.0 as the intermediate.
- WebGL 3D renders
- Drawing Export
  - PDF
  - Parametric SVGs in design docs
  - DXF

Very soon after initial contracts, I suspect I'll need:
- native export
  - Macro generators for VBA (SW and Inventor)
  - AutoLISP generators

- DesignDoc Editor App
  - let users design their own part/assembly docs with some basic notebook style tooling

Long term, I want to build my own CAD Kernel, native in Clojure so that CLJ/CLJS can be fully portable without any connection to a server. This will be useful for powerful app building -> custom CAD programs for very niche design industries.

* utils
Use the util namespace to place functions which may be used across the other namespaces. Currently the util namespace contains mostly geometry calculation functions like checks for lines and points.

** ns
#+begin_src clojure :tangle ./src/forge/utils.cljc
(ns forge.utils
  (:require [clojure.string :as str]
            [same :refer [ish? zeroish?]]))

#+end_src
** comparing-floats
This is a strangely complicated topic, and I want to implement my own functions to help compare float/double numbers to one another.

This is mostly necessary for comparing two equal-length collections of float values. This pops up a lot when doing geometry calculations due to vector and matrix operations, which are represented with [Clojure vectors] in Forge.

Since I will also need to check if float values are near zero, I'll have a special function specifically for that. This is necessary because of how floating point values are represented. The zero case is special, so I have a function for it.

NOTE: Provide more clear explanation about floating point comparisons AND my implementation choice. In particular, talk about relativeMax and why I did NOT use ULP methods.

The implementation is taken from:
[[https://floating-point-gui.de/errors/NearlyEqualsTest.java]]

This, like any float comparison implementation, is not guaranteed to be useful in all contexts.

It is sufficient for Forge for the following reasons:
- it is used near zero most often
- it is unlikely to be used when handling values much larger than 10,000 in magnitude due to typical scales of units in engineering projects.

#+begin_src clojure :tangle ./src/forge/utils.cljc
(defn nearly?
  "compare two float values for approximate equality.
   
   Default epsilon = 0.00001"
  ([^double a ^double b]
   (nearly? a b 0.00001))

  ([^double a ^double b ^double epsilon]
   (let [a (float a)
         b (float b)]
     (if (= a b)
       true
       (let [absA (Math/abs a)
             absB (Math/abs b)
             diff (Math/abs (- a b))
             min-f 1.17549435E-38
             max-f 3.4028235E38]
         (if (or (= a 0.0) 
                 (= b 0.0) 
                 (< (+ absA absB) min-f))
           (< diff (* epsilon min-f))
           (< (/ diff (Math/min (+ absA absB) max-f)) epsilon)))))))

(defn all-nearly?
  "check if all numbers are nearly equal to one another in two collections"
  [coll-a coll-b]
  (if (not (= (count coll-a) (count coll-b)))
    #?(:clj  (throw (Exception. "collections must be same size."))
       :cljs (throw (js/Error. "collections must be same size.")))
    (let [diffs (mapv #(float (Math/abs ^double (- %1 %2))) coll-a coll-b)]
      (empty? 
       (filter 
        false? 
        (map zeroish? diffs))))))

#+end_src

*** zeroish?
#+begin_src clojure :tangle ./src/forge/utils.cljc
(defn my-zeroish?
  [x]
  (let [eps 0.00001]
    (< (Math/abs x) eps)))

#+end_src

To make sure float checks work, I'm implementing unit tests.

The tests here are taken from:
[[https://floating-point-gui.de/errors/NearlyEqualsTest.java]]

and re-implemented with clojure.test library.

*** float-comparison-tests
#+begin_src clojure
(deftest nearly-test
  (testing "Regular large numbers"
    (is      (nearly? (float 1000000) (float 1000001)))
    (is      (nearly? (float 1000001) (float 1000000)))
    (is (not (nearly? (float 10000) (float 10001))))
    (is (not (nearly? (float 10001) (float 10000)))))
  (testing "Negative large numbers"
    (is      (nearly? (float -1000000) (float -1000001)))
    (is      (nearly? (float -1000001) (float -1000000)))
    (is (not (nearly? (float -10000) (float -10001))))
    (is (not (nearly? (float -10001) (float -10000)))))
  (testing "Numbers around 1"
    (is      (nearly? (float 1.0000001) (float 1.0000002)))
    (is      (nearly? (float 1.0000002) (float 1.0000001)))
    (is (not (nearly? (float 1.0001) (float 1.0002))))
    (is (not (nearly? (float 1.0002) (float 1.0001)))))
  (testing "Numbers around -1"
    (is      (nearly? (float -1.0000001) (float -1.0000002)))
    (is      (nearly? (float -1.0000002) (float -1.0000001)))
    (is (not (nearly? (float -1.0001) (float -1.0002))))
    (is (not (nearly? (float -1.0002) (float -1.0001)))))
  (testing "Numbers between 1 and 0"
    (is      (nearly? (float 0.000000001000001) (float 0.000000001000002)))
    (is      (nearly? (float 0.000000001000002) (float 0.000000001000001)))
    (is (not (nearly? (float 0.000000000001001) (float 0.000000000001002))))
    (is (not (nearly? (float 0.000000000001002) (float 0.000000000001001)))))
  (testing "Numbers between -1 and 0"
    (is      (nearly? (float -0.000000001000001) (float -0.000000001000002)))
    (is      (nearly? (float -0.000000001000002) (float -0.000000001000001)))
    (is (not (nearly? (float -0.000000000001001) (float -0.000000000001002))))
    (is (not (nearly? (float -0.000000000001002) (float -0.000000000001001)))))
  (testing "Small differences away from zero"
    (is (nearly? (float 0.3) (float 0.30000003)))
    (is (nearly? (float -0.3) (float -0.30000003))))
  (testing "Comparisons involving zero"
    (is      (nearly? (float 0.0) (float 0.0)))
    (is      (nearly? (float 0.0) (float -0.0)))
    (is      (nearly? (float -0.0) (float -0.0)))
    (is (not (nearly? (float 0.00000001) (float 0.0))))
    (is (not (nearly? (float 0.0) (float 0.00000001))))
    (is (not (nearly? (float -0.00000001) (float 0.0))))
    (is (not (nearly? (float 0.0) (float -0.00000001))))
    (is      (nearly? (float 0.0) (float 1e-40) (float 0.01)))
    (is      (nearly? (float 1e-40) (float 0.0) (float 0.01)))
    (is (not (nearly? (float 0.0) (float 1e-40) (float 0.000001))))
    (is (not (nearly? (float 1e-40) (float 0.0) (float 0.000001))))
    (is      (nearly? (float 0.0) (float -1e-40) (float 0.1)))
    (is      (nearly? (float -1e-40) (float 0.0) (float 0.1)))
    (is (not (nearly? (float 0.0) (float -1e-40) (float 0.00000001))))
    (is (not (nearly? (float -1e-40) (float 0.0) (float 0.00000001))))))

#+end_src

** vector-arithmetic
#+begin_src clojure :tangle ./src/forge/utils.cljc
(def v+ (partial mapv +))
(def v- (partial mapv -))
(def v* (partial mapv *))

#+end_src

** math-utils
#+begin_src clojure :tangle ./src/forge/utils.cljc
(def abs #?(:clj #(Math/abs %)  :cljs js/Math.abs))
(def pow #?(:clj #(Math/pow %1 %2) :cljs js/Math.pow))

(defn to-deg
  [rad]
  (* rad (/ 180 Math/PI)))

(defn to-rad
  [deg]
  (* deg (/ Math/PI 180)))

(def ^:dynamic *rounding* nil)
(defn round
  "Rounds a non-integer number `num` to `places` decimal places."
  ([num]
   (round num *rounding*))
  ([num places]
   (if places
     (let [d #?(:clj (bigdec (Math/pow 10 places))
                :cljs (Math/pow 10 places))]
       (double (/ (Math/round (* num d)) d)))
     num)))

(defn sign
  "returns -1 if x is less than 0, 0 if x is 0 and 1 if x is greater"
  [x]
  (cond
    (or (= 0.0 x) (= 0 x)) 0
    (< 0 x) 1
    (> 0 x) -1))

(defn average
  [& numbers]
  (let [n (count numbers)]
    (/ (apply + numbers) n)))

(defn sq
  [x]
  (* x x))

(defn clamp
  "clamps a value between lower bound and upper bound"
  [x lb ub]
  (cond
    (< x lb) lb
    (> x ub) ub
    :else x))

(defn add-z
  [pt]
  (let [dim (count pt)]
    (if (< dim 3)
      (conj (vec pt) 0)
      pt)))

(defn flip-y
  [pts]
  (map #(v* % [1 -1]) pts))

#+end_src

** list-manipulations
#+begin_src clojure :tangle ./src/forge/utils.cljc
(defn vec-diff
  "returns the collection difference of two vectors"
  [v1 v2]
  (vec (into #{} (concat v1 v2))))

(defn vec-inner-pop
  "pop the item at index from the collection"
  [coll ind]
  (into [] (conj (subvec coll 0 ind) (subvec coll (inc ind)))))

(defn push-new
  "push item onto vector if it doesn't already exist."
  [v n]
  (if (some #{n} v)
    v
    (conj v n)))

(defn concat-new
  "concat two vectors together pushing only unique items."
  [a b]
  (reduce push-new a b)) 

#_(defn position
  "returns index of first match to item in the src vector. Otherwise nil"
  [src item]
  (let [res (.indexOf src item)]
    (when (>= res 0)
      res)))

#_(defn link
  "Swap an item for it's index in a different list"
  [src item]
  (let [type-k (first item)
        vals (rest item)]
    (vec (conj (map #(position src %) vals) type-k))))

(defn unlink
  "Swap an item's idx for it's value in a different list"
  [src item]
  (let [type-k (first item)
        indices (rest item)]
    (vec (conj (map #((vec src) %) indices) type-k))))

#+end_src

** geometry-calculations
#+begin_src clojure :tangle ./src/forge/utils.cljc
(defn distance
  "compute distance between two points"
  [a b]
  (let [v (v- b a)
        v2 (reduce + (v* v v))]
    (Math/sqrt ^double v2)))

(defn distance-squared
  [a b]
  (let [v (v- b a)]
    (reduce + (v* v v))))

(defn slope
  [[ax ay] [bx by]]
  (/ (- by ay) (- bx ax)))

(defn perpendicular
  [[x y]]
  [(- y) x])

(defn determinant
  [[ax ay] [bx by]]
  (- (* ax by)
     (* ay bx)))

(defn dot*
  "calculates the dot product of two vectors"
  [a b]
  (reduce + (map * a b)))

(defn cross*
  "calculates cross product of two 3d-vectors"
  [a b]
  (let [[a1 a2 a3] a
        [b1 b2 b3] b
        i (- (* a2 b3) (* a3 b2))
        j (- (* a3 b1) (* a1 b3))
        k (- (* a1 b2) (* a2 b1))]
    [i j k]))

(defn cross*-k
  "Calculates the k component of the cross product of two 2D vectors, assuming Z=0 as the 3rd component."
  [[ax ay] [bx by]]
  (- (* ax by) (* ay bx)))

(defn normal
  "Calculates the normal vector of plane given 3 points or calculates the normal vector of a line given two (2D) points."
  ([a b]
   (let [[x1 y1] a
         [x2 y2] b
         dx (- x2 x1)
         dy (- y2 y1)]
     [(- dy) dx]))
  ([a b c]
   (let [eps 0.00001
         ab (v- a b)
         ac (v- a c)
         [x y z] (cross* (add-z ab) (add-z ac))]
     (when (or (> (abs x) eps) (> (abs y) eps) (> (abs z) eps))
       [x y z]))))

(defn normalize
  "find the unit vector of a given vector"
  [v]
  (when v
    (let [m (Math/sqrt ^double (reduce + (v* v v)))]
      (mapv / v (repeat m)))))

#+end_src

** rotate-pt
#+begin_src clojure :tangle ./src/forge/utils.cljc
(defn sin-cos-pair [theta]
  [(Math/sin ^long (to-rad theta))
   (Math/cos ^long (to-rad theta))])

(defn rot-pt-2d
  [[x y] theta]
  (let [[s-t c-t] (sin-cos-pair theta)]
    [(- (* x c-t) (* y s-t))
     (+ (* y c-t) (* x s-t))]))

;; this rotates a point around [0,0,0]
(defn rot-pt
  [[x y z] axis theta]
  (cond
    (= axis :x) (into [x] (rot-pt-2d [y z] theta))
    (= axis :y) (apply #(into [] [%2 y %1]) (rot-pt-2d [z x] theta))
    (= axis :z) (into (rot-pt-2d [x y] theta) [z])))

(defn rotate-pt
  [pt [ax ay az]]
  (let [pt (if (< (count pt) 3)
             (conj pt 0)
             pt)]
    (-> pt
        (rot-pt :z az)
        (rot-pt :y ay)
        (rot-pt :x ax))))
#+end_src

** scale-pt
#+begin_src clojure :tangle ./src/forge/utils.cljc
(defn scale-pt
  [pt [sx sy sz]]
  (v* pt [sx sy sz]))

(defn scale-pt-from-center
  [[x y z] [sx sy sz] [cx cy cz]]
  [(+ (* (- x cx) sx) cx)
   (+ (* (- y cy) sy) cy)
   (+ (* (- z cz) sz) cz)])

#+end_src

** regular-polygon-pts
#+BEGIN_SRC clojure :tangle ./src/forge/utils.cljc
(defn regular-polygon-pts
  [r n]
  (let [angle (* 2 Math/PI (/ 1 n))]
    (for [step (range n)]
      [(* r (Math/cos (* step angle)))
       (* r (Math/sin (* step angle)))])))
#+END_SRC

** random-pts
#+BEGIN_SRC clojure :tangle ./src/forge/utils.cljc
(defn random-pts
  [w h n]
  (let [[wh hh] (map #(/ % 2) [w h])
        f #(vector (rand-int w) (rand-int h))]
    (->> (repeatedly n f)
         (map #(v- % [wh hh])))))

#+END_SRC

** on-line?
#+begin_src clojure :tangle ./src/forge/utils.cljc
(defn on-line?
  "determine if a point is on a capped line"
  [pt line]
  (let [[a b] line
        ap (add-z (v- a pt))
        bp (add-z (v- b pt))]
    (if (or (all-nearly? pt a) 
            (all-nearly? pt b))
      true
      (let [na (normalize ap)
            nb (normalize bp)]
        (and 
         (all-nearly? (cross* ap bp) [0 0 0]) 
         (not (all-nearly? na nb)))))))

(defn on-line-inf?
  "determine if a point is on an infinitely extending line"
  [pt line]
  (let [[a b] line
        ap (add-z (v- a pt))
        bp (add-z (v- b pt))]
    (all-nearly? (cross* ap bp) [0 0 0])))

#+end_src

** edges-from-pts
#+begin_src clojure :tangle ./src/forge/utils.cljc
(defn edges
  [pts]
  (vec (partition 2 1 (concat pts [(first pts)]))))

#+end_src

** centroid-of-pts
#+begin_src clojure :tangle ./src/forge/utils.cljc
(defn centroid-of-pts
  "Calculates the arithmetic mean position of the given `pts`."
  [pts]
  (let [ndim (count (first (sort-by count pts)))
        splits (for [axis (range 0 ndim)]
                 (map #(nth % axis) pts))]
    (mapv #(apply average %) splits)))

#+end_src

** bounds-of-pts
#+begin_src clojure :tangle ./src/forge/utils.cljc
(defn bounds-of-pts
  "Calculates the axis-aligned-bounding-box of 2D points, `pts`."
  [pts]
  (let [xmax (apply max (map first pts))
        ymax (apply max (map second pts))
        xmin (apply min (map first pts))
        ymin (apply min (map second pts))]
    (vector [xmin ymin]
            [xmax ymin]
            [xmax ymax]
            [xmin ymax])))

(defn bb-dims
  [pts]
  (let [[[xmin ymin] _ [xmax ymax] _] (bounds-of-pts pts)]
    [(- xmax xmin) (- ymax ymin)]))

#+end_src

** radius-from-pts
#+begin_src clojure :tangle ./src/forge/utils.cljc
(defn radius-from-pts
  "compute the radius of an arc defined by 3 points"
  [p1 p2 p3]
  (when-not (on-line? p1 [p2 p3])
    (let [a (distance p3 p2)
          b (distance p3 p1)
          c (distance p2 p1)
          s (/ (+ a b c) 2)
          sa ( - s a)
          sb ( - s b)
          sc ( - s c)
          rt (Math/sqrt ^double (* s sa sb sc))
          radius (/ (/ (* a b c) 4) rt)]
      radius)))

#+end_src

** angle-from-pts
#+begin_src clojure :tangle ./src/forge/utils.cljc
;; https://math.stackexchange.com/questions/361412/finding-the-angle-between-three-points
(defn angle-from-pts-old
  [p1 p2 p3]
  (let [eps 0.00001
        v1 (v- p2 p1)
        v2 (v- p2 p3)
        l1 (distance p1 p2)
        l2 (distance p3 p2)
        n (dot* v1 v2)
        d (Math/abs ^double (* l1 l2))]
    (when (> d eps)
      (to-deg (Math/acos ^double (/ n d))))))

;; https://math.stackexchange.com/questions/361412/finding-the-angle-between-three-points
(defn- check-quadrants
  "Using `p2` as the 'origin', return a string indicating positive, negative, or axis-aligned for p1 p2."
  [p1 p2 p3]
  (let [v1 (v- p1 p2)
        v2 (v- p3 p2)
        qf (fn [[x y]]
             (cond (and (pos? x) (pos? y)) "pp"
                   (and (pos? x) (neg? y)) "pn"
                   (and (neg? x) (neg? y)) "nn"
                   (and (neg? x) (pos? y)) "np"
                   (pos? x) "p_"
                   (neg? x) "n_"
                   (pos? y) "_p"
                   (neg? y) "_n"))]
    (apply str (map qf [v1 v2]))))

(defn angle-from-pts
  "Calculates the angle starting at line p3p2 going to line p1p2.
Put another way, the angle is measured following the 'right hand rule' around p2."
  [p1 p2 p3]
  (let [v1 (v- p1 p2)
        v2 (v- p3 p2)
        [v1nx v1ny] (normalize v1)
        [v2nx v2ny] (normalize v2)
        l1 (distance p1 p2)
        l2 (distance p3 p2)
        n (dot* v1 v2)
        d (* l1 l2)]
    (when-not (zeroish? (float d))
      (let [a (to-deg (Math/acos (/ n d)))
            quadrants (check-quadrants p1 p2 p3)]
        (cond
          ;; same quadrant, checking if V2 is before or after V1
          (and (= "pppp" quadrants) (> v2nx v1nx)) a
          (and (= "npnp" quadrants) (> v2nx v1nx)) a
          (and (= "nnnn" quadrants) (< v2nx v1nx)) a
          (and (= "pnpn" quadrants) (< v2nx v1nx)) a
          ;; within same quadrant
          (#{"p_p_" "ppp_" "_ppp" "p_pn"} quadrants) a 
          (#{"_p_p" "np_p" "n_np"} quadrants) a
          (#{"n_n_" "nnn_" "_nnn"} quadrants) a
          (#{"_n_n" "pn_n" "pnp_"} quadrants) a
          ;; one quadrant away
          (#{"npp_" "nn_p" "pnn_" "pp_n"} quadrants) a
          (#{"n_pp" "_nnp" "p_nn" "_ppn"} quadrants) a
          (#{"nppp" "nnnp" "pnnn" "pppn"} quadrants) a
          ;; 90 degrees away on axes
          (#{"_pp_" "n__p" "_nn_" "p__n"} quadrants) a
          ;; two quadrants away
          (and (= "ppnn" quadrants) (> (Math/abs v1nx) (Math/abs v2nx))) a
          (and (= "nnpp" quadrants) (> (Math/abs v1nx) (Math/abs v2nx))) a
          (and (= "pnnp" quadrants) (< (Math/abs v1nx) (Math/abs v2nx))) a
          (and (= "nppn" quadrants) (< (Math/abs v1nx) (Math/abs v2nx))) a
          ;; 180 degrees away on axes
          (#{"p_n_" "_p_n" "n_p_" "_n_p"} quadrants) a
          :else (- 360 a))))))

#+end_src

** arc-center-from-pts
#+begin_src clojure :tangle ./src/forge/utils.cljc
;; https://math.stackexchange.com/a/1743505
(defn arc-center-from-pts
  "compute the center point of an arc through 3 points"
  [p1 p2 p3]
  (when-not (on-line? p1 [p2 p3])
    (let [u1 (mapv - p2 p1)
          u2 (mapv - p3 p1)
          w1 (cross* (mapv - p3 p1) u1)
          u (normalize u1)
          w (normalize w1)
          v (cross* w u)
          [bx by] [(dot* u1 u) 0]
          [cx cy] [(dot* u2 u) (dot* u2 v)]
          h (/ (+ (sq (- cx (/ bx 2))) (sq cy) (- 0 (sq (/ bx 2)))) 
               (* 2 cy))]
      (v+ p1 
          (v* (repeat (/ bx 2)) u) 
          (v* (repeat h) v)))))

#+end_src

** corner-condition
#+begin_src clojure :tangle ./src/forge/utils.cljc
(defn corner-condition
  [a b c]
  (let [ba (v- a b)
        bc (v- c b)
        eps 0.000001
        k (cross*-k ba bc)]
    (cond
      (> eps (abs k)) :colinear
      (< eps k) :reflex
      (> (- eps) k) :convex)))

#+end_src

** planar?
#+begin_src clojure :tangle ./src/forge/utils.cljc
(defn on-plane?
  "determine if a point is on a plane"
  [pt plane]
  (let [a (map - pt (first plane))
        n (normal (first plane) (second plane) (nth plane 2))]
    (nearly? (Math/abs ^long (dot* a n)) 0)))

(defn plane-triple
  "gets a list of 3 points on a plane from a list of points"
  [pts]
  (if (< (count pts) 3) nil
    (let [[a b c] pts]
      (if (on-line? c [a b]) 
        (plane-triple (vec-inner-pop pts 2))
        [a b c]))))

(defn planar?
  "checks if all points in a list share a plane"
  [pts]
  (cond
    (< (count pts) 3) false
    (= (count pts) 3) (let [a (first pts)
                            b (second pts)
                            c (nth pts 2)]
                        (if (on-line? c [a b]) false true))
    :else (let [plane (plane-triple pts)
                chk-pts (vec-diff plane pts)]
            (every? #(= % true) (mapv #(on-plane? % plane) chk-pts)))))
#+end_src

** colinear? 
#+begin_src clojure :tangle ./src/forge/utils.cljc
(defn colinear?
  [a b c]
  (let [ba (v- a b)
        bc (v- c b)
        eps 0.000001]
    (> eps (abs (cross*-k ba bc)))))

#+end_src

** pt-inside?
#+begin_src clojure :tangle ./src/forge/utils.cljc
;; https://youtu.be/hTJFcHutls8?t=1473
;; use k component from cross product to quickly check if vector
;; is on right or left of another vector
;; check each triangle edge vector against corner to pt vectors
(defn pt-inside?
  [[a b c] pt]
  (let [ab (v- b a)
        bc (v- c b)
        ca (v- a c)
        apt (v- pt a)
        bpt (v- pt b)
        cpt (v- pt c)]
    (not
     (or (<= (cross*-k ab apt) 0)
         (<= (cross*-k bc bpt) 0)
         (<= (cross*-k ca cpt) 0)))))

(defn pt-on-perimeter?
  [[a b c] pt]
  (some true? (map #(on-line? pt %) (partition 2 1 [a b c a]))))
               
#+end_src

** rotation-scratch-quaternions-axis-angle-euler
#+begin_src clojure :tangle ./src/forge/utils.cljc
(defn axis-angle
  [va vb]
  (let [angle (-> (dot* (normalize va) (normalize vb))
                  Math/acos
                  to-deg)
        axis (normalize (cross* va vb))]
    [axis angle]))

(defn axis-angle->euler
  [axis angle]
  (let [eps 0.00001
        angle (to-rad angle)
        ah (/ angle 2.0)
        [x y z] (normalize axis)]
    (cond
      (and (pos? z) (< (abs (- 1 z)) eps)) ;; points up
      (mapv to-deg
            [0
             (/ Math/PI 2)
             (* 2 (Math/atan2 (* x (Math/sin ah)) (Math/cos ah)))])
      
      (and (neg? z) (< (abs (- 1 z)) eps)) ;; points down
      (mapv to-deg
            [0
             (/ Math/PI -2)
             (* -2 (Math/atan2 (* x (Math/sin ah)) (Math/cos ah)))])
      
      :else
      (mapv to-deg
            [(Math/atan2
              (- (* x (Math/sin angle)) (* y z (- 1 (Math/cos angle))))
              (- 1 (* (+ (* x x) (* z z)) (- 1 (Math/cos angle)))))
             (Math/asin (+ (* x y (- 1 (Math/cos angle))) (* z (Math/sin angle))))
             (Math/atan2
              (- (* y (Math/sin angle)) (* x z (- 1 (Math/cos angle))))
              (- 1 (* (+ (* y y) (* z z)) (- 1 (Math/cos angle)))))]))))

(defn axis-angle->quaternion
  [axis angle]
  (let [[ax ay az] (normalize axis)
        ha (/ (to-rad angle) 2.0)
        qx (* ax (Math/sin ha))
        qy (* ay (Math/sin ha))
        qz (* az (Math/sin ha))
        qw (Math/cos ha)]
    (normalize [qx qy qz qw])))

;; heading = Z
;; attitude = Y
;; bank = X
;; my own convention, probably should change and/or document it better
;; ZYX is application order, but vector returns [ax ay az] which is fed into (rotate ...)

(defn quaternion->euler
  [[qx qy qz qw]]
  (let [eps 0.00001
        pole (+ (* qx qy) (* qz qw))]
    (cond
      (< (abs (- pole 0.5)) eps) ;; pole close to 0.5 is N
      (mapv to-deg
            [0
             (/ Math/PI 2)
             (* 2 (Math/atan2 qx qw))])

      (< (abs (+ pole 0.5)) eps) ;; pole close to -0.5 is S
      (mapv to-deg
            [0
             (/ Math/PI -2)
             (* -2 (Math/atan2 qx qw))])

      :else
      (mapv to-deg
            [(Math/atan2 (- (* 2 qx qw) (* 2 qy qz)) (- 1 (* 2 qx qx) (* 2 qz qz)))
             (Math/asin (+ (* 2 qx qy) (* 2 qz qw)))
             (Math/atan2 (- (* 2 qy qw) (* 2 qx qz)) (- 1 (* 2 qy qy) (* 2 qz qz)))]))))

(defn euler
  [va vb]
  (->> (axis-angle va vb)
       (apply axis-angle->quaternion)
       quaternion->euler))

;; http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
(defn quaternion->axis-angle
  [q]
  (let [eps 0.00001
        [qx qy qz qw] (normalize q)
        angle (to-deg (* 2 (Math/acos qw)))
        s (Math/sqrt (- 1 (* qw qw)))]
    (if (< s eps)
      #_[[qx qy qz] angle] [[1 0 0] angle]
      [[(/ qx s) (/ qy s) (/ qz s)] angle])))

(defn rotate-pt-aa
  [pt axis angle]
  (let [angle (to-rad angle)
        axis (normalize axis)
        d (v* (repeat 3 (dot* axis pt)) axis)
        r (v- pt d)
        rp (v+ (v* r (repeat 3 (Math/cos angle)))
                     (v* (cross* axis r) (repeat 3 (Math/sin angle))))]
    (v+ d rp)))

;; https://stackoverflow.com/a/52551983
(defn look-at-quaternion
  [from to world-up]
  (let [world-up (normalize world-up)
        [fx fy fz :as forward] (normalize (v- from to))
        [rx ry rz :as right] (normalize (cross* world-up forward))
        [ux uy uz :as up] (cross* forward right)
        trace (+ rx uy fz)]
    (cond
      (> trace 0)
      (let [s (/ 0.5 (Math/sqrt (+ trace 1.0)))
            x (* (- uz fy) s)
            y (* (- fx rz) s)
            z (* (- ry ux) s)
            w (/ 0.25 s)]
        [x y z w])

      (and (> rx uy) (> rx fz))
      (let [s (* 2 (Math/sqrt (+ 1 rx (- uy) (- fz))))
            x (* 0.25 s)
            y (/ (+ ux ry) s)
            z (/ (+ fx rz) s)
            w (/ (- uz fy) s)]
        [x y z w])

      (> uy fz)
      (let [s (* 2 (Math/sqrt (+ 1 uy (- rx) (- fz))))
            x (/ (+ ux ry) s)
            y (* 0.25 s)
            z (/ (+ fy uz) s)
            w (/ (- fx rz) s)]
        [x y z w])

      :else
      (let [s (* 2 (Math/sqrt (+ 1 fz (- rx) (- uy))))
            x (/ (+ fx rz) s)
            y (/ (+ fy uz) s)
            z (* 0.25 s)
            w (/ (- ry ux) s)]
        [x y z w]))))

(defn transform-pt-quaternion
  [[px py pz] [x y z w]]
  [(+ (* w w px) (* 2 y w pz) (* -2 z w py) (* x x px)
      (* 2 y x py) (* 2 z x pz) (* -1 z z px) (* -1 y y px))

   (+ (* 2 x y px) (* y y py) (* 2 z y pz) (* 2 w z px)
      (* -1 z z py) (* w w py) (* -2 x w pz) (* -1 x x py))

   (+ (* 2 x z px) (* 2 y z py) (* z z pz) (* -2 w y px)
      (* -1 y y pz) (* 2 w x py) (* x x pz) (* w w pz))])

(defn axis-angle->quaternion
  [axis angle]
  (let [[ax ay az] (normalize axis)
        ha (/ (to-rad angle) 2.0)
        qx (* ax (Math/sin ha))
        qy (* ay (Math/sin ha))
        qz (* az (Math/sin ha))
        qw (Math/cos ha)]
    (normalize [qx qy qz qw])))

;; http://www.euclideanspace.com/maths/algebra/vectors/lookat/index.htm
(defn look-at-axis-angle
  [pt eye current target world-up]
  (let [world-up (normalize world-up)
        ncurrent (normalize (v- current eye))
        ntarget  (normalize (v- target eye))
        axis (cross* ncurrent ntarget)
        a1 (to-deg (dot* ncurrent ntarget))
        [a b c] target
        axis2 [(* (- a) b) (+ (* a a) (* c c)) (* (- c) b)]
        a2 (to-deg (Math/acos (dot* world-up axis2)))
        q1 (axis-angle->quaternion axis a1)
        q2 (axis-angle->quaternion axis2 a2)]
    (-> pt
        (transform-pt-quaternion q2)
        (transform-pt-quaternion q1))))

#+end_src

** transform-pt-by-matrix
#+begin_src clojure :tangle ./src/forge/utils.cljc
(defn- grc
  [m [r c]]
  (get-in m [c r]))

(defn transform-pt-matrix
  [pt m]
  (let [eps 0.00001
        [px py pz] pt
        x (+ (* px (grc m [0 0])) (* py (grc m [0 1])) (* pz (grc m [0 2])) (grc m [0 3]))
        y (+ (* px (grc m [1 0])) (* py (grc m [1 1])) (* pz (grc m [1 2])) (grc m [1 3]))
        z (+ (* px (grc m [2 0])) (* py (grc m [2 1])) (* pz (grc m [2 2])) (grc m [2 3]))
        w (+ (* px (grc m [3 0])) (* py (grc m [3 1])) (* pz (grc m [3 2])) (grc m [3 3]))]
    (if (and (not (zeroish? (- w 1)))
             (not (zeroish? w)))
      [(double (/ x w)) (double (/ y w)) (double (/ z w))]
      [x y z])))

#+end_src

** look-at-matrix
#+begin_src clojure :tangle ./src/forge/utils.cljc
(defn look-at-matrix
  [from to world-up]
  (let [w (normalize to)
        u (normalize (cross* world-up w))
        v (normalize (cross* w u))]
    (mapv vec [(concat u [0])
               (concat v [0])
               (concat w [0])
               (concat from [1])])))

#+end_src

** misc
#+BEGIN_SRC clojure :tangle ./src/forge/utils.cljc
(defn ext
  [fname]
  (last (str/split fname #"\.")))

#+END_SRC

* geom
** ns
#+begin_src clojure :tangle ./src/forge/geom.cljc
(ns forge.geom
  (:require [forge.utils :as utils]
            [forge.clip-ears :as clip-ears]
            [clojure.string :as str]
            [same :refer [ish? zeroish?]]))

#+end_src

** area
#+begin_src clojure :tangle ./src/forge/geom.cljc
(defn- triangle-area
  "compute the area of a triangle defined by three points"
  [[a b c]]
  ;; use Heron's formula
  (let [la (utils/distance b c)
        lb (utils/distance a c)
        lc (utils/distance a b)
        s (/ (+ la lb lc) 2)]
    (Math/sqrt ^double (* s (- s la) (- s lb) (- s lc)))))

(defn area
  [pts]
  (let [tris (:triangles (clip-ears/triangulate pts))]
    (->> pts
         clip-ears/triangulate
         :tris
         (map triangle-area)
         (reduce +))))

#+end_src

** line-intersection
#+begin_src clojure :tangle ./src/forge/geom.cljc
(defn line-intersection
  [[a b] [c d]]
  (let [[ax ay] a
        [bx by] b
        [cx cy] c
        [dx dy] d
        xdiff [(- ax bx) (- cx dx)]
        ydiff [(- ay by) (- cy dy)]
        div (utils/determinant xdiff ydiff)]
    (when-not (zeroish? (utils/abs div))
      (let [d [(utils/determinant a b) (utils/determinant c d)]
            x (/ (utils/determinant d xdiff) div)
            y (/ (utils/determinant d ydiff) div)]
        (mapv double [x y])))))

(defn line-segment-intersection
  [[a b] [c d]]
  (let [pt (line-intersection [a b] [c d])]
    (when
        (and pt
             (utils/on-line? (utils/add-z pt) (mapv utils/add-z [a b]))
             (utils/on-line? (utils/add-z pt) (mapv utils/add-z [c d])))
      pt)))

#+end_src

** polygon-intersection
For consideration:

- find a way to pre-filter lines out of the for loop to keep things more efficient.
  - two large polygons (in terms of number of points) will slow down the computation
- identical-polygon? is only going to be true when points are literally holding the same values. This is very unlikely to be true most of the time. A better solution is to use EPS and absolute distance... but here we might have inefficiencies due to sqrt in the distance calc.

#+begin_src clojure :tangle ./src/forge/geom.cljc
(defn- identical-polygon?
  [pga pgb]
  (= (into #{} pga)
     (into #{} pgb)))

(defn polygon-intersection
  [pga pgb]
  (when-not (identical-polygon? pga pgb)
    (let [lines-a (utils/edges pga)
          lines-b (utils/edges pgb)
          s (for [la lines-a
                  lb lines-b]
              (line-segment-intersection la lb))]
      (->> s
           (remove nil?)
           distinct
           #_vec))))

#_(let [pga (utils/regular-polygon-pts 120 200)
      #_[[0 0] [200 0] [0 200]]
      pgb (map #(utils/v+ % [50.0 100.0]) (utils/regular-polygon-pts 120 200)
               #_[[-100.0 100.0] [150.0 100.0] [150.0 -100.0]])
      xs (polygon-intersection pga pgb)]
  (svg-clj.tools/cider-show
   (svg-clj.elements/g
    (when (< 0 (count xs))
      (map #(-> (svg-clj.elements/circle 3)
                (svg-clj.transforms/translate %)
                (svg-clj.transforms/style {:fill "limegreen"})) xs))
    (-> (svg-clj.elements/polygon pga)
        (svg-clj.transforms/style {:fill "none" :stroke "blue"}))
    (-> (svg-clj.elements/polygon pgb)
        (svg-clj.transforms/style {:fill "none" :stroke "blue"})))))

#+end_src

** trim
#+begin_src clojure :tangle ./src/forge/geom.cljc
(defn trim
  "Trim line a using line b."
  [la lb]
  (let [x (line-segment-intersection la lb)]
    (when x
      [[(first la) x]
       [x (second la)]])))

(defn trim-at-pt
  [[a b] pt]
  (when (and
         (not= a pt)
         (not= b pt)
         (utils/on-line? (utils/add-z (mapv float pt)) (mapv utils/add-z [a b])))
    [[a pt]
     [pt b]]))

(defn trim-at-pts
  [[a b] pts]
  (let [pts (filter #(utils/on-line? % (mapv utils/add-z [a b])) (mapv utils/add-z pts))]
    (when (first pts)
      (->> pts
           (sort-by (partial utils/distance a))
           (mapv #(into [] (drop-last %)))
           (concat [a])
           (apply vector)
           (#(conj % b))
           (partition 2 1)
           (mapv vec)))))

#_(let [la [[0.0 0.0] [200.0 300.0]]
      lb [[0.0 120.0] [250.0 80.0]]
      [lc ld] (trim la lb)
      xs [(line-intersection la lb)]]
  (svg-clj.tools/cider-show
   (svg-clj.elements/g
    (when (< 0 (count xs))
      (map #(-> (svg-clj.elements/circle 3)
                (svg-clj.transforms/translate %)
                (svg-clj.transforms/style {:fill "limegreen"})) xs))
    (-> (svg-clj.elements/polyline la)
        (svg-clj.transforms/style {:fill "none" :stroke "blue"}))
    (-> (svg-clj.elements/polyline lb)
        (svg-clj.transforms/style {:fill "none" :stroke "blue"}))
    (-> (svg-clj.elements/polyline lc)
        (svg-clj.transforms/style {:fill "none" :stroke "red"}))
    (-> (svg-clj.elements/polyline ld)
        (svg-clj.transforms/style {:fill "none" :stroke "green"})))))

#+end_src

** polygon-union
#+begin_src clojure :tangle ./src/forge/geom.cljc
(defn endpoint?
  [l pt]
  (or (= (first l) pt)
      (= (second l) pt)))

(defn on-perimeter?
  [pg pt]
  (let [lines (utils/edges pg)]
    (> (count (filter (partial utils/on-line? pt) lines)) 0)))

(defn order-lines
  ([lines]
   (let [start (first (sort-by (comp second first) lines))]
     (order-lines lines start [start])))

  ([lines [_ b] sorted]
   (let [next (first (filter #(= b (first %)) lines))]
     (if (= (count lines) (count sorted))
       (mapv first sorted)
       (recur lines next (conj sorted next))))))

(defn pt-inside?
  [pg pt]
  (let [tris (:tris (clip-ears/triangulate pg))]
    (some true? (concat
                 (map #(utils/pt-on-perimeter? % pt) tris)
                 (map #(utils/pt-inside? % pt) tris)))))

(defn overlap?
  [pga pgb]
  (some true? (map #(pt-inside? pga %) pgb)))

(defn polygon-difference
  [pga pgb]
  (if (overlap? pga pgb)
    (let [in-b (filter #(pt-inside? pgb %) pga)
          in-a (filter #(pt-inside? pga %) pgb)
          rem-a (->> pga
                     (partition-by (set in-b))
                     (remove #((set in-b) (first %)))
                     reverse
                     (apply concat))
          rem-b (->> pgb
                     (partition-by (set in-a))
                     (remove #((set in-a) (first %)))
                     reverse
                     (apply concat))
          crossing-1 [[(last rem-a) (first in-b)]
                      [(last in-a) (first rem-b)]]
          crossing-2 [[(first rem-a) (last in-b)]
                      [(first in-a) (last rem-b)]]
          [i1 i2] (map #(apply line-segment-intersection %) [crossing-1 crossing-2])]
      (concat rem-a [i1] (reverse in-a) [i2]))
    pga))

(defn polygon-union
  [pga pgb]
  (when (overlap? pga pgb)
    (let [in-b (filter #(pt-inside? pgb %) pga)
          in-a (filter #(pt-inside? pga %) pgb)
          rem-a (->> pga
                     (partition-by (set in-b))
                     (remove #((set in-b) (first %)))
                     reverse
                     (apply concat))
          rem-b (->> pgb
                     (partition-by (set in-a))
                     (remove #((set in-a) (first %)))
                     reverse
                     (apply concat))
          crossing-1 [[(last rem-a) (first in-b)]
                      [(last in-a) (first rem-b)]]
          crossing-2 [[(first rem-a) (last in-b)]
                      [(first in-a) (last rem-b)]]
          [i1 i2] (map #(apply line-segment-intersection %) [crossing-1 crossing-2])]
      (concat rem-a [i1] rem-b [i2]))))

#+end_src


- there are cases where a segment has >1 intersection point along itself. Currently, it gets 'passed over' once a single trim has occurred on it. Technically, need some sort of iteration or recursion over this so that new trimmed segments are also checked for trims with other intersections

- perform trim on list of line segments. Iterate. When prev.list = latest list, stop iteration (this means all trims are complete)


- maikerusan123 suggests create a fn that will trim a line into any N segments given any N pts along it (basically, upgrade trim-at-pt to trim-at-pts)

** offset
#+begin_src clojure :tangle ./src/forge/geom.cljc
(defn offset-edge
  [[a b] d]
  (let [p (utils/perpendicular (utils/v- b a))
        pd (utils/v* (utils/normalize p) (repeat (- d)))
        xa (utils/v+ a pd)
        xb (utils/v+ b pd)]
    [xa xb]))

(defn- cycle-pairs
  [pts]
  (let [n (count pts)]
    (vec (take n (partition 2 1 (cycle pts))))))

(defn every-other
  [v]
  (let [n (count v)]
    (map #(get v %) (filter even? (range n)))))

(defn wrap-list-once
  [s]
  (conj (drop-last s) (last s)))

(defn offset-pts
  [pts d]
  (let [edges (cycle-pairs pts)
        opts (mapcat #(offset-edge % d) edges)
        oedges (every-other (cycle-pairs opts))
        edge-pairs (cycle-pairs oedges)]
    (wrap-list-once (map #(apply line-intersection %) edge-pairs))))
#+end_src

** hull
#+begin_src clojure :tangle ./src/forge/geom.cljc
(defn hull
  ([pts] (hull [{:pt (first (sort-by first pts))}] pts))
  ([acc pts]
   (if (or
        ;; stop the process if acc grows larger than the pts count
        (> (count acc) (count pts))
        ;; *should* always end where the last added point closes the poly
        (and (< 1 (count acc))
             (= (:pt (first acc)) (:pt (last acc)))))
     (map :pt (drop-last acc))
     (let [prev (:pt (last acc))
           dir (if (= 1 (count acc))
                 (utils/v+ [0 1] prev)
                 (:pt (last (drop-last acc))))
           f (fn [pt]
               (let [a (when (= 3 (count (into #{} [dir prev pt])))
                         (utils/angle-from-pts dir prev pt))]
                 {:pt pt :angle a}))
           sorted (->> (map f pts)
                       (remove #(nil? (:angle %)))
                       (sort-by #(utils/abs (- (:angle %) 180))))]
       (recur (conj acc (first sorted)) pts)))))

(defn nested-hull
  ([pts] (nested-hull [] pts))
  ([acc pts]
   (if (> 3 (count pts))
     acc
     (let [hull (hull pts)
           npts (remove (set hull) pts)]
       (recur (conj acc hull) npts)))))

#+end_src

* delaunay
This is (for now) a copy from:
https://github.com/trystan/delaunay-triangulation

I have to change this to work on 3D points. It currently drops any Z values.

#+BEGIN_SRC clojure :tangle ./src/forge/delaunay.cljc
(ns forge.delaunay
  (:require [clojure.set :as set]
            [forge.utils :as utils]))

;; https://gist.github.com/mutoo/5617691
(defn- circumscribe-tri
  [[[ax ay] [bx by] [cx cy]]]
  (let [A (- bx ax)
        B (- by ay)
        C (- cx ax)
        D (- cy ay)
        E (+ (* A (+ ax bx)) (* B (+ ay by)))
        F (+ (* C (+ ax cx)) (* D (+ ay cy)))
        G (* 2 (- (* A (- cy by)) (* B (- cx bx))))]
    (when (> (utils/abs G) 0.000001)
      (let [cx (/ (- (* D E) (* B F)) G)
            cy (/ (- (* A F) (* C E)) G)
            dx (- cx ax)
            dy (- cy ay)
            r  (+ (utils/pow dx 2) (utils/pow dy 2))]
        {:x cx :y cy :radius-squared r}))))

(defn- edges
  [pts]
  (partition 2 1 (conj (vec pts) (first pts))))

(defn- contains-pt?
  [{:keys [x y radius-squared]} [px py]]
  (let [distance-squared (utils/distance-squared [x y] [px py])]
    (< distance-squared radius-squared)))

(defn- outer-edges
  [tris]
  (let [all-edges (mapcat edges tris)
        matches (fn [edge] (filter #{edge (reverse edge)} all-edges))
        appears-once (fn [edge] (= (count (matches edge)) 1))]
    (filter appears-once all-edges)))

(defn- make-new-tris
  [containers pt]
  (->> containers
       outer-edges
       (map (fn [[p1 p2]] [p1 p2 pt]))
       set))

(defn- add-pt-to-tris
  [tris pt]
  (let [containers (filter #(contains-pt? (circumscribe-tri %) pt) tris)
        new-tris (make-new-tris containers pt)]
    (set/union (set/difference tris containers) new-tris)))

;; http://paulbourke.net/papers/triangulate/
(defn triangulate
  [pts]
  (let [pts (map (fn [[x y]] [(float x) (float y)]) pts)
        pt-indices (zipmap pts (range 0 (count pts)))
        [bl br tr tl] (map #(utils/v* % [2 2]) (utils/bounds-of-pts pts))
        initial #{[tl tr bl] [bl tr br]}
        with-bounds (reduce add-pt-to-tris initial pts)
        tris (remove #(some #{tl tr bl br} %) with-bounds)
        tri-indices (fn [tri] (mapv #(get pt-indices %) tri))]
    {:pts pts
     :tris tris
     :tri-indices (map tri-indices tris)
     :edges (distinct (mapcat edges tris))}))

#+END_SRC

* clip-ears
#+BEGIN_SRC clojure :tangle ./src/forge/clip_ears.cljc
(ns forge.clip-ears
  (:require [clojure.set]
            [forge.utils :as utils]))

(defn remove-colinears
  [pts]
  (let [indices (zipmap pts (range (count pts)))
        tris (partition 3 1 (concat pts (take 2 pts)))
        clpts (set (map second (filter #(apply utils/colinear? %) tris)))
        xindices (vals (apply dissoc indices clpts))]
    (map #(get pts %) xindices)))

(defn- clip-one-ear
  [pts]
  (let [pts (vec pts)
        indices (zipmap pts (range (count pts)))
        corners (->> pts
                     (#(concat % (take 2 %)))
                     (partition 3 1)
                     #_(filter #(#{:convex} (apply utils/corner-condition %))))
        clear? (fn [corner]
                 (not (seq (filter #(utils/pt-inside? corner %) pts))))
        tri (first (filter clear? corners))]
    {:pts pts
     :npts (mapv #(get pts %) (sort (vals (dissoc indices (second tri)))))
     :tri tri}))

(defn triangulate
  ([pts] (triangulate {:indices (zipmap pts (range (count pts)))} pts [] []))
  ([data pts tris indices]
   (if (< (count pts) 3)
     (merge data {:tris tris :tri-indices indices})
     (let [{:keys [npts tri]} (clip-one-ear pts)
           local-indices (mapv #(get (:indices data) %) tri)]
       (recur data npts (conj tris tri) (conj indices local-indices))))))

#+END_SRC

* frep
** ns
#+begin_src clojure :tangle ./src/forge/frep.cljc
(ns forge.frep
  (:require [forge.utils :as utils]
            [forge.geom :as geom]
            [forge.delaunay :as delaunay]
            [svg-clj.elements :as svg]
            [svg-clj.transforms :as tf]
            [svg-clj.tools :as tools]
            [clojure.string :as str]
            [same :refer [ish? zeroish?]]))

#+end_src

** union
#+BEGIN_SRC clojure :tangle ./src/forge/frep.cljc
(defn union [f g]
  (fn [pt]
    (let [a (f pt)
          b (g pt)]
      (min a b))))

#+END_SRC

** difference
#+BEGIN_SRC clojure :tangle ./src/forge/frep.cljc
(defn difference [f g]
  (fn [pt]
    (let [a (f pt)
          b (* -1 (g pt))]
      (max a b))))

#+END_SRC

** intersection
#+BEGIN_SRC clojure :tangle ./src/forge/frep.cljc
(defn intersection [f g]
  (fn [pt]
    (let [a (f pt)
          b (g pt)]
      (max a b))))

#+END_SRC

** pt
#+BEGIN_SRC clojure :tangle ./src/forge/frep.cljc
(defn pt
  ([x y]
   (fn [pt]
     (utils/distance [x y] pt)))
  ([x y z]
   (fn [pt]
     (utils/distance [x y z] pt))))

#+END_SRC

** line
#+BEGIN_SRC clojure :tangle ./src/forge/frep.cljc
(defn line
  [a b]
  (fn [pt]
    (let [pa (utils/v- pt a)
          ba (utils/v- b a)
          h (utils/clamp (/ (utils/dot* pa ba) (utils/dot* ba ba)) 0 1)]
      (utils/distance (utils/v- pa (utils/v* ba (repeat h))) [0 0 0]))))

#+END_SRC

** polyline
#+BEGIN_SRC clojure :tangle ./src/forge/frep.cljc
(defn polyline
  [pts]
  (let [lines (->> (partition 2 1 pts)
                   (map #(apply line %)))]
    (reduce union lines)))

#+END_SRC

** triangle
[[https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm]]

#+BEGIN_SRC clojure :tangle ./src/forge/frep.cljc
(defn triangle
  [a b c]
  (fn [pt]
    (let [[e0 e1 e2] (map #(apply utils/v- %) [[b a] [c b] [a c]])
          [v0 v1 v2] (map (partial utils/v- pt) [a b c])
          xf (fn [v e] 
               (utils/v- v (map * e (repeat (utils/clamp (/ (utils/dot* v e) (utils/dot* e e)) 0 1)))))
          [pq0 pq1 pq2] (map #(apply xf %) [[v0 e0] [v1 e1] [v2 e2]])
          s (utils/sign (- (* (first e0) (second e2)) (* (second e0) (first e2))))
          d1 (min (utils/dot* pq0 pq0)
                  (utils/dot* pq1 pq1)
                  (utils/dot* pq2 pq2))
          d2 (min (* s (- (* (first v0) (second e0)) (* (second v0) (first e0))))
                  (* s (- (* (first v1) (second e1)) (* (second v1) (first e1))))
                  (* s (- (* (first v2) (second e2)) (* (second v2) (first e2)))))]
      (* -1 (Math/sqrt d1) (utils/sign d2)))))

#+END_SRC

** rect
#+BEGIN_SRC clojure :tangle ./src/forge/frep.cljc
(defn rect
  [l w]
  (let [b [(/ l 2.0) (/ w 2.0)]]
    (fn [pt]
      (let [abs-pt (mapv #(Math/abs ^long %) pt)  
            d (utils/v- abs-pt b)]
        (+ (utils/distance (mapv #(max % 0) d) (repeat 0))
           (min (apply max d) 0))))))

#+END_SRC

** circle
#+BEGIN_SRC clojure :tangle ./src/forge/frep.cljc
(defn circle
  [r]
  (fn [pt]
    (- (utils/distance pt (repeat 0)) r)))

#+END_SRC

** polygon
My frep-polygon uses a triangulation/union approach. This did break for me in some cases, so I am going to test an alternate implementation. I will port this code:


https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm  (go to polygon - exact section)
https://www.shadertoy.com/view/wdBXRW


Every polygon function must work on & paths, not just a single list of points. This is to allow multi-shape paths (eg. a circle with a hole.)

As well, any polygon union should effectively produce the same polygon that would result from providing each path into one polygon call. That is...

(= (union (polygon pts-a) (polygon pts-b)) (polygon pts-a pts-b))


#+begin_src c

float sdPolygon( in vec2[N] v, in vec2 p )

{
    float d = dot(p-v[0],p-v[0]);
    float s = 1.0;

    for( int i=0, j=N-1; i<N; j=i, i++ )
    {
        vec2 e = v[j] - v[i];
        vec2 w =    p - v[i];
        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );
        d = min( d, dot(b,b) );

        bvec3 c = bvec3(p.y >= v[i].y,
                        p.y < v[j].y,
                        e.x * w.y > e.y * w.x);
        if( all(c) || all(not(c)) ) s*=-1.0;  
    }
    return s*sqrt(d);
}

#+end_src


alt conditional for checkign c

(or (every? identity c) (every? not c))


#+BEGIN_SRC clojure :tangle ./src/forge/frep.cljc









(defn polygon
  [pts]
  (let [tris (map #(apply triangle %) (geom/clip-ears pts))] 
    (reduce union tris)))












(defn polygon
  [pts]
  (fn [[px py :as pt]]
    (let [pts (vec pts)
          n (count pts)
          d1 (utils/dot* (utils/v- pt (first pts))
                           (utils/v- pt (first pts)))]
      (loop [i 0
             j (dec n)
             d d1
             s 1]
        (if (< i n)
          (let [[vix viy :as vi] (get pts i)
                [vjx vjy :as vj] (get pts j)
                [ex ey :as e] (utils/v- vj vi)
                [wx wy :as w] (utils/v- pt vi)
                [bx by :as b] (utils/v-
                               w
                               (mapv #(* % (utils/clamp 
                                            (/ (utils/dot* w e)
                                               (utils/dot* e e)) 0.0 1.0)) e))
                d (min d (utils/dot* b b))
                c [(>= py viy)
                   ( < py vjy)
                   ( > (* ex wy) (* ey wx))]
                s (if (= (count (into #{} c)) 1) (* s -1) (* s 1))]
            (recur (inc i) i d s))
          (* s (Math/sqrt d)))))))












#+END_SRC

** sphere
#+BEGIN_SRC clojure :tangle ./src/forge/frep.cljc
(defn sphere
  [r]
  (fn [pt]
    (- (utils/distance pt [0 0 0]) r)))

#+END_SRC

** cylinder
#+BEGIN_SRC clojure :tangle ./src/forge/frep.cljc
(defn cylinder [r h]
  (fn [pt]
    (let [[x y z] pt]
      (max (- (Math/sqrt (+ (utils/sq x) (utils/sq y))) r)
           (- z (/ h 2)) (- (/ h -2) z)))))

#+END_SRC

** box
#+BEGIN_SRC clojure :tangle ./src/forge/frep.cljc
(defn box [l w h]
  (fn [pt]
    (let [[x y z] pt
          [lh wh hh] (map #(/ % 2) [l w h])]
      (max (- x lh) (- (- lh) x)
           (- y wh) (- (- wh) y)
           (- z hh) (- (- hh) z)))))

#+END_SRC

** extrude
#+BEGIN_SRC clojure :tangle ./src/forge/frep.cljc
(defn extrude
  [frep h]
  (fn [pt]
    (let [d (frep (drop-last pt))
          w (- (Math/abs ^long (- (last pt) (/ h 2))) (/ h 2))]
      (+ (min (max d w) 0)
         (utils/distance [0 0] [(max d 0) (max w 0)])))))

#+END_SRC

** revolve
#+BEGIN_SRC clojure :tangle ./src/forge/frep.cljc
(defn revolve
  [f]
  (fn [pt]
    (let [q [(utils/distance [0 0] [(first pt) (second pt)])
             (last pt)]]
      (f q))))

#+END_SRC

** translate
#+BEGIN_SRC clojure :tangle ./src/forge/frep.cljc
(defn translate
  [f pos]
  (fn [pt]
    (f (utils/v+ pt pos))))

#+END_SRC

** rotate
#+BEGIN_SRC clojure :tangle ./src/forge/frep.cljc
(defn rotate
  [f angles]
  (fn [pt]
    (f (utils/rotate-point pt angles))))

#+END_SRC

** scale
#+BEGIN_SRC clojure :tangle ./src/forge/frep.cljc
(defn scale
  [f scales]
  (fn [pt]
    (f (utils/v* pt scales))))

#+END_SRC

* brep
** brep.curves
*** design
The parametric functions return a function expecting a parameter, denoted as t by convention.

Given a parametric function, you can pass in a parameter t with a value anywhere between 0 and 1. The function is then expected to return a position. It can be an n-dimensional position, but in SVG-CLJ, it is almost always 2D point [x y].

In my library, I am using a 0-arity call to any parametric function to return a map of details about that curve. This means that every function that 'constructs' one of these parametric functions must properly generate this map.

The required keys for the curve map are:

#+begin_src clojure
{:fn `fn-symbol
 :input [arg1 arg2 ...]
 :origin [0 0]
 :length "length of curve, exact if possible, estimated otherwise"
 :vertex-params "t values where the curve equals the input vertices."}
#+end_src

Additionally, it is required that any parametric function that modifies a function (transforms) also matches this 0-arity scheme. This is because certain algorithms will be built requiring data from these keys, in particular, :length is valuable to have basically pre-calculated when the curve is first created.

Finally, it must be true that (f 0) and (f 1) are valid points, not nil.

*** ns
#+begin_src clojure :tangle ./src/forge/brep/curves.cljc
(ns forge.brep.curves
  (:require [clojure.string :as str]
            [forge.utils :as utils]
            [forge.geom :as geom]
            [forge.delaunay :as delaunay]
            [forge.clip-ears :as clip-ears]))

#+end_src

*** parametric-validator
A utility for checking validity of a parametric function based on the design requirements, in particular of the zero-arity function.

There are also some checks for validity at (f 0) and (f 1) since the end conditions can sometimes get confusing and break down.

One assumption made is that (f 0.5) will be valid in terms of the dimensionality of the curve. For now, this is perhaps a sufficient assumption for checks.

This check does not determine yet if the implied function from :fn :input will be equivalent. This may be a feature to build into a full-check-parametric or something later on. For now, I'm not worrying about that.

#+begin_src clojure :tangle ./src/forge/brep/curves.cljc
(defn check-parametric
  [f]
  (let [fdata (try (f) (catch #?(:cljs :default :clj Exception) e))
        [f0 f05 f1] (map f [0 0.5 1])
        t0 (if (seqable? f0) f0 [f0])
        t05 (if (seqable? f05) f05 [f05])
        t1 (if (seqable? f1) f1 [f1])
        dim (count t05)
        required [:fn :input :vertex-params :dimension :length :origin]
        keys-pred (every? #(contains? fdata %) required)
        t0-pred (and t0 (= (count t0) dim) (every? number? t0))
        t1-pred (and t1 (= (count t1) dim) (every? number? t1))
        missing (when-not keys-pred (remove (set (keys fdata)) (set required)))
        result {:dimension dim
                :data fdata
                :valid-data keys-pred
                :valid-t0 t0-pred
                :valid-t1 t1-pred}]
    (cond-> result
      missing       (assoc-in [:error :missing] missing)
      (not fdata)   (assoc-in [:error :invalid-0-arity] fdata)
      (not t0-pred) (assoc-in [:error :invalid-t0] t0)
      (not t1-pred) (assoc-in [:error :invalid-t1] t1))))

(defn valid-parametric?
  [f]
  (nil? (:error (check-parametric f))))

#+end_src

*** arc-length
#+begin_src clojure :tangle ./src/forge/brep/curves.cljc
(defn arc-length
  ([curve] (arc-length curve 0 1))
  ([curve t]
   (let [eps 0.00001]
     (if (< eps t)
       (arc-length curve 0 t)
       0)))
  ([curve ta tb]
   (let [seg 13500
         start (/ (* ta seg) seg)
         end   (/ (inc (* tb seg)) seg)]
     (->> (range start end (/ 1 seg))
          (map curve)
          (partition 2 1)
          (map #(apply utils/distance %))
          (reduce +)
          (#(utils/round % 5))))))

#+end_src

*** tangent
#+begin_src clojure :tangle ./src/forge/brep/curves.cljc
(defn tangent
  [curve t]
  (let [eps 0.00001
        a (curve (- t eps))
        b (curve (+ t eps))
        a (if a a (curve 0))
        b (if b b (curve 1))]
    (-> (utils/v- b a)
        (utils/normalize))))

#+end_src

*** normal
#+begin_src clojure :tangle ./src/forge/brep/curves.cljc
(defn normal
  [curve t up]
  (let [tangent (tangent curve t)
        binormal (utils/normalize (utils/cross* up tangent))]
    (utils/cross* tangent binormal)))

#+end_src

*** remap
#+begin_src clojure :tangle ./src/forge/brep/curves.cljc
(defn- remap-within
  ([[start end] x] (remap-within identity [start end] x))
  ([f [start end] x]
   (when (and (>= x start) (< x end))
     (let [step (- end start)
           t (/ (- x start) step)]
       (f t)))))

#+end_src

*** line
#+begin_src clojure :tangle ./src/forge/brep/curves.cljc
(defn line
  [a b]
  (fn
    ([] {:fn `line
         :input [a b]
         :origin (utils/centroid-of-pts [a b])
         :vertex-params [0 1]
         :dimension (count a)
         :length (utils/distance a b)})
    ([t]
     (cond
       (= (float t) 0.0) a
       (= (float t) 1.0) b
       :else
       (utils/v+ a (utils/v* (utils/v- b a) (repeat t)))))))

(defn fastline
  [a b]
  (let [[vx vy] (utils/v- b a)]
    (fn [t]
      (utils/v+ a (utils/v* (utils/v- b a) (repeat t))))))

#+end_src

*** polyline
#+begin_src clojure :tangle ./src/forge/brep/curves.cljc
(defn polyline
  [pts]
  (let [step (/ 1.0 (dec (count pts)))
        lines (map (partial apply line) (partition 2 1 pts))
        length (reduce + (map #(:length (%)) lines))
        intervals (->> lines
                       (map #(:length (%)))
                       (reductions +)
                       (concat [0])
                       (map #(/ % length))
                       (partition 2 1))]
    (fn
      ([] {:fn `polyline
           :input [pts]
           :origin [0 0 0] #_(utils/centroid-of-pts pts)
           :vertex-params (concat [0] (mapv second intervals))
           :dimension (count (first pts))
           :length length})
      ([t]
       (cond
         (= (float t) 0.0) (first pts)
         (= (float t) 1.0) (last pts)
         :else
         (first
          (filter some?
                  (map #(remap-within %1 %2 t) lines intervals))))))))

#+end_src

*** polygon
#+begin_src clojure :tangle ./src/forge/brep/curves.cljc
(defn polygon
  [pts]
  (let [pts (concat (vec pts) [(first pts)])
        step (/ 1.0 (dec (count pts)))
        lines (map (partial apply line) (partition 2 1 pts))
        length (reduce + (map #(:length (%)) lines))
        intervals (->> lines
                       (map #(:length (%)))
                       (reductions +)
                       (concat [0])
                       (map #(/ % length))
                       (partition 2 1))]
    (fn
      ([] {:fn `polygon
           :input [pts]
           :origin [0 0 0] #_(utils/centroid-of-pts pts)
           :vertex-params (concat [0] (mapv second intervals))
           :dimension (count (first pts))
           :length (reduce + (map #(:length (%)) lines))})
      ([t]
       (cond
         (= (float t) 0.0) (first pts)
         (= (float t) 1.0) (last pts)
         :else
         (first
          (filter some?
                  (map #(remap-within %1 %2 t) lines intervals))))))))

#+end_src

*** circle
#+begin_src clojure :tangle ./src/forge/brep/curves.cljc
(defn circle
  ([r]
   (fn
     ([] {:fn `circle
          :input [r]
          :origin [0 0]
          :vertex-params [0]
          :dimension 2
          :length (* Math/PI 2 r)})
     ([t]
      (let [t (* 2 Math/PI t)
            x (* r (Math/cos t))
            y (* r (Math/sin t))]
        [x y]))))

  ([a b c]
   (let [[a b c] (map utils/add-z [a b c])
         n (utils/normalize (utils/normal a b c))
         r (utils/radius-from-pts a b c)
         cp (utils/arc-center-from-pts a b c)
         u (utils/normalize (utils/v- a cp))
         v (utils/cross* n u)]
     (fn
       ([] {:fn `circle
            :input [a b c]
            :origin cp
            :vertex-params [0]
            :dimension (count a)
            :length (* Math/PI 2 r)
            :radius r})
       ([t]
       (cond
         (or (< t 0.0) (> t 1.0)) nil
         (= (float t) 0.0) (vec (drop-last a))
         (= (float t) 1.0) (vec (drop-last a))
         :else
         (let [t (* 2 Math/PI t)]
           (mapv 
            #(utils/round % 5)
            (drop-last 
             (utils/v+ cp
                       (utils/v* (repeat (* r (Math/cos t))) u)
                       (utils/v* (repeat (* r (Math/sin t))) v)))))))))))

#+end_src

*** arc
#+begin_src clojure :tangle ./src/forge/brep/curves.cljc
(defn arc
  [a b c]
  (let [[a b c] (map utils/add-z [a b c])
        f (circle a b c)
        cp (utils/arc-center-from-pts a b c)
        angle (utils/angle-from-pts a cp c)
        r (utils/radius-from-pts a b c)]
    (fn
      ([] {:fn `arc
           :input [a b c]
           :origin cp
           :vertex-params [0 1]
           :dimension (count a)
           :length (* Math/PI 2 r (/ angle 360))
           :radius r
           :center cp})
      ([t]
       (let [t (* t (/ angle 360.0))]
         (f t))))))

#+end_src

*** ellipse
#+begin_src clojure :tangle ./src/forge/brep/curves.cljc
;; https://www.mathsisfun.com/geometry/ellipse-perimeter.html
;; uses 'Infinite Series 2' exact calc. using 4 terms.
(defn- ellipse-perimeter
  [rx ry]
  (let [h (/ (Math/pow (- rx ry) 2)
             (Math/pow (+ rx ry) 2))]
    (* Math/PI (+ rx ry)
       (+ 1
          (* h (/ 1 4))
          (* h h (/ 1 64))
          (* h h h (/ 1 256))))))

(defn ellipse
  [rx ry]
  (fn 
    ([] {:fn `ellipse
         :input [rx ry]
         :origin [0 0]
         :vertex-params [0]
         :dimension 2
         :length (ellipse-perimeter rx ry)})
    ([t]
     (let [t (* 2 Math/PI t)
           x (* rx (Math/cos t))
           y (* ry (Math/sin t))]
       [x y]))))

#+end_src

*** bezier
#+begin_src clojure :tangle ./src/forge/brep/curves.cljc
(defn- quadratic-bezier
  [a b c]
  (fn [t]
    (let [l1 (fastline a b)
          l2 (fastline b c)
          l3 (fastline (l1 t) (l2 t))]
      (l3 t))))

(defn- bezier*
  [pts]
  (if (= 3 (count pts))
    (apply quadratic-bezier pts)
    (let [lines (map #(apply fastline %) (partition 2 1 pts))] 
      (fn
        [t]
        (let [npts (map #(% t) lines)]
          ((bezier* npts) t))))))

(defn bezier
  [pts]
  (let [curve (bezier* pts)
        length (arc-length curve)]
    (fn
      ([] {:fn `bezier
           :input [pts]
           :origin (utils/centroid-of-pts pts)
           :dimension (count (first pts))
           :vertex-params [0 1]
           :length length})
      ([t] (curve t)))))

#+end_src

*** piecewise-curve
#+begin_src clojure :tangle ./src/forge/brep/curves.cljc
(defn piecewise-curve
  [curves]
  (let [step (/ 1.0 (count curves))
        intervals (partition 2 1 (range 0 (+ 1 step) step))
        remapf (fn [curve [start end]]
                 (let [vertex-params (:vertex-params (curve))
                       sc (- end start)]
                   (map #(+ start (* sc %)) vertex-params)))
        vertex-params (vec (distinct (mapcat remapf curves intervals)))
        origin (utils/centroid-of-pts (map #(:origin (%)) curves))
        length (reduce + (map #(:length (%)) curves))
        sample-curve (first curves)]
    (fn
      ([] {:fn `piecewise-curve
           :input [curves]
           :origin origin
           :dimension (count (sample-curve 0.5))
           :vertex-params vertex-params
           :length length})
      ([t]
       (cond
         (= (float t) 0.0) ((first curves) 0)
         (= (float t) 1.0) ((last curves) 1)
         :else
         (first
          (filter some?
                  (map #(remap-within %1 %2 t) curves intervals))))))))

#+end_src

*** rational-bezier
#+begin_src clojure :tangle ./src/forge/brep/curves.cljc
(defn- next-pascal
  [row]
  (vec (concat [(first row)]
          (mapv #(apply + %) (partition 2 1 row))
          [(last row)])))

(defn- binomial
  [n i]
  (let [pascal-tri-row (last (take (inc n) (iterate next-pascal [1])))]
  (get pascal-tri-row i)))

(defn- polynomial
  [n i t]
  (* (Math/pow (- 1 t) (- n i)) (Math/pow t i)))

(defn- half-bezier
  [ws t]
  (let [n (dec (count ws))
        poly (partial polynomial n)
        bi (partial binomial n)]
    (reduce + (map-indexed 
               (fn [i w]
                 (* (bi i) (poly i t) w))
               ws))))

(defn rational-bezier*
  [pts wts]
  (let [xs (map #(* (first %1) %2) pts wts)
        ys (map #(* (second %1) %2) pts wts)
        dn (partial half-bezier wts)]
    (fn [t]
      [(/ (half-bezier xs t) (dn t)) 
       (/ (half-bezier ys t) (dn t))])))

(defn rational-bezier
  [pts wts]
  (let [curve (rational-bezier* pts wts)
        length (arc-length curve)]
    (fn
      ([] {:fn `rational-bezier
           :input [pts wts]
           :origin (utils/centroid-of-pts pts)
           :dimension (count (first pts))
           :vertex-params [0 1]
           :length length})
      ([t] (curve t)))))

#+end_src

*** to-3D
#+begin_src clojure :tangle ./src/forge/brep/curves.cljc
(defn to-3D
  [curve]
  (let [data (curve)
        origin (utils/add-z (:origin data))]
    (if (< (:dimension data) 3)
      (fn
        ([] (merge data {:fn `to-3D
                         :input [curve]
                         :origin origin
                         :dimension 3}))
        ([t]
         (when (curve t)
           (vec (concat (curve t) [0])))))
      curve)))

#+end_src

*** translate
#+begin_src clojure :tangle ./src/forge/brep/curves.cljc
(defn translate
  [f [x y z]]
  (let [data (f)
        f (to-3D f)]
    (fn
      ([] (merge data
                 {:fn `translate
                  :origin (utils/v+ (utils/add-z (:origin data)) [x y z])
                  :dimension 3
                  :input [f [x y z]]}))
      ([t]
       (utils/v+ (utils/add-z (f t)) [x y z])))))

#+end_src

*** rotate
I need to update my requirements in my curves map design. I should include an :origin key so that rotations can be exact.

#+begin_src clojure :tangle ./src/forge/brep/curves.cljc
(defn rotate
  [f [ax ay az]]
  (let [data (f)
        f (to-3D f)
        ctr (utils/add-z (:origin data))
        dim 3]
    (fn
      ([] (merge data
                 {:fn `rotate
                  :input [f [ax ay az]]
                  :dimension dim}))
      ([t]
       (-> (f t)
           (utils/v+ (map - ctr))
           (utils/rotate-pt [ax ay az])
           (utils/v+ ctr))))))

#+end_src

*** scale
#+begin_src clojure :tangle ./src/forge/brep/curves.cljc
(defn scale
  [f [sx sy sz]]
  (let [data (f)
        ctr (:origin data)]
    (fn
      ([] (merge data
                 {:fn `scale
                  :input [f [sx sy sz]]}))
      ([t]
       (utils/scale-pt-from-center (f t) [sx sy sz] ctr)))))

#+end_src

*** cut-at
#+begin_src clojure :tangle ./src/forge/brep/curves.cljc
(defn cut-at-t
  "Cut curve at the parameter `t`, returning a curve from `t-start` (0 if unspecified) to `t-end`."
  ([curve t-end] (cut-at-t curve 0 t-end))
  ([curve t-start t-end]
   (let [data (curve)
         sc (- t-end t-start)
         length (arc-length t-start t-end)]
     (fn
       ([] (merge data {:fn `cut-at-t
                        :input [curve t-start t-end]
                        :length length}))
       ([t] (curve (+ (* t sc) t-start)))))))

(defn- get-t
  "Estimate curve parameter `t` that corresponds to length-percentage `target-lp`."
  [curve target-lp]
  (let [eps 0.00001
        length (:length (curve))
        target-l (* length target-lp)]
    (loop [t target-lp
           n 0]
        (let [next-t (+ t (/ (- target-l (arc-length curve t)) target-l))]
          (if (or
               (= (utils/round t 4) (utils/round next-t 4))
               (< (utils/abs (- target-l (arc-length curve t))) eps)
               (< 300 n))
            next-t
            (recur next-t (inc n)))))))

(defn cut-at-lp
  "Cut curve at length-percentage `lp`."
  ([curve l-end] (cut-at-lp curve 0 l-end))
  ([curve l-start l-end]
   (let [data (curve)
         t-start (get-t curve l-start)
         t-end (get-t curve l-end)
         sc (- t-end t-start)
         length (arc-length t-start t-end)]
     (fn
       ([] (merge data {:fn `cut-at-lp :input [curve l-start l-end]}))
       ([t] (curve (+ (* t sc) t-start)))))))

#+end_src

*** look-at
#+begin_src clojure :tangle ./src/forge/brep/curves.cljc
#_(defn look-at
  [f [px py pz] [ux uy uz]]
  (let [data (f)
        ctr (utils/add-z (:origin data))
        dim 3]
    (fn
      ([] (merge data
                 {:fn `look-at
                  :input [f [px py pz] [ux uy uz]]
                  :dimension dim}))
      ([t]
       (-> (f t)
           utils/add-z
           (transform-pt-quaternion (look-at-quaternion ctr [px py pz] [ux uy uz])))))))

(defn- aligned?
  [[ax ay az] [bx by bz]]
  (and (utils/my-zeroish? (Math/abs (- ax bx)))
       (utils/my-zeroish? (Math/abs (- ay by)))
       (utils/my-zeroish? (Math/abs (- az bz)))))

(defn find-up
  [c]
  (let [data (c)
        [a b c :as pts] (map c [0 0.333 0.667])
        is-line (utils/on-line-inf? a [b c])
        v1 (utils/normalize (utils/v- b a))]
    (cond
      (= (:dimension data) 2)
      [0 0 1]

      (not is-line)
      (-> (apply utils/normal pts)
          utils/normalize)

      (and is-line (aligned? v1 [0 0 1]))
      [0 1 0]
      
      :else
      [0 0 1])))

(defn look-at
  ([c target] (look-at c target (find-up c)))
  ([c target up]
   (let [data (c)
        ctr (utils/add-z (:origin data))
        dim 3]
    (fn
      ([] (merge data
                 {:fn `look-at
                  :input [c target up]
                  :origin ctr
                  :dimension dim}))
      ([t]
       (if (utils/colinear? (utils/normalize up) ctr target)
         (c t)
         (let [m (utils/look-at-matrix [0 0 0] (utils/v- target ctr) up)]
         (-> (c t)
             utils/add-z
             (utils/v- ctr)
             (utils/transform-pt-matrix m)
             (utils/v+ ctr)))))))))

#+end_src

** brep.surfaces
*** design
The brep surfaces functions return a function expecting two parameter, denoted as [u v] by convention.

Given a surface function, you can pass in u v params each with a value anywhere between 0 and 1. The function is then expected to return a position. It can be an n-dimensional position, but in forge, it is almost always 3D.

Surfaces are typically built up from curves, and so should have similar data requirements.

:vertex-params are interesting because they actually become pairs of uv params. These are critical for creating good meshes with curves and surfaces that maintain sharp edges along boundaries, at corners, etc.

*** ns
#+begin_src clojure :tangle ./src/forge/brep/surfaces.cljc
(ns forge.brep.surfaces
  (:require [clojure.string :as str]
            [forge.utils :as utils]
            [forge.geom :as geom]
            [forge.delaunay :as delaunay]
            [forge.clip-ears :as clip-ears]
            [forge.brep.curves :as c]))

#+end_src

*** parametric-validator
A utility for checking validity of a parametric function based on the design requirements, in particular of the zero-arity function.

There are also some checks for validity at (f 0 0) (f 0 1) (f 1 0) and (f 1 1) since the end conditions can sometimes get confusing and break down.

One assumption made is that (f 0.5 0.5) will be valid in terms of the dimensionality of the curve. For now, this is perhaps a sufficient assumption for checks.

This check does not determine yet if the implied function from :fn :input will be equivalent. This may be a feature to build into a full-check-parametric or something later on. For now, I'm not worrying about that.

#+begin_src clojure :tangle ./src/forge/brep/surfaces.cljc
(defn check-parametric
  [f]
  :not-implemented #_(let [fdata (try (f) (catch #?(:cljs :default :clj Exception) e))
        [f00 f01 f10 f11 f0505] (map f [[0 0] [0 1] [1 0] [1 1] [0.5 0.5]])
        t0 (if (seqable? f00) f0 [f0])
        t05 (if (seqable? f0505) f05 [f05])
        t1 (if (seqable? f1) f1 [f1])
        dim (count t05)
        required [:fn :input :vertex-params :length :origin]
        keys-pred (every? #(contains? fdata %) required)
        t0-pred (and t0 (= (count t0) dim) (every? number? t0))
        t1-pred (and t1 (= (count t1) dim) (every? number? t1))
        missing (when-not keys-pred (remove (set (keys fdata)) (set required)))
        result {:dimension dim
                :data fdata
                :valid-data keys-pred
                :valid-t0 t0-pred
                :valid-t1 t1-pred}]
    (cond-> result
      missing       (assoc-in [:error :missing] missing)
      (not fdata)   (assoc-in [:error :invalid-0-arity] fdata)
      (not t0-pred) (assoc-in [:error :invalid-t0] t0)
      (not t1-pred) (assoc-in [:error :invalid-t1] t1))))

(defn valid-parametric?
  [f]
  :not-implemented #_(nil? (:error (check-parametric f))))

#+end_src

*** curve-checking-helpers
#+begin_src clojure :tangle ./src/forge/brep/surfaces.cljc
(defn coincident?
  [a b]
  (let [eps 0.00001
        diffs (map #(utils/abs (- %1 %2)) a b)]
    (when (= (count a) (count b))
      (= #{true} (set (map #(< % eps) diffs))))))

(defn- closed?
  [curve]
  (coincident? (curve 0) (curve 1)))

(defn- coincidence-table
  [pts]
  (let [pt-index (zipmap (range (count pts)) pts)
        fh (fn [pta ptb]
             (let [result (coincident? pta ptb)]
               (list (vector [pta ptb] result)
                     (vector [ptb pta] result))))
        f (fn [idx pt]
            (let [ipts (vals (dissoc pt-index idx))]
              (into {} (mapcat #(fh pt %) ipts))))]
    (apply merge (map-indexed f pts))))

(defn- flip-second-curve?
  [a0 b0 b1]
  (and
   ;; don't flip closed curves as it might break user design intent
   (not (coincident? b0 b1))
   (< (utils/distance a0 b1) (utils/distance a0 b0))))

(defn- curve3D?
  [curve]
  (= 3 (count (curve 0))))

(defn reverse-curve
  [curve]
  (fn [t]
    (curve (- 1 t))))

#+end_src

*** 2curve-surfaces
#+begin_src clojure :tangle ./src/forge/brep/surfaces.cljc
(defn surface-along*
  [curve-a curve-b]
  (fn [u v]
    (utils/v+ (curve-a u) (curve-b v))))

(defn surface-between*
  [curve-a curve-b]
  (fn [u v]
    (let [l (c/line (curve-a u) (curve-b u))]
      (l v))))

(defn surface
  [curve-a curve-b]
  (let [curve-a (c/to-3D curve-a)
        curve-b (c/to-3D curve-b)
        [a0 a1] (map curve-a [0 1])
        [b0 b1] (map curve-b [0 1])
        flip (flip-second-curve? a0 b0 b1)
        curve-b (if flip (reverse-curve curve-b) curve-b)
        [b0 b1] (if flip [b1 b0] [b0 b1])
        ctable (coincidence-table [a0 a1 b0 b1])
        surf (cond
               ;; all vals false, no coincident points
               (not (seq (filter true? (vals ctable))))
               (surface-between* curve-a curve-b)
               
               ;; curves may be closed, but don't share start/end pts
               (and (not (ctable [a0 b0])) (not (ctable [a1 b1])))
               (surface-between* curve-a curve-b)
               
               ;; start and end points for each curve are coincident
               (and (ctable [a0 b0]) (ctable [a1 b1]))
               (surface-between* curve-a curve-b)
               
               ;; only start pts coincide
               (ctable [a0 b0])
               (surface-along* curve-a curve-b)
               
               ;; only end pts coincide
               (ctable [a1 b1])
               (surface-along* curve-a curve-b))]
    (fn
      ([] {:fn `surface
           :input [curve-a curve-b]
           :origin (surf 0.5 0.5)})
      ([u v] (surf u v)))))

#+end_src

*** bezier-patch
#+begin_src clojure :tangle ./src/forge/brep/surfaces.cljc
(defn- bezier-patch*
  ([apts bpts cpts] (bezier-patch* apts bpts cpts nil))
  ([apts bpts cpts dpts]
   (let [cpt-sets (remove nil? [apts bpts cpts dpts])
         curves (map c/bezier cpt-sets)]
       (fn [u v]
         (let [curve (c/bezier (map #(% u) curves))]
           (curve v))))))

(defn bezier-patch
  ([apts bpts cpts] (bezier-patch apts bpts cpts nil))
  ([apts bpts cpts dpts]
   (let [cpt-sets (remove nil? [apts bpts cpts dpts])
         curves (map c/bezier cpt-sets)
         surf (bezier-patch* apts bpts cpts dpts)
         origin (surf 0.5 0.5)]
     (fn
       ([] {:fn `bezier-patch
            :input [apts bpts cpts dpts]
            :origin origin})
       ([u v] (surf u v))))))

#+end_src

*** curve-extrusion-surfaces
#+begin_src clojure :tangle ./src/forge/brep/surfaces.cljc
(defn extrude-curve
  ([curve h] (extrude-curve curve [0 0 1] h))
  ([curve direction d]
   (let [curve (c/to-3D curve)
         v (utils/v* (utils/normalize direction) (repeat 3 d))]
     (fn
       ([] {:fn `extrude-curve
            :input [curve direction d]
            :origin (:origin (curve))})
       ([u v]
        (utils/v+ (curve u) (utils/v* v (repeat 3 (* d v)))))))))

#+end_src

*** planar-surfaces
#+begin_src clojure :tangle ./src/forge/brep/surfaces.cljc
(defn rect
  [w h]
  (let [[wh hh] (map #(/ % 2.0) [w h])
        uline (c/line [(- wh) (- hh)] [(+ wh) (- hh)])
        vline (c/line [(- wh) (- hh)] [(- wh) (+ hh)])]
    (fn
      ([] {:fn `rect
           :input [w h]
           :origin [(uline 0.5) (vline 0.5) 0]})
      ([u v]
       [(first (uline u))
        (second (vline v))
        0]))))

(defn circle
  [r]
  (let [perim (c/circle r)]
    (fn
      ([] {:fn `circle
           :input [r]
           :origin [0 0 0]})
      ([u v]
       (let [rad (c/line [0 0] (perim u))]
         (rad v))))))

(defn triangle
  [a b c]
  (let [ctr (utils/centroid-of-pts a b c)
        perim (c/polygon [a b c])]
    (fn
      ([] {:fn `triangle
           :input [a b c]
           :origin ctr})
      ([u v]
       (let [rad (c/line ctr (perim u))]
         (rad v))))))
#+end_src

*** spherical-surfaces
#+begin_src clojure :tangle ./src/forge/brep/surfaces.cljc
(defn sphere
  [r]
  (fn
    ([] {:fn `sphere
         :input [r]
         :origin [0 0 0]})
    ([u v]
     (let [[u v] (map #(* 2 Math/PI %) [u v])
           x (* r (Math/sin u) (Math/cos v))
           y (* r (Math/sin u) (Math/sin v))
           z (* r (Math/cos u))]
       [x y z]))))

#+end_src

*** translate
#+begin_src clojure :tangle ./src/forge/brep/surfaces.cljc
(defn translate
  [f [x y z]]
  (let [data (f)]
    (fn
      ([] (merge data
                 {:fn `translate
                  :origin (utils/v+ (:origin data) [x y z])
                  :dimension 3
                  :input [f [x y z]]}))
      ([u v]
       (utils/v+ (utils/add-z (f u v)) [x y z])))))

#+end_src

*** rotate
#+begin_src clojure :tangle ./src/forge/brep/surfaces.cljc
(defn rotate
  [f [ax ay az]]
  (let [data (f)
        ctr (:origin data)
        dim (if (and (= 0 ax) (= 0 ay)) (:dimension data) 3)]
    (fn
      ([] (merge data
                 {:fn `rotate
                  :input [f [ax ay az]]
                  :dimension dim}))
      ([u v]
       (-> (f u v)
           #_(utils/v+ (map - ctr))
           (utils/rotate-pt [ax ay az])
           #_(utils/v+ ctr))))))

#+end_src

*** extrude-along
#+begin_src clojure :tangle ./src/forge/brep/surfaces.cljc
(defn extrude-along
  ([xs path] (extrude-along xs path (c/find-up path)))
  ([xs path up]
   (let [xs (c/to-3D xs)
         path (c/to-3D path)
         data (path)
         origin (:origin data)]
     (fn
       ([] {:fn `extrude-along
            :input [xs path up]
            :origin origin
            :dimension 3})
       ([u v]
        (let [path-tangent (c/tangent path v)
              m (utils/look-at-matrix (path v) path-tangent up)]
          (-> (xs u)
              (utils/transform-pt-matrix m))))))))

(defn extrude-fn-along
  ([xsfn path] (extrude-fn-along xsfn path (c/find-up path)))
  ([xsfn path up]
   (let [path (c/to-3D path)
         data (path)
         origin (:origin data)]
     (fn
       ([] {:fn `extrude-fn-along
            :input [xsfn path up]
            :origin origin
            :dimension 3})
       ([u v]
        (let [xs (xsfn v)
              path-tangent (c/tangent path v)
              m (utils/look-at-matrix (path v) path-tangent up)]
          (-> (xs u)
              (utils/transform-pt-matrix m))))))))

#+end_src

*** revolve
#+begin_src clojure :tangle ./src/forge/brep/surfaces.cljc
#_(defn revolve
  ([xs] (revolve xs [[0 0 0] [0 0 1]]))
  ([xs [a b :as axis]]
   (let [up (utils/v- b a)
         path (-> (c/circle 2)
                  c/to-3D
                  (c/translate a)
                  (c/look-at b up))
         xs (c/to-3D xs)
         data (path)
         origin (:origin data)
         nup (c/find-up path)]
     (fn
       ([] {:fn `revolve
            :input [xs axis]
            :origin origin
            :dimension 3})
       ([u v]
        (let [path-tangent (c/tangent path v)
              m (utils/look-at-matrix (path v) path-tangent nup)]
          (-> (xs u)
              (utils/transform-pt-matrix m)
              (utils/v- (path v)))))))))

(defn revolve
  ([xs] (revolve xs [[0 0 0] [0 0 1]]))
  ([xs [a b :as axis]]
   (let [up (utils/v- b a)
         xs (-> xs
                c/to-3D
                #_(c/rotate [0 90 0])
                (c/translate a)
                (c/look-at b up))
         data (xs)
         origin (:origin data)]
     (fn
       ([] {:fn `revolve
            :input [xs axis]
            :origin origin
            :dimension 3})
       ([u v]
        (let [angle (* v 360)]
          (-> (xs u)
              (utils/rotate-pt-aa (utils/v- b a) angle))))))))

#+end_src

*** scale
#+begin_src clojure :tangle ./src/forge/brep/surfaces.cljc
(defn scale
  [f [sx sy sz]]
  (let [data (f)
        ctr (:origin data)]
    (fn
      ([] (merge data
                 {:fn `scale
                  :input [f [sx sy sz]]}))
      ([u v]
       (utils/scale-pt-from-center (f u v) [sx sy sz] ctr)))))

#+end_src

*** offset-surface
#+begin_src clojure :tangle ./src/forge/brep/surfaces.cljc
(defn normal
  [surface [u v]]
  (let [eps 0.00001
        uvs (->> (utils/regular-polygon-pts eps 3)
                 (map #(utils/v+ % [u v])))
        pts (map #(apply surface %) uvs)]
    (utils/normalize (apply utils/normal pts))))

(defn offset
  [surf t]
  (let []
    (fn
      ([] {:fn `offset
           :input [surf t]
           :origin (surf 0.5 0.5)})
      ([u v]
       (let [pt (surf u v)
             n (normal surf [u v])
             v (utils/v* n (repeat t))]
         (utils/v+ pt v))))))

#+end_src

** brep.mesh
*** ns
#+begin_src clojure :tangle ./src/forge/brep/mesh.cljc
(ns forge.brep.mesh
  (:require [clojure.string :as str]
            [forge.utils :as utils]
            [forge.geom :as geom]
            [forge.delaunay :as delaunay]
            [forge.clip-ears :as clip-ears]
            [forge.brep.curves :as c]
            [forge.brep.surfaces :as s]))

#+end_src

*** rect-grid
#+begin_src clojure :tangle ./src/forge/brep/mesh.cljc
(defn rect-grid
  [nx ny x-spacing y-spacing]
  (for [b (range ny)
        a (range nx)]
    [(* a x-spacing) (* b y-spacing)]))

#+end_src

*** tri-indices
#+begin_src clojure :tangle ./src/forge/brep/mesh.cljc
(defn- tri-indices
  [seg idx]
  (if (and (not= 0 idx) (= 0 (int (mod (inc idx) seg))))
    ;; when idx is a multiple of seg, loop the surface back to u 0
    [[idx (+ idx seg) (+ 1 idx (- seg))]
     [(+ 1 idx (- seg)) (+ idx seg) (+ 1 idx)]]
    ;; otherwise, use simple idx shifting, assuming the u 1 edge pts are NOT present in the pts list
    [[idx (+ idx seg) (+ 1 idx)]
     [(+ 1 idx) (+ idx seg) (+ 1 idx seg) ]]))

#+end_src

*** curve
#+begin_src clojure :tangle ./src/forge/brep/mesh.cljc
(defn curve
  [curve seg]
  (let [step (double (/ 1 seg))
        ts (range 0 1 step)]
    {:pts (map curve ts)}))

#+end_src

*** surface
#+begin_src clojure :tangle ./src/forge/brep/mesh.cljc
(defn single-surface
  ([surf seg] (single-surface seg seg))
  ([surf useg vseg]
   (let [eps 0.00001
         ustep (double (/ 1 useg))
         vstep (double (/ 1 vseg))
         uvs (rect-grid (inc useg) (inc vseg) ustep vstep)
         trifn (fn [idx]
                 (when-not
                     (and (not= 0 idx)
                          (= 0 (int (mod (inc idx) (inc useg)))))
                   (let [a idx
                         b (inc idx)
                         d (- (+ idx 1 useg) 0 #_(- useg vseg))
                         c (inc d)]
                     [[a b c] [a c d]]
                     #_[[idx (+ idx (inc useg)) (inc idx)]
                    [(inc idx) (+ 1 idx useg) (+ 2 idx useg)]])))
         quadfn (fn [[a b c] [_ _ d]] [a b c d])
         tris (->> (range (inc (count uvs)))
                   (take (inc (* (inc useg) vseg)))
                   (mapcat trifn)
                   (remove nil?)
                   (drop-last 2))
         quads (map #(apply quadfn %) (partition 2 tris))]
     {:pts (mapv #(apply surf %) uvs)
      :tris (vec tris)
      :quads (vec quads)})))

(defn- shift-face-indices
  [shift faces]
  (map (fn [face] (mapv #(+ shift %) face)) faces))

(defn mesh-merge
  ([mesh] mesh)
  ([mesha meshb]
   (let [shift (count (:pts mesha))]
     {:pts (vec (concat (:pts mesha) (:pts meshb)))
      :tris (vec (concat (:tris mesha) (shift-face-indices shift (:tris meshb))))
      :quads (vec (concat (:quads mesha) (shift-face-indices shift (:quads meshb))))})))

#_(defn surface
  ([surf seg] (surface seg seg))
  ([surf useg vseg]
   (let [surfaces (if (fn? surface) [surface] surface)
         eps 0.00001
         ustep (double (/ 1 useg))
         vstep (double (/ 1 vseg))
         uvs (rect-grid (inc useg) (inc vseg) ustep vstep)
         trifn (fn [idx]
                 (when-not
                     (and (not= 0 idx)
                          (= 0 (int (mod (inc idx) (inc useg)))))
                   (let [a idx
                         b (inc idx)
                         d (- (+ idx 1 useg) 0 #_(- useg vseg))
                         c (inc d)]
                     [[a b c] [a c d]]
                     #_[[idx (+ idx (inc useg)) (inc idx)]
                    [(inc idx) (+ 1 idx useg) (+ 2 idx useg)]])))
         quadfn (fn [[a b c] [_ _ d]] [a b c d])
         tris (->> (range (inc (count uvs)))
                   (take (inc (* (inc useg) vseg)))
                   (mapcat trifn)
                   (remove nil?)
                   (drop-last 2))
         quads (map #(apply quadfn %) (partition 2 tris))]
     {:pts (map #(apply surf %) uvs)
      :tris tris
      :quads quads})))

(defn surface
  ([surf seg] (surface seg seg))
  ([surf useg vseg]
   (let [surfaces (if (fn? surf) [surf] surf)
         meshes (map #(single-surface % useg vseg) surfaces)]
     (reduce mesh-merge meshes))))

#+end_src

** brep-old
*** ns
#+begin_src clojure :tangle ./src/forge/brep/old.cljc
(ns forge.brep.old
  (:require [forge.utils :as utils]
            [forge.geom :as geom]
            [forge.delaunay :as delaunay]
            [clojure.string :as str]
            [same :refer [ish? zeroish?]]))

#+end_src
*** utils
#+begin_src clojure :tangle ./src/forge/brep/old.cljc
(defn remap-within
  [f [start end] x]
  (when (and (>= x start) (< x end))
    (let [step (- end start)
          t (/ (- x start) step)]
      (f t))))

#+end_src

*** line
#+BEGIN_SRC clojure :tangle ./src/forge/brep/old.cljc
(defn line
  [a b]
  (fn [t]
    (cond
      (= t :tag) :line
      (= (float t) 0.0) a
      (= (float t) 1.0) b
      :else
      (utils/v+ a (utils/v* (utils/v- b a) (repeat t))))))

#+END_SRC

*** polyline
#+BEGIN_SRC clojure :tangle ./src/forge/brep/old.cljc
(defn polyline
  [pts]
  (let [step (/ 1.0 (dec (count pts)))
        intervals (partition 2 1 (range 0 (+ 1 step) step))
        lines (map (partial apply line) (partition 2 1 pts))]
    (fn [t]
      (cond 
        (= t :tag) :polyline
        (= (float t) 0.0) (first pts)
        (= (float t) 1.0) (last pts)
        :else
        (first (filter some?
                       (map #(remap-within %1 %2 t) lines intervals)))))))

#+END_SRC

*** circle
#+BEGIN_SRC clojure :tangle ./src/forge/brep/old.cljc
;;https://mathforum.org/library/drmath/view/63755.html
(defn curve-circle
  [a b c]
  (let [n (utils/normalize (utils/normal a b c))
        r (utils/radius-from-pts a b c)
        cp (utils/center-from-pts a b c)
        u (utils/normalize (mapv - a cp))
        v (utils/cross* n u)]
    (fn [t]
      (cond
        (= t :tag) :circle
        (or (< t 0.0) (> t 1.0)) nil
        (= (float t) 0.0) a
        (= (float t) 1.0) a
        :else
        (let [t (* 2 Math/PI t)]
          (utils/v+ cp
              (utils/v* (repeat (* r (Math/cos t))) u)
              (utils/v* (repeat (* r (Math/sin t))) v)))))))

(defn surface-circle
  [a b c]
  (let [cp (utils/center-from-pts a b c)
        c1 (curve-circle a b c)]
    (fn [u v]
      (let [c2 (line cp (c1 u))]
        (c2 v)))))

#+END_SRC

*** ellipse
#+BEGIN_SRC clojure :tangle ./src/forge/brep/old.cljc
(defn curve-ellipse
  [rx ry]
  (fn [t]
    (let [t (* 2 Math/PI t)
          x (* rx (Math/cos t))
          y (* ry (Math/sin t))]
      [x y])))

#+END_SRC

*** arc
There are 2 angle-from-pts functions. They don't both work here, even though I think they should... angle-from-pts2 causes this function to nil out in many cases.

angle-from-pts only reports the small angle no matter what, so that isn't always going to produce the correct arc.

#+BEGIN_SRC clojure :tangle ./src/forge/brep/old.cljc
(defn curve-arc
  [a b c]
  (let [f (curve-circle a b c)
        cp (utils/center-from-pts a b c)
        angle (utils/angle-from-pts a cp c)]
    (fn [t]
      (let [t (* t (/ angle 360.0))]
        (f t)))))

#+END_SRC

*** polygon
My frep-polygon uses a triangulation/union approach. This did break for me in some cases, so I am going to test an alternate implementation. I will port this code:


https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm  (go to polygon - exact section)
https://www.shadertoy.com/view/wdBXRW


Every polygon function must work on & paths, not just a single list of points. This is to allow multi-shape paths (eg. a circle with a hole.)

As well, any polygon union should effectively produce the same polygon that would result from providing each path into one polygon call. That is...

(= (union (polygon pts-a) (polygon pts-b)) (polygon pts-a pts-b))

#+BEGIN_SRC clojure :tangle ./src/forge/brep/old.cljc
(defn curve-polygon
  [pts]
  (polyline (conj (vec pts) (first pts))))

#+END_SRC

*** bezier
Eventually I want to generalize bezier fn to take any number of control points, but for the time being it's easier to implement cubic/quadratic bezier curves, as they have simplified algorithms.

#+BEGIN_SRC clojure :tangle ./src/forge/brep/old.cljc
(defn- quadratic-bezier
  [a b c]
  (fn [t]
    (let [l1 (line a b)
          l2 (line b c)
          l3 (line (l1 t) (l2 t))]
      (l3 t))))

(defn bezier
  [pts]
  (if (= 3 (count pts))
    (apply quadratic-bezier pts)
    (let [lines (map #(apply line %) (partition 2 1 pts))] 
      (fn [t]
        (let [npts (map #(% t) lines)]
          ((bezier npts) t))))))

#+END_SRC

*** triangle
[[https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm]]

#+BEGIN_SRC clojure :tangle ./src/forge/brep/old.cljc
(defn surface-triangle
  [a b c]
  (let [l1 (line b a)
        l2 (line c a)]
    (fn [u v]
      (let [l3 (line (l1 v) (l2 v))]
        (l3 u)))))

#+END_SRC

*** sphere
#+BEGIN_SRC clojure :tangle ./src/forge/brep/old.cljc
(defn sphere
  [r]
  (fn [u v]
    (let [[u v] (map #(* 2 Math/PI %) [u v])
          x (* r (Math/sin u) (Math/cos v))
          y (* r (Math/sin u) (Math/sin v))
          z (* r (Math/cos u))]
      [x y z])))

#+END_SRC

*** torus
#+BEGIN_SRC clojure :tangle ./src/forge/brep/old.cljc
(defn surface-torus
  [R r]
  (fn [u v]
    (let [[u v] (map #(* 2 Math/PI %) [u v])
          x (* (+ R (* r (Math/cos u))) (Math/cos v))
          y (* (+ R (* r (Math/cos u))) (Math/sin v))
          z (* r (Math/sin u))]
      [x y z])))

#+END_SRC

*** cylinder
#+BEGIN_SRC clojure :tangle ./src/forge/brep/old.cljc
(defn surface-cylinder
  [r h]
  (fn [u v]
    (let [u (* 2 Math/PI u)
          v (* h v)
          x (* r (Math/cos u))
          y (* r (Math/sin u))
          z v]
      [x y z])))

#+END_SRC

*** translate
#+BEGIN_SRC clojure :tangle ./src/forge/brep/old.cljc
(defn translate
  [f pos]
  (comp #(utils/v+ pos %) f))

#+END_SRC

*** rotate
#+BEGIN_SRC clojure :tangle ./src/forge/brep/old.cljc
(defn brep-rotate
  [f angles]
  (comp #(utils/rotate-point % angles) f))

#+END_SRC

*** scale
#+BEGIN_SRC clojure :tangle ./src/forge/brep/old.cljc
(defn scale
  [f scales]
  (comp #(utils/v* scales %) f))

#+END_SRC

*** extrude
#+BEGIN_SRC clojure :tangle ./src/forge/brep/old.cljc
(defn curve-extrude
  [c h]
  (fn [u v]
    (let [c2 (line (c u) (utils/v+ (c u) [0 0 h]))]
      (c2 v))))

(defn surface-extrude
  [s h]
  (fn [u v w]
    (let [c1 (line (s u v) (utils/v+ (s u v) [0 0 h]))]
      c1 v)))

#+END_SRC
* model
The model is two concepts:

1. The tree
 - uses hiccup style structures [:tag {:props props} content]
 - follows similarly to what svg-clj does with its structure except it does not 'bake' transforms into the elements, but rather wraps them in the relevant tagged vector

2. The map
 - uses a map structure to represent everything about a single element
 - all transforms and combinations are 'baked' into the map so you have no history but you do have all the necessary parts to fully describe the current state of the mdoel.

You can always create a map from a tree, but you cannot guarantee that you can get the same tree from a map. It is one way and destructive. This is why you want to save both representations. 

It may be useful for some compile targets to have the ability to use both a tree and map approach. For example, turning sub-sections of a tree during traversal into a map representation to quickly get needed geometric data.

The map should have:
- BREP structure (collection of vertices, edges, faces, shells, solids)
- FREP structure (single fn taking [x y z] returning distance to surface of the whole object)

** ns
The namespace declaration.
#+begin_src clojure :tangle ./src/forge/model.cljc
(ns forge.model
  (:require [forge.utils :as utils]
            [forge.geom :as geom]
            #_[forge.brep :as brep]
            #_[forge.frep :as frep]))

#+end_src

** utils
#+begin_src clojure :tangle ./src/forge/model.cljc
(def pi Math/PI)
(def tau (* 2 pi))
#+end_src

** 2D
#+begin_src clojure :tangle ./src/forge/model.cljc
(defn pt
  ([x y]
   [:pt {:x x :y y}])
  ([x y z]
   [:pt {:x x :y y :z z}]))

(defn line
  [a b]
  [:line {:a a :b b}])

(defn polyline
  [pts]
  [:polyline {:pts pts}])

(defn rect
  [w h]
  [:rect {:w w :h h :center true}])

(defn circle
  [r]
  [:circle {:r r}])

(defn ellipse
  [rx ry]
  [:ellipse {:rx rx :ry ry}])

(defn polygon
  ([pts]
   [:polygon {:pts (vec pts) :paths [(vec (range (count pts)))]}])
  ([pts paths]
   [:polygon {:pts (vec pts) :paths paths}]))

(defn slice
  [elem z]
  [:slice {:z z} elem])

#+end_src

** 3D
#+begin_src clojure :tangle ./src/forge/model.cljc
(defn sphere
  [r]
  [:sphere {:r r}])

(defn box
  [x y z]
  [:box {:x x :y y :z z :center true}])

(defn cylinder
  ([r h]
   [:cylinder {:r r :h h :center true}])
  ([r1 r2 h]
   [:cylinder {:r1 r1 :r2 r2 :h h :center true}]))

(defn polyhedron
  [pts faces]
  [:polyhedron {:pts pts :faces faces}])

(defn extrude
  [elem h]
  [:extrude {:h h} elem])

(defn revolve
  [elem a]
  [:revolve {:a a} elem])

#+end_src

** boolean
#+begin_src clojure :tangle ./src/forge/model.cljc
(defn union
  [& elems]
  [:union {} elems])

(defn intersection
  [& elems]
  [:intersection {} elems])

(defn difference
  [& elems]
  [:difference {} elems])

#+end_src

** transforms
*** translate
#+begin_src clojure :tangle ./src/forge/model.cljc
(defn translate
  [elem [x y z]]
  [:translate {:x x :y y :z z} elem])

#+end_src

*** rotate
#+begin_src clojure :tangle ./src/forge/model.cljc
(defn rotate
  ([elem [x y z]]
   [:rotate {:x x :y y :z z} elem])

  ([elem a [x y z]]
   [:rotate {:a a :x x :y y :z z} elem]))

#+end_src

*** scale
#+begin_src clojure :tangle ./src/forge/model.cljc
(defn scale
  [elem [x y z]]
  [:scale {:x x :y y :z z} elem])

#+end_src

*** style
#+begin_src clojure :tangle ./src/forge/model.cljc
(defn style
  [[k props & content] style-map]
  (into [k (merge props style-map)] content))

#+end_src

*** group
#+begin_src clojure :tangle ./src/forge/model.cljc
(defn group
  [& elems]
  [:group {} elems])

#+end_src

*** mirror
#+begin_src clojure :tangle ./src/forge/model.cljc
(defn mirror
  [elem [x y z]]
  [:mirror {:x x :y y :z z} elem])

#+end_src

*** color
#+begin_src clojure :tangle ./src/forge/model.cljc
(defn color
  [elem [r g b a]]
  [:color {:r r :g g :b b :a a} elem])

#+end_src

*** hull
#+begin_src clojure :tangle ./src/forge/model.cljc
(defn hull
  [elem]
  [:hull {} elem])

#+end_src

*** offset
#+begin_src clojure :tangle ./src/forge/model.cljc
(defn offset
  [elem d]
  [:offset {:d d} elem])

#+end_src

*** minkowski
#+begin_src clojure :tangle ./src/forge/model.cljc
(defn minkowski
  [& elems]
  [:minkowski {} elems])

#+end_src

*** multmatrix
#+begin_src clojure :tangle ./src/forge/model.cljc
(defn multmatrix
  [elem mtx]
  [:multmatrix {:mtx mtx} elem])

#+end_src

** fig
Forge Internal Geometry

keys:
 - frep
 - brep
   - vertices
   - curves
   - faces
   - surfaces
   - shells
   - solids
 - tree


#+begin_src clojure :tangle ./src/forge/model.cljc
;; multimethod
(defmulti fig
  (fn [element]
    (if (keyword? (first element)) (first element) :list)))

(defmethod fig :list
  [[& elems]]
  (map fig elems))

(defmethod fig :pt [[_ {:keys [] :as props}]])
(defmethod fig :line [[_ {:keys [] :as props}]])
(defmethod fig :polyline [[_ {:keys [] :as props}]])
(defmethod fig :rect [[_ {:keys [] :as props}]])
(defmethod fig :circle [[_ {:keys [] :as props}]])
(defmethod fig :polygon [[_ {:keys [] :as props}]])
(defmethod fig :project [[_ {:keys [] :as props}]])

(defmethod fig :sphere [[_ {:keys [] :as props}]])
(defmethod fig :box [[_ {:keys [] :as props}]])
(defmethod fig :cylinder [[_ {:keys [] :as props}]])
(defmethod fig :polyhedron [[_ {:keys [] :as props}]])
(defmethod fig :extrude [[_ {:keys [] :as props}]])
(defmethod fig :revolve [[_ {:keys [] :as props}]])

(defmethod fig :union [[_ {:keys [] :as props}]])
(defmethod fig :intersection [[_ {:keys [] :as props}]])
(defmethod fig :difference [[_ {:keys [] :as props}]])

(defmethod fig :group [[_ {:keys [] :as props}]])
(defmethod fig :translate [[_ {:keys [] :as props}]])
(defmethod fig :rotate [[_ {:keys [] :as props}]])
(defmethod fig :scale [[_ {:keys [] :as props}]])

#+end_src

* importers
Use parsers to read-in various file types into the model representation.

Then, any number of file inputs can be used in the definition of an object.

For example, 2D drawings can be produced as SVG and read into forge and manipulated using Forge geom tools. Then, you can directly reference them in model creation and output a model to whatever compiler target you wish.

Likewise, you can also use native lang. files as modules in a design. So, if you have a multi file scad design, you can read each scad file in and trust that it is accurately represented with forge-model data and proceed as if it were built directly with forge.

** image
This is just copy pasted from scad-drawing project. The intent here is to have a tool that takes a png filename and gives a set of points/paths which can be used as the basis for sketch elements, and used in Forge models as if native fns had created the points/paths.

*** ns
#+begin_src clojure :tangle ./src/forge/import/image.clj
(ns forge.import.image
  (:require [clojure.java.shell :refer [sh]]
            [clojure.string :as str]
            [clojure.data.xml :as xml]
            [clojure.core :exclude [import]]
            [svg-clj.elements :as svg]
            [svg-clj.path :as path]
            [svg-clj.transforms :as tf]
            [svg-clj.utils :refer [s->v
                                   svg-str->hiccup]]
            [forge.model :as mdl]
            [forge.utils :as utils]))

#+end_src

*** img->svg
This part of the library has an external dependency on vtracer:

[[https://github.com/visioncortex/vtracer]]

#+begin_src clojure :tangle ./src/forge/import/image.clj
(defn img->str 
  [fname]
  "Ingest image file `fname` and transform it into a hiccup data structure."
  (let [new-fname (str (first (str/split fname #"\.")) ".svg")]
    (sh "vtracer" 
        "--mode" "polygon"
        "--colormode" "bw"
        "--segment_length" "3.5"
        "--input" fname
        "--output" new-fname)
    (let [svg-str (slurp new-fname)]
      (sh "rm" new-fname)
      (-> svg-str
          (str/replace #"<\?xml.+>" "")
          str/trim))))

(defn- closed?
  [path]
  (let [d (get-in path [1 :d])]
    (-> d
        str/trim
        str/upper-case
        (str/ends-with? "Z"))))

(defn re-center
  [seq]
  (let [group (svg/g seq)
        ctr (mapv float (tf/centroid group))]
    (->> seq
         (map #(tf/translate % (utils/v* [-1 -1] ctr))))))

#+end_src

*** svg->mdl
Methods for converting all SVG elements into equivalent forge model elements/transforms.

Elements being converted:
 - circle
 - ellipse
 - line
 - polygon
 - polyline
 - path
 - rect
 - g

#+begin_src clojure :tangle ./src/forge/import/image.clj
(defmulti svg->mdl
  (fn [element]
    (if (keyword? (first element))
      (first element)
      :list)))

(defn- clean-props
  [props]
  (let [removable [:cx :cy :transform :width :height :x :y :d :fill-rule]]
    (apply dissoc (concat [props] removable))))

(defn- parse-transform
  [tf-str]
  (let [xf (svg-clj.utils/str->xf-map tf-str)
        tr (:translate xf)
        rot (:rotate xf)
        angle (last rot)]
    [(fn [elem]
       (cond-> elem
         rot (mdl/rotate [0 0 angle])
         tr (mdl/translate tr)))
     xf]))

(defmethod svg->mdl :list
  [elems]
  (map svg->mdl elems))

(defmethod svg->mdl :default [_] nil)

(defmethod svg->mdl :circle
  [[_ {:keys [cx cy r] :as props}]]
  (let [xf-props (clean-props props)]
    (cond-> (mdl/circle r)
      true (mdl/style xf-props)
      (and (not= cx 0)
           (not= cy 0)) (mdl/translate [cx cy 0]))))

(defmethod svg->mdl :ellipse
  [[_ {:keys [cx cy rx ry] :as props}]]
  (let [xf-props (clean-props props)]
    (cond-> (mdl/ellipse rx ry)
      true (mdl/style xf-props)
      (and (not= cx 0)
           (not= cy 0)) (mdl/translate [cx cy 0]))))

(defmethod svg->mdl :line
  [[_ {:keys [x1 y1 x2 y2] :as props}]]
  (let [xf-props (clean-props props)]
    (-> (mdl/line [x1 y1 0] [x2 y2 0])
        (mdl/style xf-props))))

(defmethod svg->mdl :polyline
  [[_ {:keys [points] :as props}]]
  (let [xf-props (clean-props props)
        pts (->> points
                 s->v
                 (partition 2))]
    (-> (mdl/polyline pts)
        (mdl/style xf-props))))

(defmethod svg->mdl :polygon
  [[_ {:keys [points] :as props}]]
  (let [xf-props (clean-props props)
        pts (->> points
                 s->v
                 (partition 2))]
    (-> (mdl/polygon pts)
        (mdl/style xf-props))))

(defmethod svg->mdl :rect
  [[_ {:keys [width height x y transform] :as props}]]
  (let [[xf xf-map] (parse-transform transform)
        angle (last (get xf-map :rotate [0]))
        xf-props (clean-props props)
        pos (-> (utils/v+ [x y] [(/ width 2.0) (/ height 2.0)])
                (utils/rotate-point [0 0 angle]))]
    (-> (mdl/rect width height)
        xf
        (mdl/style xf-props)
        (mdl/translate (conj pos 0)))))

(defmethod svg->mdl :g
  [[_ props & elems]]
  (let [xf-props (clean-props props)]
    [:group xf-props (map svg->mdl elems)]))

(defn- bb-area
  [elem]
  (reduce * (tf/bb-dims elem)))

(defn path->pts
  [path-elem]
  (let [cmds (-> path-elem
                 (get-in [1 :d])
                 path/path-str->cmds)]
    (into [] (filter some? (map :input cmds)))))

(defn- svg-path-elem->polygon
  [path-elem]
  (let [pgs (->> path-elem
                 path/split-path
                 (sort-by bb-area)
                 (map path->pts)
                 (map mdl/polygon)
                 reverse)]
    (if (> (count pgs) 1)
      (apply mdl/difference pgs)
      (first pgs))))

(defn- svg-path-elem->polyline
  [path-elem]
  (let [pgs (->> path-elem
                 path/split-path 
                 (sort-by bb-area)
                 (map path->pts)
                 (map mdl/polyline)
                 reverse)]
    (if (> (count pgs) 1)
      (apply mdl/difference pgs)
      (first pgs))))

(defmethod svg->mdl :path
  [[_ props :as elem]]
  (let [xf-props (clean-props props)
        xf-elem (path/decurve elem)]
    (-> (if (closed? elem)
          (svg-path-elem->polygon xf-elem)
          (svg-path-elem->polyline xf-elem))
        (mdl/style xf-props))))

#+end_src

*** import
#+begin_src clojure :tangle ./src/forge/import/image.clj
(defn line-drawing
  [fname & {:keys [r]}]
  (-> fname
      img->str
      svg-str->hiccup
      (->> (drop 2))
      re-center
      (->> (mapcat path/split-path))
      (->> (map path->pts))
      (->> (map #(mdl/polyline %)))
      mdl/union))

(defn import-png
  [fname]
  (-> fname
      img->str
      svg-str->hiccup
      (->> (drop 2))
      re-center
      (->> (map svg-path-elem->polygon))
      mdl/union))

(defn import-svg
  [fname]
  (let [data (-> (slurp fname) svg-str->hiccup)
        elems (if (= :svg (first data)) (drop 2 data) data)]
    (->> elems
         (map svg->mdl)
         (filter some?))))

(defn import
  [fname]
  (let [fext (utils/ext fname)
        f (get {"svg" import-svg
                "png" import-png} fext)]
    (f fname)))

#+end_src

* compilers
A collection of methods for exporting models.

** scad
This is based off of Matthew Farrell's work on scad-clj. The code is modified in the following ways:

- uses some different names
  - cube -> box
  - extrude-linear -> extrude
  - extrude-rotate -> revolve

- uses vectors instead of lists (more hiccup-like) as the expr data structure

- some scad specifics are removed. This is to have 1-1 language for all compilation targets
  - fn! is not used because it does not have an equivalent in FreeCAD, SolidWorks, etc.

*** ns
#+begin_src clojure :tangle ./src/forge/compile/scad.cljc
(ns forge.compile.scad
  (:require [clojure.java.shell :refer [sh]]
            [clojure.string :as str]
            [forge.utils :as utils]
            [svg-clj.utils :refer [svg-str->hiccup]]
            [forge.model :as mdl]))

#+end_src

*** write-expr
#+begin_src clojure :tangle ./src/forge/compile/scad.cljc
;; multimethod
(defmulti write-expr
  (fn [depth element]
    (if (keyword? (first element)) (first element) :list)))

(defmethod write-expr :list
  [depth [& elems]]
  (mapcat #(write-expr depth %1) elems))

#+end_src

*** utility
#+begin_src clojure :tangle ./src/forge/compile/scad.cljc
;; utility
(defn indent
  [depth]
  (str/join (repeat depth "  ")))

(defn write-block
  [depth block]
  (mapcat #(write-expr (inc depth) %1) block))

(declare map-to-arg-string)

(defn make-arguments
  [args]
  (let [arg (first args)
        rest (rest args)
        piece (cond
               (map? arg) (map-to-arg-string arg)
               (coll? arg) (str "[" (make-arguments arg) "]")
               :else arg)]
    (if (empty? rest)
      piece
      (str/join ", " [piece (make-arguments rest)]))))

(defn map-to-arg-string
  [m]
  (str/join ", " (map (fn [[k v]] (str (name k) "=" (make-arguments [v])) ) m)))

#+end_src

*** 2d-impl
#+begin_src clojure :tangle ./src/forge/compile/scad.cljc
(defmethod write-expr :circle
  [depth [_ {:keys [r center]}]] 
  (list (indent depth) 
        "circle (r=" r ");\n"))

(defmethod write-expr :ellipse
  [depth [_ {:keys [rx ry center]}]] 
  (list (indent depth) 
        "scale([1, " (/ ry rx) ", 1])circle (r=" rx ");\n"))

(defmethod write-expr :rect
  [depth [_ {:keys [w h center]}]]
  (list (indent depth)
        "square ([" w ", " h "]"
        (when center ", center=true") ");\n"))

(defmethod write-expr :polygon
  [depth [_ {:keys [pts paths convexity]}]]
  `(~@(indent depth) "polygon ("
    "points=[[" ~(str/join "], [" (map #(str/join ", " %1) pts)) "]]"
    ~@(when paths [", paths=[[" (str/join "], [" (map #(str/join "," %1) paths)) "]]"])
    ~@(when convexity [", convexity=" convexity])
    ");\n"))

(defmethod write-expr :slice
  [depth [_ {:keys [z]} elem]]
  (concat
   (list (indent depth)
         "projection(cut=true){\n")
   (write-expr (inc depth) (-> elem (mdl/translate [0 0 (- z)])))
   (list (indent depth) "}\n")))

#+end_src

*** 3d-impl
#+begin_src clojure :tangle ./src/forge/compile/scad.cljc
(defmethod write-expr :sphere
  [depth [_ {:keys [r center]}]]
  (list (indent depth) 
        "sphere (r=" r ");\n"))

(defmethod write-expr :box
  [depth [_ {:keys [x y z center]}]]
  (list (indent depth)
        "cube ([" x ", " y ", " z "]"
        (when center ", center=true") ");\n"))

(defmethod write-expr :cylinder
  [depth [_ {:keys [h r r1 r2 center]}]]
  (concat
   (list (indent depth) 
         "cylinder (h=" h)
   (if r (list ", r=" r) (list ", r1=" r1 ", r2=" r2))
   (when center (list ", center=true"))
   (list ");\n")))

(defmethod write-expr :polyhedron
  [depth [_ {:keys [pts faces convexity]}]]
  `(~@(indent depth) "polyhedron ("
    "points=[[" ~(str/join "], [" (map #(str/join ", " %1) pts)) "]], "
    "faces=[[" ~(str/join "], [" (map #(str/join ", " %1) faces)) "]]"
    ~@(if (nil? convexity) [] [", convexity=" convexity])
    ");\n"))

(defmethod write-expr :extrude
  [depth [_ {:keys [h]} elem]]
  (concat
   (list (indent depth) 
         "linear_extrude(height=" h
         "){\n")
   (write-expr (inc depth) elem)
   (list (indent depth) 
         "}\n")))

(defmethod write-expr :revolve
  [depth [_ {:keys [a]} elem]]
  (concat
   (list (indent depth)
         "rotate_extrude(angle=" a
         "){\n")
   (write-expr (inc depth) elem)
   (list (indent depth) 
         "}\n")))

#+end_src

*** transforms-impl
#+begin_src clojure :tangle ./src/forge/compile/scad.cljc
(defmethod write-expr :translate
  [depth [_ {:keys [x y z]} elem]]
  (concat
   (list (indent depth) "translate ([" x ", " y ", " z "]) {\n")
   (write-expr (inc depth) elem)
   (list (indent depth) "}\n")))

(defmethod write-expr :rotate
  [depth [_ {:keys [a x y z]} elem]]
  (if a
    (concat
     (list (indent depth) "rotate (a=" a ", v=[" x ", " y ", " z "]) {\n")
     (write-expr (inc depth) elem)
     (list (indent depth) "}\n"))
    (concat
     (list (indent depth) "rotate ([" x "," y "," z "]) {\n")
     (write-expr (inc depth) elem)
     (list (indent depth) "}\n"))))

(defmethod write-expr :scale
  [depth [_ {:keys [x y z]} elem]]
  (concat
   (list (indent depth) "scale ([" x ", " y ", " z "]) {\n")
   (write-expr (inc depth) elem)
   (list (indent depth) "}\n")))

(defmethod write-expr :mirror
  [depth [_ {:keys [x y z]} elem]]
  (concat
   (list (indent depth) "mirror ([" x ", " y ", " z "]) {\n")
   (write-expr (inc depth) elem)
   (list (indent depth) "}\n")))

(defmethod write-expr :hull
  [depth [_ _ elem]]
  (concat
   (list (indent depth) "hull () {\n")
   (write-expr (inc depth) elem)
   (list (indent depth) "}\n")))

(defmethod write-expr :offset
  [depth [_ {:keys [d]} elem]]
  (concat 
   (list (indent depth) "offset (r = " d "){\n")
   (write-expr (inc depth) elem)
   (list (indent depth) "}\n")))

(defmethod write-expr :minkowski
  [depth [_ _ elems]]
  (concat
   (list (indent depth) "minkowski () {\n")
   (write-expr (inc depth) elems)
   (list (indent depth) "}\n")))

(defmethod write-expr :multmatrix
  [depth [_ {:keys [mtx]} elem]]
  (let [w (fn [s] (str "[" s "]"))
        co (fn [c] (apply str (interpose "," c)))]
    (concat
     (list (indent depth) "multmatrix(")
     (w (co (map #(w (co %)) mtx)))
     (list ") {\n")
     (mapcat #(write-expr (inc depth) %1) elem)
     (list (indent depth) "}\n"))))

#+end_src

*** boolean-impl
#+begin_src clojure :tangle ./src/forge/compile/scad.cljc
(defmethod write-expr :union
  [depth [_ _ elems]]
  (concat
   (list (indent depth) "union () {\n")
   (write-block depth elems)
   (list (indent depth) "}\n")))

(defmethod write-expr :difference
  [depth [_ _ elems]]
  (concat
   (list (indent depth) "difference () {\n")
   (mapcat #(write-expr (inc depth) %1) elems)
   (list (indent depth) "}\n")))

(defmethod write-expr :intersection
  [depth [_ _ elems]]
  (concat
   (list (indent depth) "intersection () {\n")
   (mapcat #(write-expr (inc depth) %1) elems)
   (list (indent depth) "}\n")))

#+end_src

*** other-impl
#+begin_src clojure :tangle ./src/forge/compile/scad.cljc
(defmethod write-expr :color
  [depth [_ {:keys [r g b a]} elem]]
  (concat
    (list (indent depth) "color (["
          (/ r 255.0) ", "
          (/ g 255.0) ", "
          (/ b 255.0) ", "
          (utils/clamp a 0.0 1.0) "]) {\n")
    (write-expr depth elem)
    (list (indent depth) "}\n")))

(defmethod write-expr :group 
  [depth [_ _ elems]]
  (concat
   (list (indent depth) "group() {\n")
   (write-expr (inc depth) elems)
   (list (indent depth) "}\n")))

#+end_src

*** composites
#+begin_src clojure :tangle ./src/forge/compile/scad.cljc
(defn- scad-line
  [a b & {:keys [r]}]
  (let [r (if r r 2)
        a (if (< (count a) 3) (forge.utils/add-z a) a)
        b (if (< (count b) 3) (forge.utils/add-z b) b)]
    (if (= a b)
      (-> (mdl/sphere r) (mdl/translate a))
      (let [[dx dy dz] (utils/v- a b)
            norm (utils/distance b a)
            rotate-angle (utils/to-deg (Math/acos (/ dz norm)))
            rotate-axis [(- dy) dx 0]]
        (-> (mdl/union
             (-> (mdl/sphere r) (mdl/translate a))
             (-> (mdl/sphere r) (mdl/translate b))
             (-> (mdl/cylinder r norm)
                 (mdl/translate [0 0 (/ norm 2)])
                 (mdl/rotate rotate-angle rotate-axis)
                 (mdl/translate b)))
            (mdl/color [0 0 0 1]))))))

(defn- scad-polyline
  [pts & {:keys [r]}]
  (apply mdl/union
   (map #(scad-line (first %) (second %) :r r)
        (partition 2 1 pts))))

(defn- linecube
  [x y z]
  (mdl/union
   (-> (mdl/box x y z) (mdl/color [0 1 0 1]))
   (-> (mdl/union
        (mdl/line [0 0 0] [x 0 0])
        (mdl/line [x 0 0] [x y 0])
        (mdl/line [x y 0] [0 y 0])
        (mdl/line [0 y 0] [0 0 0])
        (mdl/line [0 0 0] [0 0 z])
        (mdl/line [x 0 0] [x 0 z])
        (mdl/line [x y 0] [x y z])
        (mdl/line [0 y 0] [0 y z])
        (mdl/line [0 0 z] [x 0 z])
        (mdl/line [x 0 z] [x y z])
        (mdl/line [x y z] [0 y z])
        (mdl/line [0 y z] [0 0 z]))
       (mdl/translate [(/ x -2.0) (/ y -2.0) (/ z -2.0)]))))

(defmethod write-expr :line
  [depth [_ {:keys [a b]}]]
  (write-expr depth (scad-line a b)))

(defmethod write-expr :polyline
  [depth [_ {:keys [pts]}]]
  (write-expr depth (scad-polyline pts)))

#+end_src

*** write
#+begin_src clojure :tangle ./src/forge/compile/scad.cljc
(defn write [& block]
  (str/join (write-expr 0 block)))

#+end_src

*** tools
If you need to display images in the CIDER Repl, you have to make sure that cider-repl-use-content-types is true

~(setq cider-repl-use-content-types t)~

Which you can toggle with:

~M-x cider-repl-toggle-content-types~

#+begin_src clojure :tangle ./src/forge/compile/scad.cljc
(defn png!
  [fname mdl-data]
  (let [scad (write [#_(fn! 20) mdl-data])]
    (sh "/usr/local/bin/openscad" "/dev/stdin"
        "--imgsize" "400,400"
        "--projection" "orthogonal"
        "--view" "edges"
        "--colorscheme" "Tomorrow Night" #_"greenscreen" #_"Nord"
        #_"--camera" #_"0,0,0,55,0,25,2900"
        "-o" fname
        :in scad)))

(defn cider-show
  [mdl-data]
  (let [fname "_tmp.png"]
    (do (png! fname mdl-data)
        (clojure.java.io/file fname))))

(defn mdl->svg
  [mdl]
  (let [scad (str "$fn=200;\n" (write mdl))
        fname (str (gensym "tmp") ".svg")]
    (do (sh "openscad" "/dev/stdin" "-o" fname :in scad)
        (let [svg-str (slurp fname)]
          (do (sh "rm" fname)
              (rest 
               (svg-str->hiccup svg-str)))))))
#+end_src

** freecad-script
*** ns
#+begin_src clojure :tangle ./src/forge/compile/freecad.cljc
(ns forge.compile.freecad
  (:require [clojure.java.shell :refer [sh]]
            [clojure.string :as str]
            [clojure.core.matrix]
            [forge.utils :as utils]
            [forge.model :as mdl]))

#+end_src

*** utils
#+begin_src clojure :tangle ./src/forge/compile/freecad.cljc
(defn get-name
  [s]
  (-> s
      str/split-lines
      last
      (str/split #"=")
      first
      str/trim))

(defn vecstr
  [v]
  (str "Vector(" (str/join ", " v) ")"))

(defn mtxstr
  [[& vs]]
  (str "Matrix(" (str/join ", " (apply concat vs)) ")"))

(defn vecrot
  [v]
  (vec (concat (drop 1 v) (take 1 v))))

#+end_src

*** write-expr
#+begin_src clojure :tangle ./src/forge/compile/freecad.cljc
(defmulti write-expr
  (fn [[form & args]]
    (if (keyword? form) form :list)))

(defmethod write-expr :default
  [[form & args]]
  ["//(" form args ")"])

(defmethod write-expr :list
  [forms]
  (str/join "\n" (map write-expr forms)))

(defn write-block
  [block]
  (mapcat write-expr block))

(declare map-to-arg-string)

(defn make-arguments [args]
  (let [arg (first args)
        rest (rest args)
        piece (cond
               (map? arg) (map-to-arg-string arg)
               (coll? arg) (str "[" (make-arguments arg) "]")
               :else arg)]
    (if (empty? rest)
      piece
      (str/join ", " [piece (make-arguments rest)]))))

(defn map-to-arg-string [m]
  (str/join ", " (map (fn [[k v]] (str (name k) "=" (make-arguments [v])) ) m)))

#+end_src

*** boilerplate
The postamble has some filepath code which I found from here:

[[https://stackoverflow.com/a/595317]] (user jon-w)

#+begin_src clojure :tangle ./src/forge/compile/freecad.cljc
(def fcs-preamble
  "import FreeCAD
from FreeCAD import Base, Vector, Matrix, Placement, Rotation
from math import pi, sin, cos

import Part
import Sketcher
import Import
import sys, os

doc = FreeCAD.activeDocument()
doc_name = \"freecad_clj\"

def clear_doc():
    for obj in doc.Objects:
        doc.removeObject(obj.Name)

def setview():
    FreeCAD.Gui.SendMsgToActiveView(\"ViewFit\")
    FreeCAD.Gui.activeDocument().activeView().viewAxometric()

if doc is None:
    FreeCAD.newDocument(doc_name)
    FreeCAD.setActiveDocument(doc_name)
    doc = FreeCAD.activeDocument()
else:
    clear_doc()

# EPS= tolerance to use to cut the parts
EPS = 0.10
EPS_C = EPS * -0.5\n\n")

(def fcs-postamble
  "doc.recompute()

pathname = os.path.dirname(sys.argv[0])
stepname = os.path.abspath(pathname) + \"/out.step\"
fcname = os.path.abspath(pathname) + \"/out.FCStd\"

#Import.export(doc.RootObjects, stepname)
#doc.saveAs(fcname)")

#+end_src

*** 2D
**** circle
 Start with a circle.

 doc.addObject('Sketcher::SketchObject','sk1')
 doc.sk1.addGeometry(Part.Circle(App.Vector(0.000000,0.000000,0),App.Vector(0,0,1),10),False)
 doc.recompute()

 #+begin_src clojure :tangle ./src/forge/compile/freecad.cljc
 (defmethod write-expr :circle
   [[_ {:keys [r]}]]
   (let [name (gensym "sk_circle_")]
     (str name " = " "Part.makeCircle(" r  ")")))

 #+end_src

**** polygon
 geoList = []
 geoList.append(Part.LineSegment(App.Vector(-5.235079,-4.280038,0),App.Vector(4.496150,-4.280038,0)))
 geoList.append(Part.LineSegment(App.Vector(4.496150,-4.280038,0),App.Vector(4.496150,6.009032,0)))
 geoList.append(Part.LineSegment(App.Vector(4.496150,6.009032,0),App.Vector(-5.235079,6.009032,0)))
 geoList.append(Part.LineSegment(App.Vector(-5.235079,6.009032,0),App.Vector(-5.235079,-4.280038,0)))


 Sketcher.Constraint('Coincident',1,2,2,1)
 App.ActiveDocument.sk_7085.addConstraint(conList)

 App.ActiveDocument.sk_7085.addGeometry(geoList,False)

 #+begin_src clojure :tangle ./src/forge/compile/freecad.cljc
 (defn line-segment
   [[a b]]
   (str "Part.LineSegment(" (str/join ", " (map vecstr [a b])) ")"))

 (defn coincident-constraint
   [[ia ib]]
   (str "Sketcher.Constraint('Coincident'," ia ",2," ib ",1)"))

 (defn build-polygon-old
   [pts]
   (let [name (gensym "sk_")
         indices (partition 2 1 (conj (vec (range (count pts))) 0))
         lines (partition 2 1 (conj pts (first pts)))]
     (apply str [name " = doc.addObject('Sketcher::SketchObject','" name "')\n"
                 "doc." name ".addGeometry(["
                 (str/join "," (map line-segment lines))
                 "],False)\n\n"
                 "doc." name ".addConstraint(["
                 (str/join "," (map coincident-constraint indices))
                 "])\n"])))

 (defn build-polygon
   [pts]
   (let [pts (conj pts (first pts))]
     (str "Part.makePolygon(["
          (str/join ", " (map vecstr pts))
          "])")))

 (defmethod write-expr :polygon
   [[_ {:keys [pts]}]]
   (let [name (gensym "sk_polygon_")]
     (str name " = " (build-polygon pts))))

 #+end_src

**** square
 Use the polygon fn to create a square.

 #+begin_src clojure :tangle ./src/forge/compile/freecad.cljc
 (defmethod write-expr :square
   [[_ {:keys [x y]}]]
   (let [pts [[(/ x -2) (/ y -2) 0] [(/ x 2)  (/ y -2) 0]
              [(/ x 2)  (/ y 2)  0] [(/ x -2) (/ y 2)  0]]
         name (gensym "sk_sq_")]
     (str name " = " (build-polygon pts))))

 #+end_src

*** 3D
**** sphere
 doc.addObject("Part::Sphere","Sphere")
 doc.getObject("Sphere").Radius = '10'

 #+begin_src clojure :tangle ./src/forge/compile/freecad.cljc
 (defmethod write-expr :sphere
   [[_ {:keys [r]}]]
   (let [name (gensym "sphere_")]
     (str name " = " "Part.makeSphere(" r ")")))

 #+end_src

**** cube
 doc.addObject("Part::Box","Box")
 doc.getObject("Box").Placement = App.Placement(App.Vector(-25.4,0,0),App.Rotation(App.Vector(0,0,1),0))

 #+begin_src clojure :tangle ./src/forge/compile/freecad.cljc
 (defmethod write-expr :cube
   [[_ {:keys [x y z]}]]
   (let [name (gensym "cube_")
         pos (map #(/ % -2.0) [x y z])]
     (str name " = " "Part.makeBox(" (str/join ", " [x y z]) ")"
          ".translate(" (vecstr pos) ")")))

 #+end_src

**** cylinder
 App.ActiveDocument.addObject("Part::Cylinder","Cylinder")

 #+begin_src clojure :tangle ./src/forge/compile/freecad.cljc
 (defmethod write-expr :cylinder
   [[_ {:keys [r h]}]]
   (let [name (gensym "cylinder_")
         pos (map #(/ % -2) [0 0 h])]
     (str name " = " "Part.makeCylinder(" (str/join ", " [r h]) ")"
          ".translate(" (vecstr pos) ")")))

 #+end_src

**** polyhedron
 #+begin_src clojure :tangle ./src/forge/compile/freecad.cljc
 (defn build-face
   [pts]
   (str "Part.Face(" (build-polygon pts) ")"))

 (defmethod write-expr :polyhedron
   [[_ {:keys [pts faces]}]]
   (let [name (gensym "polyhedron_")
         get-pts (fn [face] (mapv #(get (vec pts) %) face))
         faces (mapv get-pts faces)]
     (str name " = " "Part.makeSolid(Part.makeShell(" 
          (str/join ", " faces) "))")))

 #+end_src

**** extrude-linear
 Part.Face(Part.Wire(a)).extrude(FreeCAD.Base.Vector(0,0,10))

 #+begin_src clojure :tangle ./src/forge/compile/freecad.cljc
 (defmethod write-expr :extrude-linear
   [[_ {:keys [height]} form]]
   (let [sk (write-expr form)
         name (gensym "extrude_")
         sk-name (get-name sk)]
     (str sk "\n"
          name " = " "Part.Face(Part.Wire(" sk-name "))"
          ".extrude(" (vecstr [0 0 height]) ")")))

 #+end_src

**** extrude-rotate
 #+begin_src clojure :tangle ./src/forge/compile/freecad.cljc
 (defmethod write-expr :extrude-rotate
   [[_ {:keys [angle]} form]]
   (let [angle (if angle angle 360)
         sk (write-expr form)
         name (gensym "revolve_")
         sk-name (get-name sk)]
     (str sk "\n"
          name " = " "Part.Face(Part.Wire(" sk-name "))"
          ".rotate(" (vecstr [0 0 0]) "," (vecstr [1 0 0]) ", 90" ")"
          ".revolve(" (vecstr [0 0 0]) "," (vecstr [0 0 1]) "," angle ")")))

 #+end_src

*** transforms
**** rotation-matrix
 This is here as reference for if/when I improve how transforms are done. For instance, I could optimize output by baking all transforms down into a single matrix multiplication.

 #+begin_src clojure :tangle ./src/forge/compile/freecad.cljc
 (defn v* [a b] (mapv * a b))

 (defn normalize
   "find the unit vector of a given vector"
   [v]
   (let [m (Math/sqrt (reduce + (v* v v)))]
     (mapv / v (repeat m))))

 ;; rotation matrices sourced from:
 ;; https://sites.google.com/site/glennmurray/Home/rotation-matrices-and-formulas/rotation-about-an-arbitrary-axis-in-3-dimensions
 ;; zyx-rotation-matrix from section 3
 ;; axis-rotation-matrix from section 5.2

 (defn axis-rotation-matrix [a [x y z]]
   (let [[u v w] (normalize [x y z])
         c #(Math/cos %)
         s #(Math/sin %)]
     [[(+ (* u u) (* (- 1 (* u u)) (c a)))
       (- (* v u (- 1 (c a))) (* w (s a)))
       (+ (* w u (- 1 (c a))) (* v (s a)))
       0]

      [(+ (* u v (- 1 (c a))) (* w (s a)))
       (+ (* v v) (* (- 1 (* v v)) (c a)))
       (- (* w v (- 1 (c a))) (* u (s a)))
       0]

      [(- (* u w (- 1 (c a))) (* v (s a)))
       (+ (* v w (- 1 (c a))) (* u (s a)))
       (+ (* w w) (* (- 1 (* w w)) (c a)))
       0]

      [0 0 0 1]]))

 #+end_src

**** translate
 #+begin_src clojure :tangle ./src/forge/compile/freecad.cljc
 (defn build-translate
   [[x y z] form]
   (str form ".translate(" (vecstr [x y z]) ")"))

 (defmethod write-expr :translate
   [[_ {:keys [x y z]} forms]]
   (let [xforms (mapcat str/split-lines (map write-expr forms))]
     (str/join "\n" (map #(build-translate [x y z] %) xforms))))

 #+end_src

**** rotate
 #+begin_src clojure :tangle ./src/forge/compile/freecad.cljc
 (defn build-rotate
   [a [x y z] form]
   (str form ".rotate(" (vecstr [0 0 0]) ", " (vecstr [x y z]) ", " a ")"))

 (defmethod write-expr :rotatev
   [[_ {:keys [a x y z]} forms]]
   (let [xforms (mapcat str/split-lines (map write-expr forms))]
     (str/join "\n" (map #(build-rotate a [x y z] %) xforms))))

 (defmethod write-expr :rotatec
   [[_ {:keys [x y z]} forms]]
   (let [xforms (map #(->> %
                           (rotate z [0 0 1])
                           (rotate y [0 1 0])
                           (rotate x [1 0 0])) forms)]
     (str/join "\n" (map write-expr xforms))))

 #+end_src

**** color
 #+begin_src clojure :tangle ./src/forge/compile/freecad.cljc
 (defmethod write-expr :color
   [[_ {:keys [a x y z]} forms]]
   (str/join "\n" (map write-expr forms)))

 #+end_src

*** boolean-ops
**** difference
 Difference takes two elements: the base and the tool. THe base is what remains, the tool is the section that gets cut away.

 doc.addObject("Part::Cut","Cut_Name")
 doc.Cut_Name.Base = doc.cube_5771
 doc.Cut_Name.Tool = doc.cylinder_5772
 doc.hide("cube_5771")
 doc.hide("cylinder_5772")

 #+begin_src clojure :tangle ./src/forge/compile/freecad.cljc
 (defn build-cut
   [str-a str-b]
   (let [name (gensym "difference_")]
     (str str-a "\n"
          str-b "\n"
          name " = " (get-name str-a) ".cut(" (get-name str-b) ")")))

 (defmethod write-expr :difference
   [[_ _ forms]]
   (let [xforms (mapcat str/split-lines (map write-expr forms))]
     (str (reduce build-cut xforms) ".removeSplitter()")))

 #+end_src

**** union
 Union takes two elements: the base and the tool. THe base is what remains, the tool is the section that gets cut away.

 doc.addObject("Part::Fuse","Union_Name")
 doc.Union_Name.Base = doc.cube_5771
 doc.Union_Name.Tool = doc.cylinder_5772

 #+begin_src clojure :tangle ./src/forge/compile/freecad.cljc
 (defn build-fuse
   [str-a str-b]
   (let [name (gensym "union_")]
     (str str-a "\n"
          str-b "\n"
          name " = " (get-name str-a) ".fuse(" (get-name str-b) ")")))

 (defmethod write-expr :union
   [[_ _ forms]]
   (let [xforms (mapcat str/split-lines (map write-expr forms))]
     (str (reduce build-fuse xforms) ".removeSplitter()")))

 #+end_src

**** intersection
 Intersection takes two elements: the base and the tool. THe base is what remains, the tool is the section that gets cut away.

 doc.addObject("Part::MultiCommon","intersection_Name")
 doc.intersection_Name.Shapes = [doc.cube_5771, doc.cylinder_5772]

 #+begin_src clojure :tangle ./src/forge/compile/freecad.cljc
 (defn build-common
   [str-a str-b]
   (let [name (gensym "intersection_")]
     (str str-a "\n"
          str-b "\n"
          name " = " (get-name str-a) ".common(" (get-name str-b) ")")))

 (defmethod write-expr :intersection
   [[_ _ forms]]
   (let [xforms (mapcat str/split-lines (map write-expr forms))]
     (str (reduce build-common xforms) ".removeSplitter()")))

 #+end_src

*** write-fcs
FreeCAD command line tool is basically just a python interactive shell. So, you can actually use the python CLI flags just fine.

 ~python -c "print('Hello')"~

 Will print 'Hello' because the interpreter executes the string as python code.

 So, I can do the same thing with freecad -c. Then, to export a STEP file, I can actually pass the whole script as a string, bypassing the need to write/del files.

 #+begin_src clojure :tangle ./src/forge/compile/freecad.cljc
 (defn write-fcs
   [& blocks]
   (let [block-strs (map write-expr blocks)
         names (map #(str "Part.show(" (get-name %) ", '" (gensym "fcs_") "')") block-strs)]
     (str/join "\n"
      (concat
       [fcs-preamble]
       block-strs
       names
       [fcs-postamble]))))

 (defn ->step
   [block]
   (sh "freecad" "-c" (write-fcs block)))

 #+end_src

** svg
The initial idea for SVG is to represent all shapes with edges and faces using svg-clj.path/polygon-path fn.

Every elem-to-svg needs the element and a transform function (xf) which takes a list of 3D points and returns a list of 2D points which fit the desired ortho projection (isometric being default).

*** ns
#+begin_src clojure :tangle ./src/forge/compile/svg.cljc
(ns forge.compile.svg
  (:require [clojure.java.shell :refer [sh]]
            [clojure.string :as str]
            [svg-clj.elements :as svg]
            [svg-clj.path :as path]
            [svg-clj.transforms :as tf]
            [svg-clj.tools :as tools]
            [hiccup.core :refer [html]]
            [forge.utils :as utils]))

#+end_src

*** elem-to-svg
#+begin_src clojure :tangle ./src/forge/compile/svg.cljc
;; multimethod
(defmulti elem-to-svg
  (fn [element _]
    (if (keyword? (first element)) 
      (first element) 
      :list)))

(defmethod elem-to-svg :list 
  [[& args] xf]
  (map #(elem-to-svg % xf) args))

#+end_src

*** 2d-impl
#+begin_src clojure :tangle ./src/forge/compile/svg.cljc
(defmethod elem-to-svg :circle
  [[_ {:keys [r center origin rotation translation]}] xf]
  (let [rot (if rotation rotation [0 0 0])
        tr (if translation translation [0 0 0])
        pts (->> (utils/regular-polygon-pts r 40)
                 (mapv #(conj % 0))
                 (mapv #(utils/v+ origin %))
                 (mapv #(utils/rotate-point % rot))
                 xf)]
    (-> (path/polygon-path pts)
        (tf/style {:fill "none"
                   :stroke "black"
                   :stroke-width "2px"}))))

(defmethod elem-to-svg :rect 
  [[_ {:keys [x y center origin rotation]}] xf]
  (let [pts (->> (if center
                   [ [(/ x -2.0) (/ y -2.0)]
                    [(/ x 2.0) (/ y -2.0)] 
                    [(/ x 2.0) (/ y 2.0)]
                    [(/ x -2.0) (/ y 2.0)] ]
                   [ [0 0] [x 0] [x y] [0 y] ])
                 (mapv #(utils/v+ origin %))
                 (mapv #(utils/rotate-point % rotation))
                 xf)]
    (-> (path/polygon-path pts)
        (tf/style {:fill "none"
                   :stroke "black"
                   :stroke-width "2px"}))))

(defmethod elem-to-svg :polygon
  [[_ {:keys [pts paths convexity]}] xf]
  (let [polygons (for [path paths]
                   (xf (map #(get pts %) path)))]
    (-> (apply path/merge-paths 
               (map path/polygon-path polygons))
        (tf/style {:fill "none"
                   :stroke "black"
                   :stroke-width "2px"}))))

#+end_src

*** transforms-impl
#+begin_src clojure :tangle ./src/forge/compile/svg.cljc
(defmethod elem-to-svg :translate 
  [[_ {:keys [xf-elem]} block] xf]
  (elem-to-svg xf-elem xf))

(defmethod elem-to-svg :rotate 
  [[_ {:keys [xf-elem]} block] xf]
  (elem-to-svg xf-elem xf))

#+end_src

*** write
#+begin_src clojure :tangle ./src/forge/compile/svg.cljc
(def iso-euler-angles [35.264 45 0])
(def origin-angle-adjust-a [90 0 0])
(def origin-angle-adjust-b [0 -90 0])

(defn rotate-points
  [[ax ay az] pts]
  (mapv #(utils/rotate-point % [ax ay az]) pts))

(defn isometric-xf
  [pts]
  (->> pts
       (rotate-points origin-angle-adjust-a)
       (rotate-points origin-angle-adjust-b)
       (rotate-points iso-euler-angles)
       (mapv #(into [] (drop-last %)))))

(defn top-xf
  [pts]
  (-> pts
      (rotate-points [0 0 0])))

(defn right-xf
  [pts]
  (-> pts
      (rotate-points [90 0 0])))

(defn write
  [& mdl-data]
  (->> mdl-data
       (mapv #(elem-to-svg % isometric-xf))
       svg/g
       svg/svg
       #_html))

#+end_src

* scratch
A namespace for playing around with fns

** path-extrusion-surfaces
#+begin_src clojure
(load-file "src/forge/brep/curves.cljc")
(load-file "src/forge/brep/surfaces.cljc")

(ns forge.scratch
  (:require [forge.utils :as utils]
            [forge.model :as mdl]
            [forge.brep.curves :as bc]
            [forge.brep.surfaces :as bs]
            [forge.brep.mesh :as bmesh]
            [forge.compile.scad :as scad :refer [cider-show]]
            [svg-clj.path :as path]
            [svg-clj.transforms :as tf]))

(defn surface-mesh
  [surf seg]
  (let [{:keys [pts faces]} (bmesh/surface surf seg)]
    (mdl/polyhedron pts faces)))

(defn lcs
  [path t]
  (let [wo [0.00001 0.00001 0.00001]
        path (bc/to-3D path)
        m 40
        o (path t)
        f (bc/tangent path t)
        r (bc/normal path t [0 0 1])
        u (utils/cross* f r)
        [f r u] (map utils/normalize [f r u])]
    (mdl/group
     (-> (mdl/sphere 5) (mdl/translate o))
     (mdl/color (-> (mdl/line wo (map #(* m %) f)) (mdl/translate o)) [255 0 0 1])
     (mdl/color (-> (mdl/line wo (map #(* m %) r)) (mdl/translate o)) [0 255 0 1])
     (mdl/color (-> (mdl/line wo (map #(* m %) u)) (mdl/translate o)) [0 0 255 1]))))

(def a
  (let [shape (mdl/box 200 75 50)
        pt [300 300 300]
        [axis angle] (bs/quaternion->axis-angle (bs/look-at [1 0 0] pt [0 0 1]))
        path (-> (bc/circle 200)
                 #_(bc/rotate [45 0 0])) #_(bc/line [0 0 0] [0 0 1])
        xs (bc/polygon [[-20 -10] [ 20 -10]
                        [ 20  10] [-20  10]])]
    (mdl/group
     (-> (mdl/sphere 10) (mdl/translate pt))
     (-> shape
         (mdl/rotate angle axis))
     (map #(lcs path %) (range 0 1 0.05))
     (surface-mesh (bs/extrude-along xs path) 20))))

(def b (mdl/box 200 300 100))
#+end_src


** importing-svg
#+begin_src clojure
(ns forge.scratch
  (:require [forge.model :as mdl]
            [forge.utils :as utils]
            [forge.brep.curves :as bc]
            [forge.brep.surfaces :as bs]
            [forge.import.image :as img]
            [forge.compile.scad :as scad]))

(def a (-> (mdl/circle 20) 
           (mdl/extrude 100)))
(def b (-> (mdl/circle 20)
           (mdl/translate [40 0 0])
           (mdl/revolve 360)))
(def c (-> (utils/regular-polygon-pts 30 8)
           (mdl/polygon)
           (mdl/translate [180 0 0])
           (mdl/revolve 180)))
(def d (-> (img/import "sk.svg")))

(def e (-> (for [t (range 0 1.1 0.1)]
             ((bc/bezier [[0 0 0] [400 400 400] [700 50 200] [300 -200 100] [30 -500 -100]]) t))
           (mdl/polyline)))

(def aa
  (->> (slurp "sk.svg")
       svg-clj.utils/svg-str->hiccup
       (drop 2)
       last
       (drop 2)
       last
       svg-clj.transforms/path->elements))

(svg-clj.tools/cider-show aa)
(scad/cider-show d)

(defn line-drawing
  [fname & {:keys [r]}]
  (-> fname
      img->str
      svg-str->hiccup
      (->> (drop 2))
      re-center
      (->> (mapcat path/split-path))
      (->> (map path->pts))
      (->> (map #(mdl/polyline %)))
      mdl/union))

#+end_src

* axiart
** svg-surface
#+begin_src clojure
(load-file "src/forge/utils.cljc")
(load-file "src/forge/geom.cljc")
(load-file "src/forge/brep/curves.cljc")
(load-file "src/forge/brep/surfaces.cljc")
(load-file "src/forge/brep/mesh.cljc")

(ns forge.scratch
  (:require [clojure.string :as str]
            [forge.utils :as utils]
            [forge.model :as mdl]
            [forge.brep.curves :as bc]
            [forge.brep.surfaces :as bs]
            [forge.brep.mesh :as bmesh]
            [forge.compile.scad :as scad :refer [cider-show]]
            [svg-clj.elements :as el]
            [svg-clj.transforms :as tf]
            [svg-clj.parametric :as p]
            [svg-clj.layout :as lo]
            [svg-clj.tools :as tools]))

(def iso-euler-angles [35.264 45 0])
(def origin-angle-adjust-a [90 0 0])
(def origin-angle-adjust-b [0 -90 0])

(defn- sin-cos-pair [theta]
  [(Math/sin ^double (utils/to-rad theta))
   (Math/cos ^double (utils/to-rad theta))])

(defn- rot-pt-2d
  [[x y] theta]
  (let [[s-t c-t] (sin-cos-pair theta)]
    [(- (* x c-t) (* y s-t))
     (+ (* y c-t) (* x s-t))]))

;; this rotates a point around [0,0,0]
(defn- rot-pt
  [[x y z] axis theta]
  (cond
    (= axis :x) (into [x] (rot-pt-2d [y z] theta))
    (= axis :y) (apply #(into [] [%2 y %1]) (rot-pt-2d [z x] theta))
    (= axis :z) (into (rot-pt-2d [x y] theta) [z])))

(defn- rotate-point
  [pt [ax ay az]]
  (let [pt (if (< (count pt) 3)
             (conj pt 0)
             pt)]
    (-> pt
        (rot-pt :z az)
        (rot-pt :y ay)
        (rot-pt :x ax))))

(defn- rotate-points
  [pts [ax ay az]]
  (mapv #(rotate-point % [ax ay az]) pts))

(defn isometric-xf
  [pts]
  (-> pts
      (rotate-points origin-angle-adjust-a)
      (rotate-points origin-angle-adjust-b)
      (rotate-points iso-euler-angles)))

(defn svg-curve
  [curve seg]
  (let [pts (->> (bmesh/curve curve seg)
                 :pts
                 isometric-xf
                 (map drop-last)
                 vec)]
    (svg-clj.path/polyline pts)))

(defn- svg-single-surface
  [surface useg vseg]
  (let [{:keys [pts quads]} (bmesh/surface surface useg vseg)
        pts (mapv drop-last (vec (isometric-xf pts)))
        f (fn [face]
            (let [pts (remove nil? (map #(get pts %) face))
                  normal (apply utils/normal (map utils/add-z (take 3 pts)))
                  front-facing (when normal (pos? (last normal)))]
              (when (and front-facing
                         (= 4 (count pts)))
                (el/polygon pts))))]
    (remove nil? (map f quads))))

(defn svg-surface
  ([surface seg] (svg-surface seg seg))
  ([surface useg vseg]
   (let [surfaces (if (fn? surface) [surface] surface)]
     (el/g (mapcat #(svg-single-surface % useg vseg) surfaces)))))

(defn- quad-z
  [pts quad]
  (let [pts (map #(get pts %) quad)]
    (utils/centroid-of-pts pts)))

(defn svg-surface2
  [{:keys [pts quads] :as mesh}]
  (let [quads (reverse (sort-by #(quad-z pts %) quads))
        pts (mapv drop-last (vec (isometric-xf pts)))
        f (fn [face]
            (let [pts (remove nil? (map #(get pts %) face))
                  normal (apply utils/normal (map utils/add-z (take 3 pts)))
                  front-facing (when normal (neg? (last normal)))]
              (when (and front-facing
                         (= 4 (count pts)))
                (el/polygon pts))))]
    (remove nil? (map f quads))))

#+end_src

** svg-surface3
#+begin_src clojure
(defn any-pts-inside?
  [pg pts]
  (let [pts (filter (set pg) pts)]
    (geom/pt-inside? pg (utils/centroid-of-pts pg))
    #_(some true? (filter #(geom/pt-inside? pg %) (take 2 pts)))))

(defn svg-surface3
  [{:keys [pts quads] :as mesh}]
  (let [quads (reverse (sort-by #(quad-z pts %) quads))
        pts (mapv drop-last (vec (isometric-xf pts)))
        f (fn [face]
            (let [pts (vec (remove nil? (map #(vec (get pts %)) face)))
                  normal (apply utils/normal (map utils/add-z (take 3 pts)))
                  front-facing (when normal (neg? (last normal)))]
              (when true #_(and front-facing
                         (= 4 (count pts)))
                pts)))
        front-faces (map reverse (remove nil? (mapv f quads)))
        npts (set (apply concat front-faces))
        overlaps (filter #(any-pts-inside? % npts) front-faces)]
    (map #(el/polygon %) overlaps)))

#+end_src

** 001
#+begin_src clojure
(def rcut
  (let [[l w h] [500 500 500]
        [lh wh hh] (map #(/ % 2) [l w h])
        base (mdl/box l w h)
        dimfn (fn [] (+ (rand-int 55) 20))
        cutfn (fn [] (-> (mdl/box (dimfn) (dimfn) (dimfn))
                         (mdl/translate [(- (rand-int l) lh)
                                         (- (rand-int w) wh)
                                         (- (rand-int h) hh)])))]
    (mdl/difference
     base
     (apply mdl/union (repeatedly 2000 cutfn)))))

(spit "forge.scad" (scad/write rcut))

#+end_src

** 002
#+begin_src clojure
(defn sphere
  [r]
  (let [c (-> (bc/circle r)
              bc/to-3D
              (bc/rotate [0 90 0]))]
    (fn [u v]
      (let [a (* u 360)
            v (* v 0.5)
            xc (-> c (bc/rotate [0 0 a]))]
        (xc v)))))

(defn bezier-loop
  [pts]
  (let [ba (apply path/bezier pts)
        cp1 ((apply bc/line (reverse (take 2 pts))) 2)
        cp2 ((apply bc/line (take-last 2 pts)) 2)
        bb (path/bezier (last pts) cp2 cp1 (first pts))
        [path-start bez-a] (path/path-str->cmds (get-in ba [1 :d]))
        [_ bez-b] (path/path-str->cmds (get-in bb [1 :d]))
        close {:command "Z" :coordsys :abs}]
    (path/path (path/cmds->path-string [path-start bez-a bez-b close]))))

(defn sphere-blobs
  []
  (let [bezfn (fn [r bez-uvs]
                (let [ball (sphere r)
                      uvs (-> (bezier-loop bez-uvs)
                              path/decurve
                              (get-in [1 :d])
                              path/path-str->cmds
                              (->> (mapcat path/cmd->pts)))
                      shape (->> (map #(apply ball %) uvs)
                                 isometric-xf
                                 (map drop-last)
                                 (map vec)
                                 path/polygon)]
                  (-> shape 
                     (tf/style {:stroke "black"
                                :fill "none"
                                :stroke-width 2}))))
        buvs (fn [r pt]
               (let [c (-> (bc/circle r) bc/to-3D (bc/translate (utils/add-z pt)))
                     ts (take-nth 6 (sort (repeatedly 21 rand)))]
                 (map #(drop-last (c %)) ts)))
        ptfn (fn [n]
               (let [north ((sphere 100) 0 1)
                     south ((sphere 100) 0 0)
                     pts (->> (p/rect-grid 16 16 0.07 0.07)
                              (map #(apply (sphere 100) %))
                              (remove #(< (utils/distance north %) 23))
                              (remove #(< (utils/distance south %) 23)))]
                 (loop [acc [[0.375 0.5]]
                        pts (clojure.set/difference (set pts) (set (first acc)))]
                   (if-not (< (count acc) (* 2 (inc n)))
                     (take n (shuffle acc))
                     (let [next-pt (->> pts
                                        (sort-by
                                         (fn [pt] (/ (apply + (map #(utils/distance pt %) acc))
                                                     (count acc))))
                                        last)
                           remaining-pts (clojure.set/difference pts (set next-pt))]
                       (recur (conj acc next-pt) remaining-pts))))))
        bpts (->> (ptfn 11)
                  (map #(buvs (+ 0.09 (rand 0.015)) %)))]
    (el/g
     (-> (svg-surface (sphere 100) 20)
         (tf/style {:opacity 0.3}))
     (mapcat (fn [r] (map #(bezfn r %) bpts)) (range 100 205 7)))))

(def spheres-and-blobs
  (lo/distribute-on-pts (repeatedly 9 sphere-blobs) (p/rect-grid 3 3 450 450)))
  
(svg-clj.tools/cider-show spheres-and-blobs)

#+end_src

** 003
#+begin_src clojure
(def scut
  (let [r 250
        shell (sphere r)
        base (mdl/sphere r)
        dimfn (fn [] (+ (rand-int 40) 27))
        cutfn (fn [] (-> (mdl/sphere (dimfn))
                         (mdl/translate ((bc/line [0 0 0] (shell (+ 0.1 (rand 0.8))
                                                                 (+ 0.1 (rand 0.8)))) (+ 0.2 (rand 0.8))))))]
    (loop [base base
           itr 0]
      (if (< itr 500)
        (recur (mdl/difference base (cutfn)) (inc itr))
        base))
    #_(mdl/difference
     (conj
      (repeatedly 200 cutfn)
      base))))

(spit "forge.scad" (scad/write scut))

#+end_src

** 004
#+begin_src clojure
;; WIP
(defn- shift-face-indices
  [shift faces]
  (map (fn [face] (mapv #(+ shift %) face)) faces))

(defn obj
  [{:keys [pts quads] :as mesh}]
  (let [entryfn (fn [prefix data] (str/join " " (concat [prefix] data)))
        verts-str (str/join "\n" (map #(entryfn "v" %) pts))
        faces-str (str/join "\n" (map #(entryfn "f" %) (map #(mapv inc %) quads)))]
    (str/join "\n" [verts-str faces-str])))

;; piecewise function of two lines, where the peak has value
;; out-t = 1 at peak-t
;; in-t = 0 -> out-t = 0
;; in-t = peak-t -> out-t = 1
;; in-t = 1 -> out-t = 0
(defn tri-t
  [peak-t]
  (fn [t]
    (if (< t peak-t)
      (* (/ 1 peak-t) t)
      (+ (* (/ -1 (- 1 peak-t)) (- t peak-t)) 1))))

(defn slug
  [c r bump-t]
  (let [xsfn #(-> (* (svg-clj.utils/ease-in-out-sin ((tri-t bump-t) %)) r)
                  bc/circle
                  bc/to-3D)]
    (bs/extrude-fn-along xsfn c)))

(defn slugs [n]
  (let [h 775
        ra 90
        rb 350
        a [0 0 h]
        b [0 0 0]
        ring-a (-> (bc/circle ra)
                   bc/to-3D
                   (bc/translate [0 0 (* 2 (/ h 3))]))
        ring-b (-> (bc/circle rb)
                   bc/to-3D
                   (bc/translate [0 0 (* 1.8 (/ h 3))]))
        mid-sphere (-> (bs/sphere 90) (bs/translate [0 0 (* h 0.5)]))
        f (fn [] (-> (bc/bezier [a (ring-a (rand)) (ring-b (rand)) b])
                     (slug (+ 7 (rand-int 25)) (+ 0.1 (rand 0.75)))))]
    (repeatedly n f)))

(def radial-slugs
  (let [a (slug (bc/bezier [[0 0 875] [100 0 500] [400 0 250] [20 0 0]]) 25 0.7)]
    (-> (map #(-> a
                  (bs/translate [0 0 0])
                  (bs/rotate [0 0 %])) (range 0 360 45))
        (bmesh/surface 16 50)
        bmesh/mesh-merge
        svg-surface2
        el/g
        (tf/style {:fill "white" :stroke "black"}))))

(def random-slugs
  (let [s1 (slugs 1)
        s3 (slugs 3)
        s5 (slugs 5)
        s7 (slugs 7)
        gap 350]
    (el/g
     (-> (bmesh/surface s1 16 50)
         bmesh/mesh-merge
         svg-surface2
         el/g
         (tf/translate [0 0])
         (tf/style {:fill "none" :stroke "black"}))
     (-> (bmesh/surface s3 16 50)
         bmesh/mesh-merge
         svg-surface2
         el/g
         (tf/translate [gap 0])
         (tf/style {:fill "none" :stroke "black"}))
     (-> (bmesh/surface s5 16 50)
         bmesh/mesh-merge
         svg-surface2
         el/g
         (tf/translate [(* 2 gap) 0])
         (tf/style {:fill "none" :stroke "black"}))
     (-> (bmesh/surface s7 16 50)
         bmesh/mesh-merge
         svg-surface2
         el/g
         (tf/translate [(* 3 gap) 0])
         (tf/style {:fill "none" :stroke "black"})))))

(tools/cider-show random-slugs)

(defn mesh->polyhedron
  [{:keys [pts tris]}]
  (mdl/polyhedron pts tris))

(def scad-slugs
  (let [shapes (slugs 9)]
    (-> (apply mdl/union 
               (map #(-> (bmesh/surface % 16 50)
                         mesh->polyhedron)
                    shapes))
        (mdl/color [51 51 51 1]))))

(spit "forge.scad" (scad/write scad-slugs))

#+end_src

** 005
#+begin_src clojure
(def failing-cube
  (let [spc 20
        box-size 20
        n 16
        vox (apply concat
                   (for [lz (range n)]
                     (->> (bmesh/rect-grid n n spc spc)
                          (map utils/add-z)
                          (map #(utils/v+ [0 0 (* lz spc)] %)))))
        block-fn (fn [pos] (-> (mdl/box box-size box-size box-size)
                               (mdl/translate pos)
                               (mdl/color [51 51 51 1])))]
    (map block-fn (take (int (* 0.0625 n n n)) (shuffle vox)))))

(spit "forge.scad" (scad/write failing-cube))
#+end_src

** 006
#+begin_src clojure
(def bending-lines
  (let [w 800
        surf (bs/surface (bc/line [0.1 0 (* 0.25 w)] [0 0 (* 0.75 w)])
                         (bc/bezier [[w 0 0]
                                     [w (* -0.3 w) (* 0.325 w)]
                                     [w (* 0.9 w) (* 0.5 w)]
                                     [w 0 w]]))
        curves (map (fn [t] #((bs/rotate surf [(* 90 t) 0 0]) % t)) (range 0 1 0.0375))
        f (fn [curve]
            (-> curve
                (bmesh/curve 80)
                :pts
                mdl/polyline
                (mdl/color [255 255 255 1])))]
    (map f curves)))

(def bending-lines-svg
  (let [w 800
        surf (bs/surface (bc/line [0.1 0 (* 0.25 w)] [0 0 (* 0.75 w)])
                         (bc/bezier [[w 0 0]
                                     [w (* -0.3 w) (* 0.325 w)]
                                     [w (* 0.9 w) (* 0.5 w)]
                                     [w 0 w]]))
        curves (map (fn [t] #((bs/rotate surf [(* 90 t) 0 0]) % t)) (range 0 1 0.0375))
        f (fn [curve]
            (-> curve
                (bmesh/curve 100)
                :pts
                (->> (map rest))
                svg-clj.path/polyline
                (tf/style {:fill "none"
                           :stroke "white"})))]
    (map f curves)))

(spit "forge.scad" (scad/write bending-lines))

#+end_src

** 007
#+begin_src clojure
(defn rose-curve
  [r [n d]]
  (fn
    ([]
     {:fn `rose-curve
      :input [r [n d]]
      :origin [0 0]
      :vertex-params [0]
      :dimension 2})
    ([t]
     (let [k (/ n d)
           theta (utils/to-rad (* t 360 d))
           xr (* r (Math/cos (* k theta)))]
       [(* xr (Math/cos theta))
        (* xr (Math/sin theta))])))) 

(def roses
  (let [[n d] [4 9]
        r 250
        surf (bs/surface
              #_(-> (rose-curve (* r 0.125) [d n]))
              (-> (bc/circle (* r 0.1))
                  (bc/rotate [0 0 (* 360 (double (/ n d)))]))
              (-> (rose-curve r [n d])
                  (bc/translate [0 0 (* 4 r)])))
        curves (map (fn [t] #((-> surf
                                  (bs/rotate [0 0 (* 360 t)])
                                  (bs/translate [(* t r 2.5) 0 0])
                                  (bs/rotate [0 0 (* 315 t)])) % t)) (range 0 1 (double (/ 1 6))))
        f (fn [curve]
            (-> curve
                (bmesh/curve 300)
                :pts
                mdl/polyline
                (mdl/color [255 255 255 1])))]
    (map f curves)))

(def roses-svg
  (let [;; some adjustable params
        [n d] [9 7]
        r 250

        ;; create a 3D surface linearly interpolated from
        ;; a circle at [0 0 0] to a rose curve at [0 0 (* 4 r)]
        surf (bs/surface
              (bc/circle (* r 0.1))
              (-> (rose-curve r [n d])
                  (bc/translate [0 0 (* 4 r)])))

        ;; slice the surface up. A planar slice of a 3D surface produces a curve
        ;; (surf u v) -> we pin v for each slice creating a new curve fn
        ;; for example we could manually def a slice:
        ;; (def slice1 (fn [t] (surf t 0.1)))
        curves (map (fn [v]
                      #((-> surf
                            (bs/rotate [0 0 (* 360 v)])
                            (bs/translate [(* t r 2.5) 0 0])
                            (bs/rotate [0 0 (* 315 v)])) % v))
                    (range 0 1 (double (/ 1 6))))

        ;; create a function to turn each curve into an
        ;; svg polygon and style it
        f (fn [curve]
            (-> curve
                (bmesh/curve 700)
                :pts
                (->> (map drop-last))
                svg-clj.path/polygon
                (tf/style {:fill "none"
                           :stroke "white"})))]
    ;; produce a list of svg polygon elements in hiccup syntax
    ;; which is compiled to an SVG string and saved
    (map f curves)))

(spit "forge.scad" (scad/write roses))

#+end_src

*** 008
#+begin_src clojure
(defn next-collatz
  [n]
  (if (even? n)
    (/ n 2)
    (+ (* 3 n) 1)))

(defn collatz
  [n]
  (when (> n 0)
    (->> (iterate next-collatz n)
         (take-while #(not (= 1 %)))
         reverse
         (cons 1))))

(defn collatz->pts
  [n {:keys [angle length]}]
  (let [collatz-seq (collatz n)
        #_#_angle (* angle (count collatz-seq))
        #_#_length (double (/ length (count collatz-seq))) 
        f (fn [last-a pts s]
            (if (empty? s)
              pts
              (let [[n xs] ((juxt first rest) s)
                    a-dir (if (even? n) 1 -1)
                    xa (+ last-a (* angle a-dir))
                    pt (-> [length 0]
                           (svg-clj.utils/rotate-pt xa)
                           (utils/v+ (last pts))
                           (->> (mapv #(utils/round % 3))))]
              (recur xa (conj pts pt) xs))))]
    (f 0 [[0 0]] collatz-seq)))

(def collatz-lines
  (for [n (range 1000 4000)]
    (-> (collatz->pts n {:angle 10.1
                         :length 4})
        el/polyline
        (tf/style {:fill "none"
                   :stroke "white"
                   :opacity 0.1
                   :stroke-width 1}))))

(svg-clj.tools/cider-show collatz-lines)

#+end_src

** extrude-along-scratch
#+begin_src clojure
(def axes
  (el/g
   (el/g (svg-surface2 (bmesh/surface (-> (bs/sphere 5) (bs/translate [0 0 0])) 5 5)))
   (-> (bs/extrude-along (bc/circle 5) (bc/line [0.001 0.001 0.001] [300 0 0]))
       (bmesh/surface 9 5)
       svg-surface2
       el/g
       (tf/style {:fill "red" :stroke "none"}))
   (-> (bs/extrude-along (bc/circle 5) (bc/line [0.001 0.001 0.001] [0 300 0]))
       (bmesh/surface 9 5)
       svg-surface2
       el/g
       (tf/style {:fill "green" :stroke "none"}))
   (-> (bs/extrude-along (bc/circle 5) (bc/line [0.001 0.001 0.001] [0 0 300]))
       (bmesh/surface 9 5)
       svg-surface2
       el/g
       (tf/style {:fill "blue" :stroke "none"}))))

(def a2
  (let [[a b] [[0 0 0] [100 100 100]]]
    (->
     (el/g
      (svg-surface2 (bmesh/surface (-> (bs/sphere 5) (bs/translate a)) 5 5))
      (svg-surface2 (bmesh/surface (-> (bs/sphere 5) (bs/translate b)) 5 5))
      (svg-surface2 (bmesh/surface
                     (bs/extrude-along (bc/circle 27) (bc/line a b)) 20 10)))
     (tf/style {:fill "white" :stroke "black"}))))

(defn show-tangents
  ([c seg] (show-tangents c seg (bs/find-up c)))
  ([c seg up]
   (let [step (double (/ 1 seg))
         ts (range 0 1 step)
         csfn (fn [t]
                (let [a (c t)
                      w (utils/normalize (bc/tangent c t))
                      u (utils/normalize (utils/cross* up w))
                      v (utils/normalize (utils/cross* w u))
                      m [(vec (concat u [0]))
                         (vec (concat v [0]))
                         (vec (concat w [0]))
                         (vec (concat a [1]))]
                      m2 (utils/look-at-matrix a (bc/tangent c t) up)
                      wpt (utils/v+ (utils/v* [15 15 15] w) a)
                      upt (utils/v+ (utils/v* [15 15 15] u) a)
                      vpt (utils/v+ (utils/v* [15 15 15] v) a)]
                  (mdl/group
                   (-> (mdl/line upt a) (mdl/color [255 0 0 1]))
                   (-> (mdl/line vpt a) (mdl/color [0 255 0 1]))
                   (-> (mdl/line wpt a) (mdl/color [0 0 255 1])))))]
     (map csfn ts))))

(defn bezier-loop
  [pts]
  (let [ba (bc/bezier pts)
        cp1 ((apply bc/line (reverse (take 2 pts))) 2)
        cp2 ((apply bc/line (take-last 2 pts)) 2)
        bb (bc/bezier [(last pts) cp2 cp1 (first pts)])]
    (bc/piecewise-curve [ba bb])))

(defn tri-t
  [peak-t]
  (fn [t]
    (if (< t peak-t)
      (* (/ 1 peak-t) t)
      (+ (* (/ -1 (- 1 peak-t)) (- t peak-t)) 1))))

(def asdf
  (let [path (bc/circle 200) #_(bezier-loop [[0 0 0]
                           [300 0 0]
                           [300 200 100]
                           [0 200 0]])
        xs (bezier-loop [[-20 -40 0]
                         [20 -40 0]
                         [20 40 0]
                         [-20 40 0]])
        r 100
        xsfn #(-> (* (svg-clj.utils/ease-in-out-sin ((tri-t 0.5) %)) r)
                  bc/circle
                  bc/to-3D)
        {:keys [pts quads] :as s} (-> (bs/extrude-fn-along xsfn path [0 0 1])
                                (bmesh/surface 30 100))]
    (svg-surface2 s) #_(mdl/group
     #_(show-tangents path 30)
     (-> (mdl/polyhedron pts quads)
         (mdl/color [120 120 120 1])))))

#+end_src

** lorenz-attractor
#+begin_src clojure
(defn lorenz
  [[sigma rho beta] [x y z]]
  (let [f (fn [[[x y z]
                [dx dy dz dt]]]
            (let [dx (* (* sigma (- y x)) dt)
                  dy (* (- (* x (- rho z)) y) dt)
                  dz (* (- (* x y) (* beta z)) dt)]
              [[(+ x dx) (+ y dy) (+ z dz)]
               [dx dy dz dt]]))]
    (fn [dt steps]
      (map first (take steps (iterate f [[x y z] [0 0 0 dt]]))))))

(let [c
      (lorenz [10 28 (/ 8 3.0)] [0.1 0.1 0.1])
      #_(lorenz [(/ 5 7) (/ 7 9) (/ 5 23)] [2 2 2])
      n 10000
      pts (c 0.01 n)]
  (-> (bc/polyline pts)
      (bc/rotate [70 45 70])
      (bc/rotate [70 45 75])
      (bc/scale [5 5 5])
      (svg-curve n)
      tools/cider-show))

(def a
  (let [p (-> (bc/circle 162)
              bc/to-3D
              (bc/rotate [0 0 190]))
        g 275
        step 0.00375
        xs (fn [amp freq t]
             (bc/circle (+ 20 (* ((p/sinwave amp freq) t) 10))))
        f (fn [amp freq t]
            (let [from (utils/add-z (p t))
                  to (utils/add-z (bc/tangent p t))]
              (-> (xs amp freq t)
                  (bc/look-at (utils/v+ from to) [0 1 0])
                  (bc/translate from)
                  (bc/rotate [0 0 90])
                  (svg-curve 20))))]
    (el/g
     (-> (el/g (map #(f 2 2 %) (range 0 1 step)))
         (tf/translate [0 0]))
     (-> (el/g (map #(f 1.8 4 %) (range 0 1 step)))
         (tf/translate [0 g]))
     (-> (el/g (map #(f 1.6 6 %) (range 0 1 step)))
         (tf/translate [0 (* 2 g)]))
     (-> (el/g (map #(f 1.4 8 %) (range 0 1 step)))
         (tf/translate [0 (* 3 g)]))
     (-> (el/g (map #(f 1.2 10 %) (range 0 1 step)))
         (tf/translate [0 (* 4 g)])))))

(def b
  (let [p1 (-> (bc/circle 150)
               bc/to-3D
               (bc/translate [0 -150 0])
               (bc/rotate [0 0 180]))
        p2 (-> (bc/circle 150)
               bc/to-3D
               #_(bc/translate [0 150 0])
               (bc/rotate [0 90 0]))
        g 275
        step 0.00375
        xs (fn [amp freq t]
             (bc/circle (+ 20 (* ((p/sinwave amp freq) t) 10))))
        f (fn [amp freq p t]
            (let [from (utils/add-z (p t))
                  to (utils/add-z (bc/tangent p t))]
              (-> (xs amp freq t)
                  (bc/look-at (utils/v+ from to) [0 1 0])
                  (bc/translate from)
                  (bc/rotate [0 0 90])
                  (svg-curve 20))))]
    (el/g
     #_(svg-curve p1 120)
     #_(svg-curve p2 120)
     (-> (el/g (map #(f 2 2 p1 %) (range 0 1 step)))
         (tf/translate [0 0]))
     (-> (el/g (map #(f 2 2 p2 %) (range 0 1 step)))
         (tf/translate [0 0])))))

(def c
  (let [p1 (-> (bc/circle 150)
               bc/to-3D
               (bc/rotate [0 0 215]))
        g 275
        step 0.01
        xs (fn [amp freq t]
             (bc/circle (+ 20 (* ((p/sinwave amp freq) t) 10))))
        f (fn [amp freq p t]
            (let [from (utils/add-z (p t))
                  to (utils/add-z (bc/tangent p t))]
              (-> (xs amp freq t)
                  (bc/look-at (utils/v+ from to) [0 1 0])
                  (bc/translate from)
                  (bc/rotate [0 0 90])
                  (bmesh/curve 20)
                  :pts
                  isometric-xf)))]
    #_(->> (mapcat #(f 0.7 20 p1 %) (range 0 1 step))
         (map #(clojure.string/join \tab %))
         (clojure.string/join \newline))
    (el/g (map #(-> (el/circle 1) (tf/translate (drop-last %))) (mapcat #(f 0.7 20 p1 %) (range 0 1 step))))))
#+end_src

* polygon-intersection-scratch
#+begin_src clojure
(load-file "src/forge/utils.cljc")
(load-file "src/forge/geom.cljc")

(ns forge.scratch
  (:require [clojure.string :as str]
            [forge.utils :as utils]
            [forge.geom :as geom]
            [svg-clj.elements :as el]
            [svg-clj.transforms :as tf]
            [svg-clj.parametric :as p]
            [svg-clj.layout :as lo]
            [svg-clj.tools :as tools]))

(def a (utils/regular-polygon-pts 120 4))
(def b (map #(utils/v+ % [90 0]) (utils/regular-polygon-pts 30.01 4)))

(def asdf
  (let [a-b (geom/polygon-difference a b)
        #_#_a+b (geom/polygon-union a b)]
    (el/g
     (-> (el/polygon a)
         (tf/style {:fill "none" :stroke "green"}))
     (-> (el/polygon b)
         (tf/style {:fill "none" :stroke "green"}))
     (-> (el/polygon a-b)
         (tf/style {:fill "limegreen" :stroke "red"})))))

(tools/cider-show asdf)

#+end_src
