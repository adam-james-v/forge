* ;;
#+Title: forge
#+SUBTITLE: build solid modeling programs
#+AUTHOR: adam-james
#+STARTUP: overview
#+EXCLUDE_TAGS: nx
#+PROPERTY: header-args :cache yes :noweb yes :results none :mkdirp yes :padline yes :async
#+HTML_DOCTYPE: html5
#+OPTIONS: toc:2 num:nil html-style:nil html-postamble:nil html-preamble:nil html5-fancy:t

** deps.edn
#+NAME: deps.edn
#+begin_src clojure :tangle ./deps.edn
{:deps 
 {org.clojure/clojure            {:mvn/version "1.10.2"}
  org.clojure/clojurescript      {:mvn/version "1.10.597"}
  org.clojure/test.check         {:mvn/version "0.9.0"}
  org.clojure/math.numeric-tower {:mvn/version "0.0.4"}
  org.clojure/core.logic         {:mvn/version "0.8.11"}
  hiccup/hiccup                  {:mvn/version "2.0.0-alpha2"}
  hawk/hawk                      {:mvn/version "0.2.11"}
  same/ish                       {:mvn/version "0.1.4"}
  svg-clj/svg-clj                {:local/root "/Users/adam/dev/svg-clj"}
  #_occjava #_{:local/root  "./resources/occjava.jar"}}

 :paths ["src" "resources"]

 :aliases
 {:base {:jvm-opts ["-Djava.library.path=/usr/local/lib:./resources:"]}}}

#+end_src

OCC works when clj is invoked with clj -A:base.

** readme
#+BEGIN_SRC markdown :tangle ./readme.md
# Forge

Forge is a library for 3D CAD data.

Currently presented here without a license as things are still highly experimental and subject to changes.

#+END_SRC

* design
** intro
*** Pitch
Forge is a powerful Design library that enhances the work of designers and engineers by providing a concise, powerful set of design documentation and creation tools.

It works with the following flow:
- create a text document
- write your specs, design ideas, scope, and any other necessary documentation in plain text
- enter code descriptions of all parts and assemblies in the same document, right with the documentation
- Forge 'renders' this text document to an html file
- view, interact with, change parameters, and export from this html file

*** Emphasis and Values
The design and implementation of Forge focuses heavily on:

- Simplicity
- Composition
- Discipline
- Documentation as Design
- Pragmatic Correctness and Completeness
- Open Source
- User Empowerment

*** Motivation
Design is a difficult task for the craftsperson, and the tools should be as integral to the design work as any final components. At the same time, effective design is communicative of purpose, intent, and method. Designs solve problems as elegantly as possible, taking into primary consideration the context in which the design will live. With such a broad yet critical task, designers must be given the power to create solutions and build abstractions at every layer of their process; from tools to final design.

Solid Modeling is fundamentally a method of communicating the form, function, and interactions of physical objects. Modern CAD programs are extremely powerful and expressive tools which facilitate effective capture of many design needs. Where CAD tools fall short is in expressiveness of parametric design needs, computational approaches to modeling, and reusability of complex and parametric assembly data.

Instead of focusing on the direct manipulation of 3D objects in a user interface, forge favours flexibility and specificity by embracing the functional programming approach. Visual aids are critical for the proper understanding of a solid model, but a visual approach alone is insufficient for fully describing advanced design ideas or parametric aspects of a design. Forge effectively blends the visual elements of design with the expressive power of programming to empower designers to more fully communicate design intent and to enhance problem solving in general.

*** What is Forge?
Forge is a tool that embraces the dynamic and evolving nature of complexity in design by enabling engineers and designers to directly program their designs.

Forge is a Clojure and ClojureScript library for building 3D modeling programs, inspired by [[https://libfive.com/][libfive]], [[http://www.openscad.org/][OpenSCAD]], and [[https://github.com/CadQuery/cadquery][CadQuery]].

*** Intended Workflow
The intended workflow of the Forge library is very simple and is meant to 'get out of the way' of designers and engineers.

The following workflow is assumed to be 'fuzzy' at the transition boundaries from one phase to the next. Additionally, it should be assumed that iteration loops between any number of steps may need to occur. For example, it is often the case in real-world projects that the spec and design phases change dynamically even as programming nears completion. 

**** Spec
Write a specification document capturing the problem being solved and the intended scope of the solution being designed.

**** Design
Document the design in words, pictures, existing 3d models, links to other Forge documents, etc.
For small projects, the spec and design steps can be combined, or even skipped altogether. It is, however, always recommended to at least provide a small explanation section prior to implementing any solutions, to give context to future users.

**** Program
Use all of the Clojure/Clojurescript ecosystem alongside the Forge library to implement scripts and programs that can produce a fully parametric solid model of all parts and assemblies for the design.

This phase can additionally be used to add analytic modelling capabilities and advanced engineering calculations into the model directly using the built in Forge engineering capabilities or pairing with external math, numerics, solver, and AI libraries. The limit is the user's imagination and confidence.

**** Render
Forge is used to read, parse, and compile the design document, which at this point is a full design journal of prose and code which all define the design.

The output of this render process is a powerful html document that fully embeds the working model code alongside the text explaining the design. This is presented to the user as an 'interactive essay' where every part and assembly is shown in 3D and can be manipulated live. All programmed parameters become available as interface elements such as sliders, radio buttons, and drop-down menus where the user can dynamically change the displayed design.

**** Export
From within the rendered html, once a user is satisfied with any parameter changes and is confident the code is 'production ready', it is possible to export final files.

If no commercial CAD software is available, Forge can serve as a perfectly viable commercial tool as it can fully render and export 2D drawing packages suitable for manufacturing.

If designers wish to add or change designs in a tool they are familiar with, commercial CAD export options exist: STEP files (generic, safe export option), SW vba script files, Inventor vba script files, and AutoCAD LISP files are all producible. These scripts, when run in their appropriate software, will render a fully native part/assembly file.

**** Iterate
The design of a solution is fully described in text and code, and so is quick to change, fast to load, and easy to manipulate. With Forge's 'watch and render' capabilities, a very tight design loop is formed where the designer can create changes to text and code and see them reflected live in the rendered document. 

This is excellent for design work which can be completed by an individual. Iteration however, often occurs over the course of days and weeks and includes many different stakeholders. Forge's intended workflow is designed so that the canonical design is always captured in the text. If a CAD file is lost, it can be re-produced easily from the text. If stakeholders make custom, one-time tweaks to CAD files or drawings, they do not 'filter back' and cause problems with the original design. 

The 'change arrow' always occurs one way. txt -> html -> CAD
This mono-directional change seems like a hinderance, but forces the user(s) to capture design intent at the lowest level, always ensuring correctness downstream.

** architecture
The Forge library is architected around an idea of *functional layering.* Layering begins with a *kernel* of necessary functionality and wraps on additional functionality. Each added layer depends upon prior layers, but adds value to the unit as a whole. This implies that:
 - a *kernel* is the minimum set of functionality that can provide value
 - any layer on its own provides no utility, due to its dependence on prior layers

The layering concept is useful at varying levels of abstraction and is used liberally throughout the Forge Library.

*** Code Units
Layering provides structure to *code units* which are well-designed sets of functions that provide utility in some context. 

Extending the idea of a code unit is a *design document* which is a document that fully captures the problem, and the design intent of the unit. 

It is not strictly necessary to realize every layer to produce a valid code unit, with the exception of the kernel. Nevertheless, a code unit becomes more valuable with each layer implemented.

With this in mind, the layers of a code unit are as follows:
 
 1. *design*
    A document explaining the need for the unit and the approach being taken to address it. A fully developed design will include elements familiar to engineers like a problem statement, assumptions, unknowns, constraints, and parameters.

 2. *kernel*
    The set of functions that implement the required functionality. The most direct realization of an algorithm or procedure for meeting the requirements.

 3. *guard*
    Validation functions or specs that ensure any data passed into the kernel is correctly shaped and logically correct according to the intended use cases. Error handling functions that protect and communicate errors that originate in the kernel.

 4. *instrumentation*
    The set of functions that perform useful measurement tasks such as logging, debugging, and timing.

 5. *optimization*
    The set of functions that can use additional logic to create functionally equivalent versions of data and/or functions that run more optimally than the default kernel.

 6. *interface*
    The set of functions that wrap all prior layers into a package that can be appropriately and easily used by users. Different users may use different interfaces such as dev. and user interfaces.

 7. *test*
    The set of functions which run unit tests on all prior layers as well as integration tests for the fully wrapped kernel.

*** Library Structure
The layering of the Forge Library begins at the *solid model* and extends up to the *test harness* layer.

The layers:
 1. design
 2. solid model
 3. guard
 4. analytic model
 5. optimizer
 6. interface
 7. test harness

**** design
The design of the Forge Library is captured in the form of a literate program. In fact, it lives in this very document. Additional notes and diagrams are added into the project's directory and linked into this document as needed.

**** solid model
The solid model is a *script* using the *domain specific language (DSL)* provided by ~forge.lang~ to describe the shape and dimensions of an object. This is the minimum required element for creating a useful design with Forge. The DSL is embedded within Clojure/Clojurescript permitting full use of the entire Clojure ecosystem of libraries.

User facing functions are geometric, transforms, constructive, topological, math, and utility functions which can all be used to accurately describe parts and assemblies. In all cases, the user is not required to consider the underlying implementation of any functions.

A solid model is *executable*. When run, a solid model program will produce an *enriched abstract syntax tree (AST)* which forms the main data structure on which all subsequent layers operate.

**** guard
The guard layer provides *validation* of data entering the solid model and *error handling* to properly manage errors that occur when the solid model is executed.

Beyond simple validation and error handling, Forge's guard layer consists of a parameter and constraint handling set of functions. These functions allow the user to specify many types of parametric relationships between dimensions and variables defined in the solid model, as well as constraints.

If no guards are explicitly designed, the constraints and parameters default to be fixed at the intial values programmed into the solid model.

**** analytic model
The analytic model provides advanced functionality for describing high level requirements which are typically derived from engineering analysis considerations.

The analytical model has two pathways for affecting the solid model: *interfacing* or *integrating*. 

Interfacing is the simpler approach as it adjusts the model strictly through the guard layer; the results from an analysis run will only ever change parameter and constraint values.

Integrating is a much more complex mode as it can directly alter the solid model's code. This may be desireable for highly complex logical transformations of a model based on a very involved analysis approach. It is more complex because changing the solid model necessarily requires that the analytic model has logic for updating the parameters and constraints in the guard layer.

Both modes of analytic interaction are fully supported and encouraged by the Forge library.

**** optimizer
The optimizer is capable of altering the AST to improve on various key metrics such as generation speed, memory use, renderability, exportability, and complexity.

The optimizer performs these improvements heuristically. It is important to allow the optimizer to be tuned appropriately for the use case because some optimizations may lead to lossy alterations. This is of particular importance for highly parametric designs as geometric simplification may accidentally erase design intent.

The main optimizations focus on AST simplification by swapping nested structures for volumetrically equivalent flat calls.

**** interface
The interface layer has a high degree of optionality as it contains diverse functionality:
 - graphical views
 - GUI forms
 - minimal viewers
 - web app producers
 - compilers/transpilers
 - exporters

All interface functionality is intended to be used as pieces for the designer to be able to build a program which can fully express the design intent of *all possible* variants of the design.

**** test harness
The guard layer is intended to handle data related validation and to enforce appropriate constraints and parameter limits, but it is not a sufficient layer for fully testing the entire design program. The test harness layer provides a suite of useful tests which can be run against any Forge prorgam.

The test harness also provides a simple interface for designers to define their own tests and run them with the rest of the test suite.

*** A Diagram
To keep it all straight.

#+begin_src text

   design
     doc
      |
      V
+-----------+
|   solid   |<--(ns forge.lang)<-+--(ns forge.brep)
|   model   |                     `-(ns forge.frep)
+-----------+
      |
      V
+-----------+
|   guard   |<--(ns forge.guard)
|           |
+-----------+
      |
      V
+-----------+
| analytic  |<--(ns forge.analytic)
|   model   |
+-----------+
      |
      V
+-----------+
| optimizer |<--(ns forge.optimize)
|           |
+-----------+
      |
      V                            ,-(ns forge.app)
+-----------+                     |--(ns forge.gui)
| interface |<--(ns forge.build)<-+--(ns forge.impl)
|           |                     |--(ns forge.view)
+-----------+                     |--(ns forge.compile)
      |                            `-(ns forge.web)
      V
+-----------+
|   test    |<--(ns forge.test)
|  harness  |
+-----------+
      |
      V
 integration

#+end_src
** notes
I need to productize fairly quickly.

Necessary features for acceptable 'paid prototyping':
- STEP export 
  - do this by creating a Server/Client Webapp. FreeCAD first as STEP backend
  - upgrade from FreeCAD to proper Kernel (OCCT...)
  - alternatively, use CadQuery 2.0 as the intermediate.
- WebGL 3D renders
- Drawing Export
  - PDF
  - Parametric SVGs in design docs
  - DXF

Very soon after initial contracts, I suspect I'll need:
- native export
  - Macro generators for VBA (SW and Inventor)
  - AutoLISP generators

- DesignDoc Editor App
  - let users design their own part/assembly docs with some basic notebook style tooling

Long term, I want to build my own CAD Kernel, native in Clojure so that CLJ/CLJS can be fully portable without any connection to a server. This will be useful for powerful app building -> custom CAD programs for very niche design industries.

* ns
#+BEGIN_SRC clojure :tangle ./src/forge/proto.cljc
(ns forge.proto
  (:require [forge.delaunay :as delaunay]
            [same :refer [ish? zeroish?]]))

#+END_SRC

* math-geom
Use the util namespace to place functions which may be used across the other namespaces. Currently the util namespace contains mostly geometry calculation functions like checks for lines and points.

** comparing-floats
This is a strangely complicated topic, and I want to implement my own functions to help compare float/double numbers to one another.

This is mostly necessary for comparing two equal-length collections of float values. This pops up a lot when doing geometry calculations due to vector and matrix operations, which are represented with [Clojure vectors] in Forge.

Since I will also need to check if float values are near zero, I'll have a special function specifically for that. This is necessary because of how floating point values are represented. The zero case is special, so I have a function for it.

NOTE: Provide more clear explanation about floating point comparisons AND my implementation choice. In particular, talk about relativeMax and why I did NOT use ULP methods.

The implementation is taken from:
[[https://floating-point-gui.de/errors/NearlyEqualsTest.java]]

This, like any float comparison implementation, is not guaranteed to be useful in all contexts.

It is sufficient for Forge for the following reasons:
- it is used near zero most often
- it is unlikely to be used when handling values much larger than 10,000 in magnitude due to typical scales of units in engineering projects.

#+begin_src clojure :tangle ./src/forge/proto.cljc
(defn nearly?
  "compare two float values for approximate equality.
   
   Default epsilon = 0.00001"
  ([a b]
   (nearly? a b 0.00001))

  ([a b epsilon]
   (let [a (float a)
         b (float b)]
     (if (= a b)
       true
       (let [absA (Math/abs a)
             absB (Math/abs b)
             diff (Math/abs (- a b))
             min-f 1.17549435E-38
             max-f 3.4028235E38]
         (if (or (= a 0.0) 
                 (= b 0.0) 
                 (< (+ absA absB) min-f))
           (< diff (* epsilon min-f))
           (< (/ diff (Math/min (+ absA absB) max-f)) epsilon)))))))

(defn all-nearly?
  "check if all numbers are nearly equal to one another in two collections"
  [coll-a coll-b]
  (if (not (= (count coll-a) (count coll-b)))
    #?(:clj  (throw (Exception. "collections must be same size."))
       :cljs (throw (js/Error. "collections must be same size.")))
    (let [diffs (mapv #(float (Math/abs (- %1 %2))) coll-a coll-b)]
      (empty? 
       (filter 
        false? 
        (map zeroish? diffs))))))

#+end_src

To make sure float checks work, I'm implementing unit tests.

The tests here are taken from:
[[https://floating-point-gui.de/errors/NearlyEqualsTest.java]]

and re-implemented with clojure.test library.

*** float-comparison-tests
#+begin_src clojure
(deftest nearly-test
  (testing "Regular large numbers"
    (is      (nearly? (float 1000000) (float 1000001)))
    (is      (nearly? (float 1000001) (float 1000000)))
    (is (not (nearly? (float 10000) (float 10001))))
    (is (not (nearly? (float 10001) (float 10000)))))
  (testing "Negative large numbers"
    (is      (nearly? (float -1000000) (float -1000001)))
    (is      (nearly? (float -1000001) (float -1000000)))
    (is (not (nearly? (float -10000) (float -10001))))
    (is (not (nearly? (float -10001) (float -10000)))))
  (testing "Numbers around 1"
    (is      (nearly? (float 1.0000001) (float 1.0000002)))
    (is      (nearly? (float 1.0000002) (float 1.0000001)))
    (is (not (nearly? (float 1.0001) (float 1.0002))))
    (is (not (nearly? (float 1.0002) (float 1.0001)))))
  (testing "Numbers around -1"
    (is      (nearly? (float -1.0000001) (float -1.0000002)))
    (is      (nearly? (float -1.0000002) (float -1.0000001)))
    (is (not (nearly? (float -1.0001) (float -1.0002))))
    (is (not (nearly? (float -1.0002) (float -1.0001)))))
  (testing "Numbers between 1 and 0"
    (is      (nearly? (float 0.000000001000001) (float 0.000000001000002)))
    (is      (nearly? (float 0.000000001000002) (float 0.000000001000001)))
    (is (not (nearly? (float 0.000000000001001) (float 0.000000000001002))))
    (is (not (nearly? (float 0.000000000001002) (float 0.000000000001001)))))
  (testing "Numbers between -1 and 0"
    (is      (nearly? (float -0.000000001000001) (float -0.000000001000002)))
    (is      (nearly? (float -0.000000001000002) (float -0.000000001000001)))
    (is (not (nearly? (float -0.000000000001001) (float -0.000000000001002))))
    (is (not (nearly? (float -0.000000000001002) (float -0.000000000001001)))))
  (testing "Small differences away from zero"
    (is (nearly? (float 0.3) (float 0.30000003)))
    (is (nearly? (float -0.3) (float -0.30000003))))
  (testing "Comparisons involving zero"
    (is      (nearly? (float 0.0) (float 0.0)))
    (is      (nearly? (float 0.0) (float -0.0)))
    (is      (nearly? (float -0.0) (float -0.0)))
    (is (not (nearly? (float 0.00000001) (float 0.0))))
    (is (not (nearly? (float 0.0) (float 0.00000001))))
    (is (not (nearly? (float -0.00000001) (float 0.0))))
    (is (not (nearly? (float 0.0) (float -0.00000001))))
    (is      (nearly? (float 0.0) (float 1e-40) (float 0.01)))
    (is      (nearly? (float 1e-40) (float 0.0) (float 0.01)))
    (is (not (nearly? (float 0.0) (float 1e-40) (float 0.000001))))
    (is (not (nearly? (float 1e-40) (float 0.0) (float 0.000001))))
    (is      (nearly? (float 0.0) (float -1e-40) (float 0.1)))
    (is      (nearly? (float -1e-40) (float 0.0) (float 0.1)))
    (is (not (nearly? (float 0.0) (float -1e-40) (float 0.00000001))))
    (is (not (nearly? (float -1e-40) (float 0.0) (float 0.00000001))))))

#+end_src

** math-utils
#+begin_src clojure :tangle ./src/forge/proto.cljc
(defn to-deg
  [rad]
  (* rad (/ 180 Math/PI)))

(defn to-rad
  [deg]
  (* deg (/ Math/PI 180)))

(defn round
  [num places]
  (let [d (Math/pow 10 places)]
    (/ (Math/round (* num d)) d)))

(defn sign
  "returns -1 if x is less than 0, 0 if x is 0 and 1 if x is greater"
  [x]
  (cond
    (or (= 0.0 x) (= 0 x)) 0
    (< 0 x) 1
    (> 0 x) -1))

(defn average
  [& numbers]
  (let [n (count numbers)]
    (/ (apply + numbers) n)))

(defn sq
  [x]
  (* x x))

(defn clamp
  "clamps a value between lower bound and upper bound"
  [x lb ub]
  (cond
    (< x lb) lb
    (> x ub) ub
    :else x))

(defn add-z
  [pt]
  (conj (vec pt) 0))

#+end_src

** vector-arithmetic
#+begin_src clojure :tangle ./src/forge/proto.cljc
(def v+ (partial mapv +))
(def v- (partial mapv -))
(def v* (partial mapv *))
#+end_src

** list-manipulations
#+begin_src clojure :tangle ./src/forge/proto.cljc
(defn vec-diff
  "returns the collection difference of two vectors"
  [v1 v2]
  (vec (into #{} (concat v1 v2))))

(defn vec-inner-pop
  "pop the item at index from the collection"
  [coll ind]
  (into [] (conj (subvec coll 0 ind) (subvec coll (inc ind)))))

(defn push-new
  "push item onto vector if it doesn't already exist."
  [v n]
  (if (some #{n} v)
    v
    (conj v n)))

(defn concat-new
  "concat two vectors together pushing only unique items."
  [a b]
  (reduce push-new a b)) 

(defn position
  "returns index of first match to item in the src vector. Otherwise nil"
  [src item]
  (let [res (.indexOf src item)]
    (if (>= res 0)
      res
      nil)))

(defn link
  "Swap an item for it's index in a different list"
  [src item]
  (let [type-k (first item)
        vals (rest item)]
    (vec (conj (map #(position src %) vals) type-k))))

(defn unlink
  "Swap an item's idx for it's value in a different list"
  [src item]
  (let [type-k (first item)
        indices (rest item)]
    (vec (conj (map #((vec src) %) indices) type-k))))

#+end_src

** geometry-calculations
#+begin_src clojure :tangle ./src/forge/proto.cljc
(defn slope-2d
  [a b]
  (let [[x1 y1] a
        [x2 y2] b]
    (/ (- y2 y1) (- x2 x1))))

(defn perpendicular-2d
  [[x y]]
  [(- y) x])

(defn determinant-2d
  [a b]
  (- (* (first a) (second b))
     (* (second a) (first b))))

(defn dot*
  "calculates the dot product of two vectors"
  [a b]
  (reduce + (map * a b)))

(defn cross*
  "calculates cross product of two 3d-vectors"
  [a b]
  (let [[a1 a2 a3] a
        [b1 b2 b3] b
        i (- (* a2 b3) (* a3 b2))
        j (- (* a3 b1) (* a1 b3))
        k (- (* a1 b2) (* a2 b1))]
    [i j k]))

(defn distance
  "compute distance between two points"
  [a b]
  (let [v (v- b a)
        v2 (reduce + (v* v v))]
    (Math/sqrt v2)))

(defn normalize
  "find the unit vector of a given vector"
  [v]
  (let [m (Math/sqrt (reduce + (v* v v)))]
    (mapv / v (repeat m))))

(defn on-line?
  "determine if a point is on a capped line"
  [pt line]
  (let [[a b] line
        ap (v- a pt)
        bp (v- b pt)]
    (if (or (all-nearly? pt a) 
            (all-nearly? pt b))
      true
      (let [na (normalize ap)
            nb (normalize bp)]
        (and 
         (all-nearly? (cross* ap bp) [0 0 0]) 
         (not (all-nearly? na nb)))))))

(defn on-line-inf?
  "determine if a point is on an infinitely extending line"
  [pt line]
  (let [[a b] line
        ap (mapv - a pt)
        bp (mapv - b pt)]
    (all-nearly? (cross* ap bp) [0 0 0])))

#+end_src

** 3-points-algorithms
#+begin_src clojure :tangle ./src/forge/proto.cljc
(defn normal
  "find normal vector of plane given 3 points"
  [a b c]
  (let [ab (mapv - a b)
        ac (mapv - a c)]
    (if (on-line? c [a b]) nil (cross* ab ac))))

(defn on-plane?
  "determine if a point is on a plane"
  [pt plane]
  (let [a (map - pt (first plane))
        n (normal (first plane) (second plane) (nth plane 2))]
    (nearly? (Math/abs (dot* a n)) 0)))

(defn plane-triple
  "gets a list of 3 points on a plane from a list of points"
  [pts]
  (if (< (count pts) 3) nil
    (let [[a b c] pts]
      (if (on-line? c [a b]) 
        (plane-triple (vec-inner-pop pts 2))
        [a b c]))))

(defn planar?
  "checks if all points in a list share a plane"
  [pts]
  (cond
    (< (count pts) 3) false
    (= (count pts) 3) (let [a (first pts)
                            b (second pts)
                            c (nth pts 2)]
                        (if (on-line? c [a b]) false true))
    :else (let [plane (plane-triple pts)
                chk-pts (vec-diff plane pts)]
            (every? #(= % true) (mapv #(on-plane? % plane) chk-pts)))))

(defn radius-from-pts
  "compute the radius of an arc defined by 3 points"
  [p1 p2 p3]
  (when-not (on-line? p1 [p2 p3])
    (let [a (distance p3 p2)
          b (distance p3 p1)
          c (distance p2 p1)
          s (/ (+ a b c) 2)
          sa ( - s a)
          sb ( - s b)
          sc ( - s c)
          rt (Math/sqrt (* s sa sb sc))
          R (/ (/ (* a b c) 4) rt)]
      R)))

;; https://math.stackexchange.com/questions/361412/finding-the-angle-between-three-points
(defn angle-from-pts
  [p1 p2 p3]
  (let [v1 (v- p2 p1)
        v2 (v- p2 p3)
        l1 (distance p1 p2)
        l2 (distance p3 p2)
        n (dot* v1 v2)
        d (Math/abs (* l1 l2))]
    (when (not (= 0.0 (float d)))
      (to-deg (Math/acos (/ n d))))))

;; https://math.stackexchange.com/a/1743505
(defn center-from-pts
  "compute the center point of an arc through 3 points"
  [p1 p2 p3]
  (when-not (on-line? p1 [p2 p3])
    (let [u1 (mapv - p2 p1)
          u2 (mapv - p3 p1)
          w1 (cross* (mapv - p3 p1) u1)
          u (normalize u1)
          w (normalize w1)
          v (cross* w u)
          [bx by] [(dot* u1 u) 0]
          [cx cy] [(dot* u2 u) (dot* u2 v)]
          h (/ (+ (sq (- cx (/ bx 2))) (sq cy) (- 0 (sq (/ bx 2)))) 
               (* 2 cy))]
      (v+ p1 
          (v* (repeat (/ bx 2)) u) 
          (v* (repeat h) v)))))

#+end_src

** area
#+begin_src clojure :tangle ./src/forge/proto.cljc
(defn triangle-area
  "compute the area of a triangle defined by three points"
  [a b c]
  ;; use Heron's formula
  (let [la (distance b c)
        lb (distance a c)
        lc (distance a b)
        s (/ (+ la lb lc) 2)]
    (Math/sqrt (* s (- s la) (- s lb) (- s lc)))))

(defn polygon-area
  [pts]
  (let [tris (:triangles (delaunay/triangulate pts))]
    (->> pts
         (delaunay/triangulate)
         (:triangles)
         (map #(apply triangle-area %))
         (reduce +))))

#+end_src

** bounding-box
#+begin_src clojure :tangle ./src/forge/proto.cljc
(defn bb-corners-2d
  [pts]
  (let [xs (map first pts)
        ys (map last pts)
        xmax (apply max xs)
        ymax (apply max ys)
        xmin (apply min xs)
        ymin (apply min ys)]
    [[xmin ymin]
     [xmax ymax]]))

(defn bb-center-2d
  [pts]
  (let [xs (map first pts)
        ys (map last pts)
        xmax (apply max xs)
        ymax (apply max ys)
        xmin (apply min xs)
        ymin (apply min ys)]
    [(+ (/ (- xmax xmin) 2.0) xmin)
     (+ (/ (- ymax ymin) 2.0) ymin)]))

(defn midpoint
  [pts]
  (let [axes (count (first pts))
        splits (for [axis (range 0 axes)]
                 (map #(nth % axis) pts))]
    (mapv #(apply average %) splits)))

(defn bounding-box-corners
  [shape]
  (let [xs (map #(nth % 0)
                (sort-by #(nth % 0) (:vertices shape)))
        ys (map #(nth % 1)
                (sort-by #(nth % 1) (:vertices shape)))
        zs (map #(nth % 2)
                (sort-by #(nth % 2) (:vertices shape)))]
    [[(first xs) (first ys) (first zs)]
     [(last xs) (last ys) (last zs)]]))

(declare polygon)
(declare extrude)
(defn bounding-volume-proto
  [shape]
  (let [[a z] (bounding-box-corners shape)
        b [(first z) (second a) (last a)]
        c [(first z) (second z) (last a)]
        d [(first a) (second z) (last a)]
        s1 (polygon [a b c d])
        h (Math/abs (- (last z) (last a)))]
    (extrude s1 h)))

#+end_src

** estimators
Some properties are needed during calculations. The simplest way to ge them is with estimators. These should improve over time, but for now can 'brute force' things a bit.

#+begin_src clojure :tangle ./src/forge/proto.cljc
(defn estimate-path-length
  [path [t1 t2] step]
  (let [samples (range t1 (+ t2 step) step)
        pts (partition 2 1 (map path samples))]
    (reduce + (map (partial apply distance) pts))))

;; this breaks somewhat often. Consider a case where the match is
;; a very tiny difference in parameter space. It's easy to pass over it
;; there's surely a more refined approach, perhaps a combination of several algorithms?
(defn close?
  [p1 p2]
  (let [[x1 y1 z1] p1
        [x2 y2 z2] p2]
    (and (nearly? (+ 1 (Math/abs (- x1 x2))) 1.0)
         (nearly? (+ 1 (Math/abs (- y1 y2))) 1.0)
         (nearly? (+ 1 (Math/abs (- z1 z2))) 1.0))))

(defn estimate-parameter
  [f pt step]
  (let [[x y z] pt
        samples (into [] (range 0 (+ 1 step) step))
        pts (mapv f samples)
        close? (partial close? pt)]
    (get samples
         (count (take-while #(not (= (first (filter close? pts)) %)) pts)))))

#+end_src

** brep-remapper
#+begin_src clojure :tangle ./src/forge/proto.cljc
(defn remap-within
  [f [start end] x]
  (when (and (>= x start) (< x end))
    (let [step (- end start)
          t (/ (- x start) step)]
      (f t))))

#+end_src

** frep-voxel-grid-proto
#+begin_src clojure :tangle ./src/forge/proto.cljc
(defn frep-voxel-grid-proto
  [[minc maxc] [xs ys zs]]
  (for [x (range (first minc) (first maxc) xs)
        y (range (second minc) (second maxc) ys)
        z (range (last minc) (last maxc) zs)]
    [x y z]))

#+end_src
* 2d-algorithms
** delaunay
 This is (for now) a copy from:

 https://github.com/trystan/delaunay-triangulation

 I have to change this to work on 3D points. It currently drops any Z values.

 #+BEGIN_SRC clojure :tangle ./src/forge/delaunay.cljc
 (ns forge.delaunay
   (:require [clojure.set]))

 ;; move these to geom ns?
 (def abs #?(:clj #(Math/abs %)
             :cljs #(js/Math.abs %)))

 (def pow #?(:clj #(Math/pow %1 %2)
             :cljs #(Math/pow %1 %2)))


 (defn rand-int-pt
   ([n]
    (rand-int-pt n n))

   ([nx ny]
    [(rand-int nx) (rand-int ny)]))

 (defn random-points
   ([n]
    (random-points n n))

   ([nx ny]
    (repeatedly #(rand-int-pt nx ny))))

 (defn grid-points
   [cell-x cell-y n-xcells n-ycells]
   (for [nx (range n-xcells)
         ny (range n-ycells)]
     [(* cell-x nx) (* cell-y ny)]))

 ;; https://gist.github.com/mutoo/5617691
 (defn circumscribe-triangle [[[ax ay] [bx by] [cx cy]]]
   (let [A (- bx ax)
         B (- by ay)
         C (- cx ax)
         D (- cy ay)
         E (+ (* A (+ ax bx)) (* B (+ ay by)))
         F (+ (* C (+ ax cx)) (* D (+ ay cy)))
         G (* 2 (- (* A (- cy by)) (* B (- cx bx))))]
     (when (> (abs G) 0.000001)
       (let [cx (/ (- (* D E) (* B F)) G)
             cy (/ (- (* A F) (* C E)) G)
             dx (- cx ax)
             dy (- cy ay)
             r  (+ (pow dx 2) (pow dy 2))]
         {:x cx :y cy :radius-squared r}))))

 (defn edges [[p1 p2 p3]] [[p1 p2] [p2 p3] [p3 p1]])

 (defn contains-point? [{:keys [x y radius-squared]} [px py]]
   (let [distance-squared (+ (pow (- x px) 2) (pow (- y py) 2))]
     (< distance-squared radius-squared)))

 (defn outer-edges [triangles]
   (let [all-edges    (mapcat edges triangles)
         matches      (fn [edge] (filter #{edge (reverse edge)} all-edges))
         appears-once (fn [edge] (= (count (matches edge)) 1))]
     (filter appears-once all-edges)))

 (defn make-new-triangles [containers point]
   (->> containers
        outer-edges
        (map (fn [[p1 p2]] [p1 p2 point]))
        set))

 (defn add-point-to-triangles [triangles point]
   (let [containers    (filter #(contains-point? (circumscribe-triangle %) point) triangles)
         new-triangles (make-new-triangles containers point)]
     (clojure.set/union (clojure.set/difference triangles containers) new-triangles)))

 (defn bounds [points]
   (let [minx (->> points (map first) (apply min) (+ -1000))
         maxx (->> points (map first) (apply max) (+ 1000))
         miny (->> points (map second) (apply min) (+ -1000))
         maxy (->> points (map second) (apply max) (+ 1000))]
     [[minx maxy] [maxx maxy] [minx miny] [maxx miny]]))

 ;; http://paulbourke.net/papers/triangulate/
 (defn triangulate [points]
   (let [points (map (fn [[x y]] [(float x) (float y)]) points)
         [tl tr bl br] (bounds points)
         initial #{[tl tr bl] [bl tr br]}
         with-bounds (reduce add-point-to-triangles initial points)
         triangles (remove #(some #{tl tr bl br} %) with-bounds)]
     {:points points
      :triangles triangles
      :edges (distinct (mapcat edges triangles))}))

 #+END_SRC
** polygon-intersection
HUGE NOTE: The nearly function needs serious checking. It will be necessary to work very well because I need 'close enough' predicates often when working with geometry checks.

#+begin_src clojure :tangle ./src/forge/proto.cljc
#_(defn fake-on-line?
  "determine if a point is on a capped line"
  [pt line]
  (let [[a b] line
        ap (v- a pt)
        bp (v- b pt)]
    (let [na (normalize ap)
          nb (normalize bp)]
      (cross* na nb) #_(and 
       (all-nearly? (cross* ap bp) [0 0 0]) 
       (not (all-nearly? na nb))))))

(defn line-intersection
  [[a b] [c d]]
  (let [[ax ay] a
        [bx by] b
        [cx cy] c
        [dx dy] d
        xdiff [(- ax bx) (- cx dx)]
        ydiff [(- ay by) (- cy dy)]
        div (determinant-2d xdiff ydiff)]
    (when (not (zeroish? (Math/abs div))) 
      (let [d [(determinant-2d a b) (determinant-2d c d)]
            x (/ (determinant-2d d xdiff) div)
            y (/ (determinant-2d d ydiff) div)]
        [x y]))))

(defn line-segment-intersection
  [[a b] [c d]]
  (let [pt (line-intersection [a b] [c d])]
    (when (and pt
               (on-line? (add-z pt) (mapv add-z [a b]))
               (on-line? (add-z pt) (mapv add-z [c d])))
      pt)))

(defn identical-polygons?
  [pga pgb]
  (= (into #{} pga)
     (into #{} pgb)))

(declare close-path)
(defn polygon-intersection
  [pga pgb]
  (when (not (identical-polygons? pga pgb))
    (let [lines-a (partition 2 1 (close-path pga))
          lines-b (partition 2 1 (close-path pgb))
          s (for [la lines-a
                  lb lines-b]
              (line-segment-intersection la lb))]
      (->> s
           (filter (complement nil?))
           (into #{})
           (vec)))))

#+end_src

continue the algorithm...

 - point inside?
   - line to right... count intersections even = outside, odd = inside, 0 = outside (but only works for convex polygons)
     - need to consider parallel lines and vertices changing the intersection count (for concanve polygon)

#+begin_src clojure :tangle ./src/forge/proto.cljc
(defn pt-inside-convex?
  [pts pt]
  (let [m (mapv float (midpoint pts))
        xs (polygon-intersection pts [m pt])]
    ;; pt inside when count intersection = 0
    ;; pt inside when intersection = pt
    (or (= 0 (count xs))
        (all-nearly? (first xs) pt))))

(defn pt-inside-convex-strict?
  [pts pt]
  (let [m (mapv float (midpoint pts))
        xs (polygon-intersection pts [m pt])]
    (all-nearly? (first xs) pt)))

(defn quadrant
  [x y]
  (let [mask [(pos? x) (pos? y)]]
    (cond (= mask [ true  true]) 1
          (= mask [false  true]) 2
          (= mask [false false]) 3
          (= mask [ true false]) 4)))
#+end_src

The angle-from-pts2 implementation has an issue with ambiguity of quadrant. take [1 0] and [0 1] (and [-1 0] and [0 -1]). The zero isn't positive or negative so causes incorrect quadrant classification which breaks the conditional branch logic.

#+begin_src clojure :tangle ./src/forge/proto.cljc
(defn angle-from-pts2 
  "Angle following RHR from p3p2 to p1p2"
  [p1 p2 p3]
  (let [[ax ay] (v- p1 p2)
        [bx by] (v- p3 p2)
        qa (quadrant ax ay)
        qb (quadrant bx by)
        theta-a (to-deg (Math/atan2 ay ax))
        theta-b (to-deg (Math/atan2 by bx))]
    (cond 
      ;; la and lb both in same quadrant, always < 90deg
      (= qa qb) (- theta-b theta-a)
      ;; qa greater than qb and 2 away [4 2] or [3 1]
      (= 2 (- qa qb)) (- 360 theta-b theta-a)
      ;; qb greater than qa and 2 away [2 4] or [1 3]
      (= 2 (- qb qa)) (- theta-b theta-a)
      (or
       (= [qa qb] [2 1])
       (= [qa qb] [4 3])) (- 180 (Math/abs theta-b) (Math/abs theta-a))
      (or
       (= [qa qb] [1 2])
       (= [qa qb] [3 4])) (+ 180 (Math/abs theta-b) (Math/abs theta-a))
      (or
       (= [qa qb] [3 2])
       (= [qa qb] [1 4])) (+ (Math/abs theta-b) (Math/abs theta-a))
      (or
       (= [qa qb] [2 3])
       (= [qa qb] [4 1])) (+ 180 (Math/abs theta-b) (Math/abs theta-a)))))

(defn acute?
  [p1 p2 p3]
  (< (angle-from-pts2 p1 p2 p3) 180.0))      

(defn line?
  [[a b c]]
  (on-line-inf? (add-z a) (mapv add-z [b c])))

(defn contains-value?
  [coll val]
  (when (some #{val} coll) true))

(defn vecdiff
  [va vb]
  (into [] (filter (complement (partial contains-value? vb)) va))) 

(defn simplify-segments
  [pts]
  (let [triples (partition 3 1 (take (+ 2 (count pts)) (cycle pts)))
        removable (map second (filter line? triples))]
    (vecdiff pts removable)))

;; can I use reduce instead?
;; other recursion scheme?
#+end_src

This clip-ears algo doesn't work in all cases. For example, the shape:

[2 2] [12 2] [5 7] [12 12] [2 12]

incorrectly clips to these 3 triangles:

- [2 2] [12 2] [5 7] (this is ok)
- [2 2] [5 7] [12 12] (INVALID, line [2 2] [12 12] is outside original poly)
- [2 2] [12 12] [2 12] (INVALID, line [2 2] [2 12] is outisde original poly)

This is related to the fact that I don't check for angles at all.

Idea is that I can take any point to clip as long as its angle is less than 180 degrees. If it is greater, try next point, etc. Eventually, you can clip all ears away as remaining lines will eventually be less than 180 degrees.

My angles-from-pts fn needs to be changed because it will only report the smaller angle between lines. I need the angle from line 1 to line 2 even if it is > 180, otherwise I can't detect incorrect triangles.

#+begin_src clojure :tangle ./src/forge/proto.cljc
(defn clip-ears
  ([pts]
   (clip-ears pts []))
  
  ([pts acc]
   (let [spts (simplify-segments pts)
         tris (->> (cycle spts)
                   (partition 3 1)
                   (take (count spts))
                   (filter #(apply acute? %))
                   (mapv #(into [] %)))
         tri (first (for [tri tris]
                      (let [xpts (remove (into #{} tri) (into #{} spts))
                            clear (= 0 (count (filter #(pt-inside-convex? tri %) xpts)))]
                        (when clear tri))))
         npts (if tri 
                (->> spts
                     (filter (complement #{(second tri)}))
                     (into []))
                (->> spts
                     (cycle)
                     (drop 1)
                     (take (count spts))
                     (into [])))
         acc (if tri (conj acc tri) acc)]
     (if (> (count npts) 2)
       (recur npts acc)
       acc))))

(defn pt-inside?
  [pts pt]
  (let [tris (clip-ears pts)]
    (->> tris
         (map #(pt-inside-convex? % pt))
         (filter true?)
         (empty?)
         (not))))

#+end_src

- get intersectin points of polygons
- if zero, done if one, done, else, continue
- remove pgb points that are inside pga
- remove pga points that are inside pgb
- trim pga lines to intersectin points
- trim pgb lines to intersection points
- combine pga pts, intersectin points, and pgb points
  - order matters... not sure how to preserve that yet.

#+begin_src clojure :tangle ./src/forge/proto.cljc
(defn trim
  "Trim line a using line b."
  [la lb]
  (let [x (line-segment-intersection la lb)]
    (when x
      [[(first la) x]
       [x (second la)]])))

(defn trim-at-pt
  [[a b] pt]
  (when (and
         (not= a pt)
         (not= b pt)
         (on-line? (add-z (mapv float pt)) (mapv add-z [a b])))
    [[a pt]
     [pt b]]))

(defn trim-at-pts
  [[a b] pts]
  (let [pts (filter #(on-line? % (mapv add-z [a b])) (mapv add-z pts))]
    (when (first pts)
      (->> pts
           (sort-by (partial distance a))
           (mapv #(into [] (drop-last %)))
           (concat [a])
           (apply vector)
           (#(conj % b))
           (partition 2 1)
           (mapv vec)))))

#+end_src

- instead of creating lists of points, create lists of line segments that make each polygon

- for segments with intersections, just trim them and only keep the trimmed parts

- flatten the list of all these segments together

- then, remove all segments that lie inside either of the originals

- re-order the line list by 'chaining' (reverse of (partition 2 1))...

- map drop-last over list of lines... should give a correct ordering of pts

#+begin_src clojure :tangle ./src/forge/proto.cljc
(defn polygon->lines 
  [pg]
  (->> pg
       (cycle)
       (take (inc (count pg)))
       (partition 2 1)))

(defn endpoint?
  [l pt]
  (or (= (first l) pt)
      (= (second l) pt)))

(defn on-perimeter?
  [pg pt]
  (let [pt (add-z pt)
        pg (mapv add-z pg)
        lines (polygon->lines pg)]
    (> (count (filter (partial on-line? pt) lines)) 0)))

(defn order-lines
  ([lines]
   (let [start (first (sort-by (comp second first) lines))]
     (order-lines lines start [start])))

  ([lines [_ b] sorted]
   (let [next (first (filter #(= b (first %)) lines))]
     (if (= (count lines) (count sorted))
       (mapv first sorted)
       (recur lines next (conj sorted next))))))
#+end_src

*** polygon-union
#+begin_src clojure :tangle ./src/forge/proto.cljc
(defn polygon-union
  [pga pgb]
  (let [xs (polygon-intersection pga pgb)
        ;; trim lines at intersection points
        ls (apply concat 
                  (for [l (mapv vec (mapcat polygon->lines [pga pgb]))]
                    (let [trims (->> #_(map #(trim-at-pts l [%]) xs)
                                     [(trim-at-pts l xs)]
                                     (filter #(not (nil? %))))]
                      (if (> (count trims) 0)
                        (apply concat trims)
                        [l]))))
        ;; remove degenerate lines (= pta ptb)
        ls (filter #(not (= (first %) (second %))) ls)
        ;; get lines that are not in polygon a
        a (filter #(not (pt-inside? pga (midpoint %))) ls)
        ;; get lines that are not in polygon b
        b (filter #(not (pt-inside? pgb (midpoint %))) ls)
        ;; get lines with midpoints on both perimeters
        c (filter #(and (on-perimeter? pga (midpoint %))
                        (on-perimeter? pgb (midpoint %))) ls)]
    (->> (concat a b c)
         (filter (complement nil?))
         (into #{})
         (order-lines))))

#+end_src

*** polygon-difference
#+begin_src clojure :tangle ./src/forge/proto.cljc
(defn polygon-difference
  "Polygon B Cuts Polygon A"
  [pga pgb]
  (let [xs (polygon-intersection pga pgb)
        ;; trim lines at intersection points
        ls (apply concat 
                  (for [l (mapv vec (mapcat polygon->lines [pga pgb]))]
                    (let [trims (->> #_(map #(trim-at-pts l [%]) xs)
                                     [(trim-at-pts l xs)]
                                     (filter #(not (nil? %))))]
                      (if (> (count trims) 0)
                        (apply concat trims)
                        [l]))))
        ;; remove degenerate lines (= pta ptb)
        ls (filter #(not (= (first %) (second %))) ls)
        ;; get lines that are in polygon a
        a (filter #(pt-inside? pga (midpoint %)) ls)
        ;; get lines that are in polygon b
        b (filter #(pt-inside? pgb (midpoint %)) ls)
        ;; get lines with midpoints on both perimeters
        c (filter #(and (on-perimeter? pga (midpoint %))
                        (on-perimeter? pgb (midpoint %))) ls)]
    (->> (concat a b c)
         (filter (complement nil?))
         (into #{})
         (order-lines))))

#+end_src

- there are cases where a segment has >1 intersection point along itself. Currently, it gets 'passed over' once a single trim has occurred on it. Technically, need some sort of iteration or recursion over this so that new trimmed segments are also checked for trims with other intersections

- perform trim on list of line segments. Iterate. When prev.list = latest list, stop iteration (this means all trims are complete)


- maikerusan123 suggests create a fn that will trim a line into any N segments given any N pts along it (basically, upgrade trim-at-pt to trim-at-pts)

** offset
#+begin_src clojure :tangle ./src/forge/proto.cljc
(defn offset-edge
  [[a b] d]
  (let [p (perpendicular-2d (v- b a))
        pd (v* (normalize p) (repeat (- d)))
        xa (v+ a pd)
        xb (v+ b pd)]
    [xa xb]))

(defn cycle-pairs
  [pts]
  (let [n (count pts)]
    (vec (take n (partition 2 1 (cycle pts))))))

(defn every-other
  [v]
  (let [n (count v)]
    (map #(get v %) (filter even? (range n)))))

(defn wrap-list-once
  [s]
  (conj (drop-last s) (last s)))

(defn offset
  [pts d]
  (let [edges (cycle-pairs pts)
        opts (mapcat #(offset-edge % d) edges)
        oedges (every-other (cycle-pairs opts))
        edge-pairs (cycle-pairs oedges)]
    (wrap-list-once (map #(apply line-intersection %) edge-pairs))))

 #+end_src
* forge-model
** notes
This is a section that I think should move to the forge library. It's here only for prototyping at the moment.

The model will be consistent such that any operation done on it will produce a model as output. This lets you chain any set of operations together to produce a model. You can then also create renderers as separate applications.

Any object consists of:

- sdf      (FREP fn)        1 or more
- vertices (3-tuples)       1 or more
- curves   (parametric fns) 0 or more
- surfaces (parametric fns) 0 or more
- history  (sequence of operation fns/args) 1 or more

primitives (fns that generate the initial structure):

- vertex
- line
- polyline
- curve

- circle
- rectangle
- polygon

- extrude
- revolve

- sphere
- box
- cylinder
- polyhedron
- surface

Necessary operations:

- translate
- rotate
- scale

- union
- difference
- intersection

Thoughts related to 'sketches'

- might be useful as a grouping mechanism for all 2D things.
- could just have all 2D related operations implicitly work on XY plane... and you can use all 3D operations normally
- you can def a list of 2D things and just reduce them with union to create an object that you can then extrude, revolve, display, whatever. So, for now, there is not explicit structure for sketches. They are just user convention at most.

** model-map
Not sure how best to handle reference elements like center points, midlines, control points, etc.

Perhaps they shouldn't be my first concern at all, but I feel like they are going to be necessary for visual clarity, debugging, and control in UI environments.

It might be better to 'tag' elements as :ref and just place them appropriately. Eg. a Centerpoint is just a tagged version of a vertex and so ends up in the vertices list.

#+BEGIN_SRC clojure :tangle ./src/forge/proto.cljc
(def sample-model
  {:history "the quoted most recent fn call with eval'd args."
   :frep "the single FREP function which produces the shape"
   :ref "list of reference elements like center points and lines"
   :vertices "list of vertices, excluding ref elements"
   :curves "list of parametric curve functions"
   :surfaces "list of parametric surface functions"
   :volumes "list of volume functions"})

#+END_SRC

** operations
*** unions
**** frep
#+BEGIN_SRC clojure :tangle ./src/forge/proto.cljc
(defn frep-union [f g]
  (fn [pt]
    (let [a (f pt)
          b (g pt)]
      (min a b))))

#+END_SRC

**** naive-brep
#+BEGIN_SRC clojure :tangle ./src/forge/proto.cljc
(defn brep-curve-union
  [& curves]
  (let [n (count curves)
        intervals (map #(vector % (inc %)) (range n))]
    (fn [t]
      (let [t (* n t)]
        (cond
          (= (float t) 0.0) ((first curves) 0)
          (= (float t) (float n)) ((last curves) 1)
          :else
          (first
           (filter 
            some?
            (map #(remap-within %1 %2 t) curves intervals))))))))

(defn brep-surface-union
  [& surfaces]
  (let [n (count surfaces)
        intervals (map #(vector % (inc %)) (range n))]
    (fn [u v]
      (let [partial-surfaces (map #(partial % u) surfaces)]
        ((apply brep-curve-union partial-surfaces) v)))))

(defn union
  [shape1 shape2]
  (let [s1 (dissoc shape1 :frep :history)
        s2 (dissoc shape2 :frep :history)]
    (merge
     (merge-with (comp vec concat) s1 s2)
     {:frep (frep-union (:frep shape1) (:frep shape2))
      :history [`(union ~shape1 ~shape2)]})))

#+END_SRC

**** brep
Let's consider first a union of 2 polygons known to be on the same plane (assume in XY plane). We need to:

- find all intersection points between the polygons
- remove all points from p1 that are inside p2
- remove all points from p2 that are inside (original p1)
- remaining points are concatenated, but order must be preserved around the new shape


#+BEGIN_SRC clojure :tangle ./src/forge/proto.cljc


#+END_SRC

*** difference
#+BEGIN_SRC clojure :tangle ./src/forge/proto.cljc
(defn frep-difference [f g]
  (fn [pt]
    (let [a (f pt)
          b (* -1 (g pt))]
      (max a b))))

#+END_SRC

*** intersection
#+BEGIN_SRC clojure :tangle ./src/forge/proto.cljc
(defn frep-intersection [f g]
  (fn [pt]
    (let [a (f pt)
          b (g pt)]
      (max a b))))

#+END_SRC

*** transformations
**** translate
#+BEGIN_SRC clojure :tangle ./src/forge/proto.cljc
(defn frep-translate
  [f pos]
  (fn [pt]
    (f (v+ pt pos))))

(defn brep-translate
  [f pos]
  (comp #(v+ pos %) f))

(defn translate
  [shape pos]
  (merge
   shape
   {:history (conj (:history shape) `(translate ~shape ~pos))
    :frep (frep-translate (:frep shape) pos)
    :vertices (mapv (partial v+ pos) (:vertices shape))
    :curves (mapv #(brep-translate % pos) (:curves shape))
    :surfaces (mapv #(brep-translate % pos) (:surfaces shape))
    :volumes (mapv #(brep-translate % pos) (:volumes shape))}))

#+END_SRC

**** rotate
#+BEGIN_SRC clojure :tangle ./src/forge/proto.cljc
(defn sin-cos-pair [theta]
  [(Math/sin (to-rad theta)) (Math/cos (to-rad theta))])

(defn rot-pt-2d
  [[x y] theta]
  (let [[s-t c-t] (sin-cos-pair theta)]
    [(- (* x c-t) (* y s-t))
     (+ (* y c-t) (* x s-t))]))

;; this rotates a point around [0,0,0]
(defn rot-pt
  [[x y z] axis theta]
  (cond
    (= axis :x) (into [x] (rot-pt-2d [y z] theta))
    (= axis :y) (apply #(into [] [%2 y %1]) (rot-pt-2d [z x] theta))
    (= axis :z) (into (rot-pt-2d [x y] theta) [z])))

(defn rotate-point
  [pt [ax ay az]]
  (let [pt (if (< (count pt) 3)
             (conj pt 0)
             pt)]
    (-> pt
        (rot-pt :z az)
        (rot-pt :y ay)
        (rot-pt :x ax))))

(defn brep-rotate
  [f angles]
  (comp #(rotate-point % angles) f))

(defn frep-rotate
  [f angles]
  (fn [pt]
    (f (rotate-point pt angles))))

(defn rotate
  [shape angles]
  (merge
   shape
   {:history (conj (:history shape) `(rotate ~shape ~angles))
    :frep (frep-rotate (:frep shape) angles)
    :vertices (mapv #(rotate-point % angles) (:vertices shape))
    :curves (mapv #(brep-rotate % angles) (:curves shape))
    :surfaces (mapv #(brep-rotate % angles) (:surfaces shape))
    :volumes (mapv #(brep-rotate % angles) (:volumes shape))}))

#+END_SRC

**** scale
#+BEGIN_SRC clojure :tangle ./src/forge/proto.cljc
(defn frep-scale
  [f scales]
  (fn [pt]
    (f (v* pt scales))))

(defn brep-scale
  [f scales]
  (comp #(v* scales %) f))

(defn scale
  [shape scales]
  (merge
   shape
   {:history (conj (:history shape) `(scale ~shape ~scales))
    :frep (frep-scale (:frep shape) scales)
    :vertices (mapv (partial v* scales) (:vertices shape))
    :curves (mapv #(brep-scale % scales) (:curves shape))
    :surfaces (mapv #(brep-scale % scales) (:surfaces shape))
    :volumes (mapv #(brep-scale % scales) (:volumes shape))}))

#+END_SRC

*** extrude
#+BEGIN_SRC clojure :tangle ./src/forge/proto.cljc
(defn frep-extrude
  [f h]
  (fn [pt]
    (let [d (f (drop-last pt))
          w [d (- (Math/abs (last pt)) h)]]
      (+ (min (apply max w) 0)
         (distance [0 0]
                   [(max (first w) 0) (max (second w) 0)])))))

(declare brep-line)
(defn brep-curve-extrude
  [c h]
  (fn [u v]
    (let [c2 (brep-line (c u) (v+ (c u) [0 0 h]))]
      (c2 v))))

(defn brep-surface-extrude
  [s h]
  (fn [u v w]
    (let [c1 (brep-line (s u v) (v+ (s u v) [0 0 h]))]
      c1 v)))

(defn extrude
  [shape h]
  (let [vertices (mapv (partial v+ [0 0 h]) (:vertices shape))]
    (merge
     (merge-with
      (comp vec concat)
      shape
      {:vertices vertices
       :curves (concat
                (mapv #(brep-translate % [0 0 h]) (:curves shape))
                (mapv #(brep-line %1 %2) (:vertices shape) vertices))
       :surfaces (concat
                  [(brep-translate (first (:surfaces shape)) [0 0 h])]
                  (mapv #(brep-curve-extrude % h) (:curves shape)))
       :volumes [(brep-surface-extrude (first (:surfaces shape)) h)]})
     {:history `(extrude ~shape ~h)
      :frep (frep-extrude (:frep shape) h)})))

#+END_SRC

*** sweep
#+BEGIN_SRC clojure :tangle ./src/forge/proto.cljc
(defn brep-curve-straight-sweep
  [c1 c2]
  (fn [u v]
    (v+ (c1 u) (c2 v))))

(defn brep-surface-straight-sweep
  [s c]
  (fn [u v w]
    (v+ (s u v) (c w))))

#+END_SRC

*** revolve
#+BEGIN_SRC clojure :tangle ./src/forge/proto.cljc
(defn frep-revolve
  [f r]
  (fn [pt]
    (let [q [(- (distance [0 0] [(first pt) (last pt)]) r) 
             (second pt)]]
      (f q))))

#+END_SRC

** primitives
*** vertex
#+BEGIN_SRC clojure :tangle ./src/forge/proto.cljc
(defn vertex
  [[x y z]]
  {:history `(vertex [~x ~y ~z])
   :frep (fn [pt]
           (distance [x y z] pt))
   :vertices [[x y z]]})

#+END_SRC

*** line
#+BEGIN_SRC clojure :tangle ./src/forge/proto.cljc
(defn frep-line
  [a b]
  (fn [pt]
    (let [pa (map - pt a)
          ba (map - b a)
          h (clamp (/ (dot* pa ba) (dot* ba ba)) 0 1)]
      (distance (map - pa (map * ba (repeat h))) [0 0 0]))))

(defn brep-line
  [a b]
  (fn [t]
    (cond
      (= t :tag) :line
      (= (float t) 0.0) a
      (= (float t) 1.0) b
      :else
      (v+ a (v* (v- b a) (repeat t))))))

(defn line
  [a b]
  {:history `(line ~a ~b)
   :frep (frep-line a b)
   :vertices [a b]
   :curves [(brep-line a b)]})

(defn brep-polyline
  [pts]
  (let [step (/ 1.0 (dec (count pts)))
        intervals (partition 2 1 (range 0 (+ 1 step) step))
        lines (map (partial apply brep-line) (partition 2 1 pts))]
    (fn [t]
      (cond 
        (= t :tag) :polyline
        (= (float t) 0.0) (first pts)
        (= (float t) 1.0) (last pts)
        :else
        (first (filter some?
                       (map #(remap-within %1 %2 t) lines intervals)))))))

#+END_SRC

*** circle
#+BEGIN_SRC clojure :tangle ./src/forge/proto.cljc
(defn frep-circle
  [r]
  (fn [pt]
    (- (distance pt [0 0 0]) r)))

;;https://mathforum.org/library/drmath/view/63755.html
(defn brep-curve-circle
  [a b c]
  (let [n (normalize (normal a b c))
        r (radius-from-pts a b c)
        cp (center-from-pts a b c)
        u (normalize (mapv - a cp))
        v (cross* n u)]
    (fn [t]
      (cond
        (= t :tag) :circle
        (or (< t 0.0) (> t 1.0)) nil
        (= (float t) 0.0) a
        (= (float t) 1.0) a
        :else
        (let [t (* 2 Math/PI t)]
          (v+ cp
              (v* (repeat (* r (Math/cos t))) u)
              (v* (repeat (* r (Math/sin t))) v)))))))

(defn brep-surface-circle
  [a b c]
  (let [cp (center-from-pts a b c)
        c1 (brep-curve-circle a b c)]
    (fn [u v]
      (let [c2 (brep-line cp (c1 u))]
        (c2 v)))))

(defn circle
  [r]
  {:history `(circle ~r)
   :frep (frep-circle r)
   :vertices [#_[0 0 0] [r 0 0] [0 r 0] [(- r) 0 0] [0 (- r) 0]]
   :curves [(brep-curve-circle [r 0 0] [0 r 0] [(- r) 0 0])]
   :surfaces [(brep-surface-circle [r 0 0] [0 r 0] [(- r) 0 0])]})

#+END_SRC

*** ellipse
#+BEGIN_SRC clojure :tangle ./src/forge/proto.cljc
(defn brep-curve-ellipse
  [rx ry]
  (fn [t]
    (let [t (* 2 Math/PI t)
          x (* rx (Math/cos t))
          y (* ry (Math/sin t))]
      [x y])))

#+END_SRC

*** arc
#+BEGIN_SRC clojure :tangle ./src/forge/proto.cljc
(defn old-arc
  [a b c]
  (let [cr (brep-curve-circle a b c)
        c-param (estimate-parameter cr c 0.001)]
    (fn [t]
      (cond
        (or (< t 0.0) (> t 1.0)) nil
        (= (float t) 0.0) a
        (= (float t) 1.0) c
        :else
        (let [t (* c-param t)]
          (cr t))))))
#+END_SRC

There are 2 angle-from-pts functions. They don't both work here, even though I think they should... angle-from-pts2 causes this function to nil out in many cases.

angle-from-pts only reports the small angle no matter what, so that isn't always going to produce the correct arc.

#+BEGIN_SRC clojure :tangle ./src/forge/proto.cljc
(defn brep-curve-arc
  [a b c]
  (let [f (brep-curve-circle a b c)
        cp (center-from-pts a b c)
        angle (angle-from-pts a cp c)]
    (fn [t]
      (let [t (* t (/ angle 360.0))]
        (f t)))))

;; this is not correct. ...-straight-sweep does
;; not account for rotating based on path normal
(defn brep-surface-arc
  [a b c]
  (let [cp (center-from-pts a b c)
        c1 (brep-line cp a)
        c2 (brep-curve-arc a b c)]
    (fn [u v]
      ((brep-curve-straight-sweep c1 c2) u v))))

#+END_SRC

*** fillets
Fillets are applied to a shape at intersections of curves. So, for a polygon, all corner points can be filletted.

A fillet for BREP is best represented with a brep-curve-arc.
A fillet for FREP is best done with transformation using scaling + constant offset to produce a rounded shell that maintains original dimension of the boundary while adding the rounded corners. (see [[https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm]] )

#+BEGIN_SRC clojure :tangle ./src/forge/proto.cljc
#+END_SRC

*** triangle
[[https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm]]

#+BEGIN_SRC clojure :tangle ./src/forge/proto.cljc
(defn frep-triangle
  [a b c]
  (fn [pt]
    (let [[e0 e1 e2] (map #(apply v- %) [[b a] [c b] [a c]])
          [v0 v1 v2] (map (partial v- pt) [a b c])
          xf (fn [v e] 
               (v- v (map * e (repeat (clamp (/ (dot* v e) (dot* e e)) 0 1)))))
          [pq0 pq1 pq2] (map #(apply xf %) [[v0 e0] [v1 e1] [v2 e2]])
          s (sign (- (* (first e0) (second e2)) (* (second e0) (first e2))))
          d1 (min (dot* pq0 pq0)
                  (dot* pq1 pq1)
                  (dot* pq2 pq2))
          d2 (min (* s (- (* (first v0) (second e0)) (* (second v0) (first e0))))
                  (* s (- (* (first v1) (second e1)) (* (second v1) (first e1))))
                  (* s (- (* (first v2) (second e2)) (* (second v2) (first e2)))))]
      (* -1 (Math/sqrt d1) (sign d2)))))

(defn brep-surface-triangle
  [a b c]
  (let [l1 (brep-line b a)
        l2 (brep-line c a)]
    (fn [u v]
      (let [l3 (brep-line (l1 v) (l2 v))]
        (l3 u)))))

(declare brep-curve-polygon)

(defn triangle
  [a b c]
  {:history `(triangle ~a ~b ~c)
   :frep (frep-triangle a b c)
   :vertices [a b c]
   :curves (conj
            (mapv brep-line [a b c] [b c a])
            (brep-curve-polygon [a b c]))
   :surfaces [(brep-surface-triangle a b c)]})

#+END_SRC

*** polygon
#+BEGIN_SRC clojure :tangle ./src/forge/proto.cljc
(defn regular-polygon-pts
  [r n]
  (let [angle (* 2 Math/PI (/ 1 n))]
    (for [step (range n)]
      [(* r (Math/cos (* step angle)))
       (* r (Math/sin (* step angle)))])))

#+END_SRC

My frep-polygon uses a triangulation/union approach. This did break for me in some cases, so I am going to test an alternate implementation. I will port this code:


https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm  (go to polygon - exact section)
https://www.shadertoy.com/view/wdBXRW


Every polygon function must work on & paths, not just a single list of points. This is to allow multi-shape paths (eg. a circle with a hole.)

As well, any polygon union should effectively produce the same polygon that would result from providing each path into one polygon call. That is...

(= (union (polygon pts-a) (polygon pts-b)) (polygon pts-a pts-b))

#+BEGIN_SRC clojure :tangle ./src/forge/proto.cljc
(defn frep-polygon
  [paths]
  (let [pts (apply concat paths) ;; temporary avoidance of path merge
        tris (map
              #(apply frep-triangle %)
              (clip-ears pts)
              (:triangles (clip-ears pts)))]
    (reduce frep-union tris)))

(defn brep-curve-polygon
  [pts]
  (brep-polyline (conj (vec pts) (first pts))))

(defn brep-surface-polygon
  [pts]
  (let [xf (fn [pts] (mapv #(conj % 0) pts))
        tris (mapv xf (:triangles (delaunay/triangulate pts)))]
    (apply brep-surface-union (map #(apply brep-surface-triangle %) tris))))

(defn polygon-old
  [pts]
  {:history `(polygon-old ~pts)
   :frep (frep-polygon pts)
   :vertices (vec pts)
   :curves (mapv 
            #(apply brep-line %) 
            (partition 2 1 (conj (vec pts) (first pts))))
   :surfaces [(brep-surface-polygon pts)]})

(defn close-path
  [path]
  (conj (vec path) (first path)))

(defn path->brep-lines
  [path]
  (mapv #(apply brep-line %) (partition 2 1 path)))
#+END_SRC

Below is a temporary polygon function that concats paths into a single list of points for the FREP. This won't really work correctly for any holes or overlapping paths. I need to fix this behaviour with an updated frep-polygon function that takes paths as an arguement and correctly combines them.

#+BEGIN_SRC clojure :tangle ./src/forge/proto.cljc
(defn polygon
  [& paths]
  (let [paths (mapv vec paths)]
    {:history `(polygon ~@paths)
     :frep nil #_(frep-polygon paths)
     :vertices (apply concat paths)
     :curves (vec (mapcat (comp path->brep-lines close-path) paths))
     :surfaces (mapv brep-surface-polygon paths)}))

#+END_SRC
*** sphere
#+BEGIN_SRC clojure :tangle ./src/forge/proto.cljc
(defn frep-sphere [r]
  (fn [pt]
    (let [[x y z] pt]
      (+ (sq x) (sq y) (sq z) (- (sq r))))))

(defn brep-sphere
  [r]
  (fn [u v]
    (let [[u v] (map #(* 2 Math/PI %) [u v])
          x (* r (Math/sin u) (Math/cos v))
          y (* r (Math/sin u) (Math/sin v))
          z (* r (Math/cos u))]
      [x y z])))

#+END_SRC

*** torus
#+BEGIN_SRC clojure :tangle ./src/forge/proto.cljc
(defn brep-surface-torus
  [R r]
  (fn [u v]
    (let [[u v] (map #(* 2 Math/PI %) [u v])
          x (* (+ R (* r (Math/cos u))) (Math/cos v))
          y (* (+ R (* r (Math/cos u))) (Math/sin v))
          z (* r (Math/sin u))]
      [x y z])))

#+END_SRC

*** cylinder
#+BEGIN_SRC clojure :tangle ./src/forge/proto.cljc
(defn frep-cylinder [r h]
  (fn [pt]
    (let [[x y z] pt]
      (max (- (Math/sqrt (+ (sq x) (sq y))) r)
           (- z h) (- (- h) z)))))

(defn brep-surface-cylinder
  [r h]
  (fn [u v]
    (let [u (* 2 Math/PI u)
          v (* h v)
          x (* r (Math/cos u))
          y (* r (Math/sin u))
          z v]
      [x y z])))

#+END_SRC

*** box
#+BEGIN_SRC clojure :tangle ./src/forge/proto.cljc
(defn frep-box [l w h]
  (fn [pt]
    (let [[x y z] pt]
      (max (- x l) (- (- l) x)
           (- y w) (- (- w) y)
           (- z h) (- (- h) z)))))

#+END_SRC
* splines-proto
try again with pomax's tutorials
#+begin_src clojure
(defn domain
  [knots deg]
  (let [e (- (count knots) 1 deg)]
    [(nth knots deg) (nth knots e)]))

(defn remap
  [[s e] t]
  (+ s (* t (- e s))))

(defn inside?
  [[a b] x]
  (and (<= a x)
       (> b x)))

(defn section
  [knots deg t]
  (let [t (remap (domain knots deg) t)
        spans (partition 2 1 knots)
        mask (mapv #(inside? % t) spans)]
    (count (take-while false? mask))))

;; weight and unweight fns
(defn weight
  [pt wt]
  (apply vector (conj (mapv * pt (repeat wt)) wt)))

(defn unweight
  [pt]
  (if (> (last pt) 0)
    (mapv / (drop-last pt) (repeat (last pt)))
    (drop-last pt)))

;; open uniform clamped knot vector
(defn knots-ouc
  [npts deg]
  (let [s (repeat deg 0)
        e (repeat deg 1)
        step (/ 1 (dec (+ npts 1 (- deg))))
        m (map float (range 0 (+ 1 step) step))]
    (apply vector (concat s m e))))

(defn deboor
  [knots cpts deg t]
  (let [s (section knots deg t)
        d (atom (mapv #(nth cpts (+ % s (- deg))) (range (inc deg))))
        nd (last 
            (for [r (range 1 (inc deg))
                  j (range deg (dec r) -1)]
              (let [ka (nth knots (+ j s (- deg)))
                    kb (nth knots (+ j s 1 (- r)))
                    nr (- t ka)
                    dr (- kb ka)
                    alpha (/ nr dr)
                    dj (nth @d j)
                    dj-1 (nth @d (dec j))]
                (swap! d #(assoc % j (mapv + 
                                           (map * (repeat alpha) dj)
                                           (map * (repeat (- 1 alpha)) dj-1)))))))]
    (nth nd deg)))

(defn -closed-spline
  [cpts wts deg]
  (let [tmp (mapv weight cpts wts)
        wpts (apply vector (concat tmp (take (inc deg) tmp)))
        knots (knots-ouc (count wpts) deg)]
    (fn [t]
      (unweight (deboor knots wpts deg t)))))

(let [tau (* 2 Math/PI)]
  (def ref-spline-data
    {:knots (knots-ouc 10 3)
     :cpts 
     #_[[10 10] [20 600] [120 600] [150 400] [200 10] [300 700] [400 600] [450 400] [500 200] [650 10]]
     (mapv #(vector (+ 500 (* 100 (Math/cos %))) 
                    (+ 500 (* 100 (Math/sin %)))) 
           (range 0 tau (/ tau 10)))
     :wts [1 4 1 4 1 4 1 4 1 4]
     :deg 3}))

(defn -spline
  [cpts wts deg]
  (let [knots (knots-ouc (count cpts) deg)
        wpts (mapv weight cpts wts)]
    (fn [t]
      (unweight (deboor knots wpts deg t)))))

(let [tau (* 2 Math/PI)]
  (def ref-spline-data
    {:knots (knots-ouc 10 3)
     :cpts 
     #_[[10 10] [20 600] [120 600] [150 400] [200 10] [300 700] [400 600] [450 400] [500 200] [650 10]]
     (mapv #(vector (+ 500 (* 100 (Math/cos %))) 
                    (+ 500 (* 100 (Math/sin %)))) 
           (range 0 tau (/ tau 10)))
     :wts [1 1 1 1 1 1 1 1 1 1]
     :deg 3}))

(def sp (-closed-spline (:cpts ref-spline-data) (:wts ref-spline-data) (:deg ref-spline-data)))

#+end_src

* model
** ns
The namespace declaration.
#+begin_src clojure :tangle ./src/forge/model.cljc
(ns forge.model
  (:require [clojure.walk :refer [postwalk]]
            [forge.proto :as f]))

#+end_src

** utils
#+begin_src clojure :tangle ./src/forge/model.cljc
(def pi Math/PI)
(def tau (* 2 pi))
#+end_src

** 2D
#+begin_src clojure :tangle ./src/forge/model.cljc
(defn rect
  [x y]
  [:rect {:origin [0 0 0]
          :lcs {:lx [1 0 0]
                :ly [0 1 0]
                :lz [0 0 1]}
          :x x :y y :center true}])

(defn circle
  [r]
  [:circle {:origin [0 0 0]
            :lcs {:lx [1 0 0]
                  :ly [0 1 0]
                  :lz [0 0 1]}
            :r r}])

(defn polygon
  ([pts]
   [:polygon {:origin [0 0 0]
              :lcs {:lx [1 0 0]
                    :ly [0 1 0]
                    :lz [0 0 1]}
              :pts (vec pts) :paths [(vec (range (count pts)))]}])
  ([pts paths]
   [:polygon {:origin [0 0 0]
              :lcs {:lx [1 0 0]
                    :ly [0 1 0]
                    :lz [0 0 1]}
              :pts (vec pts) :paths paths}]))

(defn project
  [block cut]
  [:project {:origin [0 0 0]
             :lcs {:lx [1 0 0]
                   :ly [0 1 0]
                   :lz [0 0 1]}
             :cut cut} block])

#+end_src

** 3D
#+begin_src clojure :tangle ./src/forge/model.cljc
(defn sphere
  [r]
  [:sphere {:origin [0 0 0]
            :lcs {:lx [1 0 0]
                  :ly [0 1 0]
                  :lz [0 0 1]}
            :r r}])

(defn box
  [x y z]
  [:box {:origin [0 0 0]
         :lcs {:lx [1 0 0]
               :ly [0 1 0]
               :lz [0 0 1]}
         :x x :y y :z z :center true}])

(defn cylinder
  ([r h]
   [:cylinder {:origin [0 0 0]
               :lcs {:lx [1 0 0]
                     :ly [0 1 0]
                     :lz [0 0 1]}
               :r r :h h :center true}])
  ([r1 r2 h]
   [:cylinder {:origin [0 0 0]
               :lcs {:lx [1 0 0]
                     :ly [0 1 0]
                     :lz [0 0 1]}
               :r1 r1 :r2 r2 :h h :center true}]))

(defn polyhedron
  [pts faces]
  [:polyhedron {:origin [0 0 0]
                :lcs {:lx [1 0 0]
                      :ly [0 1 0]
                      :lz [0 0 1]}
                :pts pts :faces faces}])

(defn extrude
  [block {:keys [height twist convexity center slices scale] :as opts}]
  [:extrude (merge {:origin [0 0 0]
                    :lcs {:lx [1 0 0]
                          :ly [0 1 0]
                          :lz [0 0 1]}}
                   opts) block])

(defn revolve
  [block {:keys [convexity angle] :as opts}]
  [:revolve (merge {:origin [0 0 0]
                    :lcs {:lx [1 0 0]
                          :ly [0 1 0]
                          :lz [0 0 1]}}
                   opts) block])
#+end_src

** boolean
#+begin_src clojure :tangle ./src/forge/model.cljc
(defn union
  [& elems]
  [:union {} elems])

(defn intersection
  [& elems]
  [:intersection {} elems])

(defn difference
  [& elems]
  [:difference {} elems])

#+end_src

** transforms
*** translate
#+begin_src clojure :tangle ./src/forge/model.cljc
(defn translate
  [block [x y z]]
  (let [[tag {:keys [origin] :as props} content] block
        xf-props (-> props
                     (assoc :origin (f/v+ origin [x y z]))
                     (assoc :translation [x y z]))]
    [:translate {:xf-elem (vec (filter some? [tag xf-props content]))
                 :translation [x y z]
                 :x x :y y :z z} block]))

#+end_src

*** rotate
#+begin_src clojure :tangle ./src/forge/model.cljc
(defn- rotate-lcs
  [lcs [x y z]]
  (let [[keys vals] ((juxt keys vals) lcs)]
    (zipmap keys (map #(f/rotate-point % [x y z]) vals))))

(defn rotate
  ([block [x y z]]
   (let [[tag {:keys [lcs] :as props} content] block
         xf-props (-> props 
                      (assoc :lcs (rotate-lcs lcs [x y z]))
                      (assoc :rotation [x y z]))]
     [:rotate {:xf-elem (vec (filter some? [tag xf-props content]))
               :rotation [x y z]
               :x x :y y :z z} block]))
  
  ([block a [x y z]]
   [:rotate {:a a :x x :y y :z z} block]))

#+end_src

*** group
#+begin_src clojure :tangle ./src/forge/model.cljc
(defn group
  [& content]
  (if (and (= 1 (count content))
           (not (keyword? (first (first content)))))
    ;; content is a list of a list of elements
    (into [:group {}] (first content))
    ;; content is a single element OR a list of elements
    (into [:group {}] (filter (complement nil?) content))))
#+end_src

*** resize
#+begin_src clojure :tangle ./src/forge/model.cljc
(defn resize
  [block [x y z]]
  [:resize {:x x :y y :z z} block])
#+end_src

*** scale
#+begin_src clojure :tangle ./src/forge/model.cljc
(defn scale
  [block [x y z]]
  [:scale {:x x :y y :z z} block])

#+end_src

*** mirror
#+begin_src clojure :tangle ./src/forge/model.cljc
(defn mirror
  [block [x y z]]
  [:mirror {:x x :y y :z z} block])

#+end_src

*** color
#+begin_src clojure :tangle ./src/forge/model.cljc
(defn color
  [block [r g b a]]
  [:color {:r r :g g :b b :a a} block])

#+end_src

*** hull
#+begin_src clojure :tangle ./src/forge/model.cljc
(defn hull
  [block]
  [:hull {} block])

#+end_src

*** offset
#+begin_src clojure :tangle ./src/forge/model.cljc
(defn offset
  [block opts]
  (if (number? opts)
    [:offset {:r opts} block]
    [:offset opts block]))

#+end_src

*** minkowski
#+begin_src clojure :tangle ./src/forge/model.cljc
(defn minkowski
  [block]
  [:minkowski {} block])

#+end_src

*** multmatrix
#+begin_src clojure :tangle ./src/forge/model.cljc
(defn multmatrix
  [block mtx]
  [:multmatrix {:mtx mtx} block])

#+end_src

** fig
Forge Internal Geometry

The idea is to provide a 2 stage model:

1. the basic tree structure which is hiccup-style and relatively simple.
2. the FIG direct model which is a map containing all necessary data for BREP, FREP, etc.

Compilers can then use the tree structure OR the FIG structure or a hybrid. For example, the scad compiler only needs the tree structure... but the SVG compiler might be better with the FIG structure.


#+begin_src clojure :tangle ./src/forge/model.cljc
#+end_src

* importers
Use parsers to read-in various file types into the model representation.

Then, any number of file inputs can be used in the definition of an object.

For example, 2D drawings can be produced as SVG and read into forge and manipulated using Forge geom tools. Then, you can directly reference them in model creation and output a model to whatever compiler target you wish.

Likewise, you can also use native lang. files as modules in a design. So, if you have a multi file scad design, you can read each scad file in and trust that it is accurately represented with forge-model data and proceed as if it were built directly with forge.
** scad
coming.

** svg
coming.

*** ns
#+begin_src clojure :tangle ./src/forge/import/svg.cljc
(ns forge.import.svg
  (:require [clojure.java.shell :refer [sh]]
            [clojure.string :as str]
            [clojure.data.xml :as xml]
            [svg-clj.main :as svg]
            [svg-clj.path :as path]
            [svg-clj.utils :as utils]
            [svg-clj.transforms :as tf]))

#+end_src

** images
Coming.

** scad-drawing
*** ns
#+begin_src clojure :tangle ./src/forge/import/images.clj
(ns forge.import.images
  (:require [clojure.java.shell :refer [sh]]
            [clojure.string :as str]
            [clojure.data.xml :as xml]
            [svg-clj.main :as svg]
            [svg-clj.path :as path]
            [svg-clj.utils :as utils]
            [svg-clj.transforms :as tf]
            [scad-clj.model :as scad]
            [scad-clj.scad :refer [write-scad]]))

#+end_src

*** img->scad
This part of the library has an external dependency on vtracer:

[[https://github.com/visioncortex/vtracer]]

#+begin_src clojure :tangle ./src/forge/import/images.cljc
(defn img->str [fname]
  "Ingest image file `fname` and transform it into a hiccup data structure."
  (let [new-fname (str (first (str/split fname #"\.")) ".svg")]
    (sh "vtracer" 
        "--mode" "polygon"
        "--colormode" "bw"
        "--segment_length" "3.5"
        "--input" fname
        "--output" new-fname)
    (let [svg-str (slurp new-fname)]
      (sh "rm" new-fname)
      (-> svg-str
          (str/replace #"<\?xml.+>" "")
          str/trim))))

;; xml parse/transform technique is from:
;; https://github.com/babashka/babashka/blob/master/examples/portal.clj
(defn xml->hiccup [xml]
  (if-let [t (:tag xml)]
    (let [elt [t]
          elt (if-let [attrs (:attrs xml)]
                (conj elt attrs)
                elt)]
      (into elt (map xml->hiccup (:content xml))))
    xml))

(defn str->elements
  [str]
  (-> str
      (xml/parse-str :namespace-aware false)
      xml->hiccup
      (->> (drop 2))))

(defn split-path
  [[k props]]
  (let [ps (-> (:d props)
               (str/split #"(?=M)")
               (->> (map str/trim)))]
    (map #(assoc-in [k props] [1 :d] %) ps)))

(defn path->pts
  [path-elem]
  (let [cmds (path/path-string->commands (get-in path-elem [1 :d]))]
    (mapv :input cmds)))

(defn re-center
  [seq]
  (let [group (svg/g seq)
        ctr (mapv float (tf/centroid group))]
    (->> seq
         (map #(tf/translate (utils/v* [-1 -1] ctr) %)))))

#+end_src

*** scad->svg
#+begin_src clojure :tangle ./src/forge/import/images.cljc
(defn scad->svg
  [scad-block]
  (let [scad (write-scad [(scad/fn! 200) scad-block])
        fname (str (gensym "tmp") ".svg")]
    (do (sh "openscad" "/dev/stdin" "-o" fname :in scad)
        (let [svg (slurp fname)]
          (do (sh "rm" fname)
              (str->elements svg))))))

#+end_src

*** lines
#+begin_src clojure :tangle ./src/forge/import/images.cljc
(defn line
  [from to & {:keys [r]}]
  (let [r (if r r 2)]
    (scad/color 
     [0 0 0 1]
     (if (= from to)
       (scad/sphere r)
       (let [diff (map - to from)
             norm (utils/distance from to)
             rotate-angle (Math/acos (/ (last diff) norm))
             rotate-axis [(- (nth diff 1)) (nth diff 0) 0]]
         (scad/union
          (scad/sphere r)
          (scad/translate to (scad/sphere r))
          (->> (scad/cylinder r norm)
               (scad/translate [0 0 (/ norm 2)])
               (scad/rotate rotate-angle rotate-axis)
               (scad/translate from))))))))

(defn polyline
  [pts & {:keys [r]}]
  (apply scad/union (map #(line (first %) (second %) :r r) (partition 2 1 pts))))

#+end_src

*** utils
#+begin_src clojure :tangle ./src/forge/import/images.cljc
(defn- add-z
  [pts]
  (map #(conj % 0) pts))

(defn flip-y
  [pts]
  (map #(utils/v* % [1 -1]) pts))

#+end_src

*** drawing
#+begin_src clojure :tangle ./src/forge/import/images.cljc
(defn line-drawing
  [fname & {:keys [r]}]
  (-> fname
      img->str
      str->elements
      re-center
      (->> (mapcat split-path))
      (->> (map path->pts))
      (->> (map flip-y))
      (->> (map add-z))
      (->> (map #(polyline % :r r)))
      scad/union))

(defn svg-path-elem->scad-polygon
  [path-elem]
  (-> path-elem
      split-path
      (->> (map path->pts))
      (->> (map flip-y))
      (->> (map scad/polygon))
      (->> (apply scad/difference))))

(defn drawing
  [fname]
  (-> fname
      img->str
      str->elements
      re-center
      (->> (map svg-path-elem->scad-polygon))
      scad/union))

#+end_src

*** primitives-wip
#+begin_src clojure :tangle ./src/forge/import/images.cljc
(defn linecube
  [x y z]
  (scad/union
   (scad/color [0 1 0 1] (scad/cube x y z))
   (scad/translate [(/ x -2.0) (/ y -2.0) (/ z -2.0)]
    (scad/union
     (line [0 0 0] [x 0 0])
     (line [x 0 0] [x y 0])
     (line [x y 0] [0 y 0])
     (line [0 y 0] [0 0 0])
     (line [0 0 0] [0 0 z])
     (line [x 0 0] [x 0 z])
     (line [x y 0] [x y z])
     (line [0 y 0] [0 y z])
     (line [0 0 z] [x 0 z])
     (line [x 0 z] [x y z])
     (line [x y z] [0 y z])
     (line [0 y z] [0 0 z])))))

#+end_src

* compilers
A collection of methods for exporting models.

** scad
This is based off of Matthew Farrell's work on scad-clj. The code is modified in the following ways:

- uses some different names
  - cube -> box
  - extrude-linear -> extrude
  - extrude-rotate -> revolve

- uses vectors instead of lists (more hiccup-like) as the expr data structure

- some scad specifics are removed. This is to have 1-1 language for all compilation targets
  - fn! is not used because it does not have an equivalent in FreeCAD, SolidWorks, etc.

*** ns
#+begin_src clojure :tangle ./src/forge/compile/scad.cljc
(ns forge.compile.scad
  (:require [clojure.java.shell :refer [sh]]
            [clojure.string :as str]
            [forge.proto :as f :refer [to-rad
                                       to-deg]]))
#+end_src

*** write-expr
#+begin_src clojure :tangle ./src/forge/compile/scad.cljc
;; multimethod
(defmulti write-expr
  (fn [depth element]
    (if (keyword? (first element)) (first element) :list)))

(defmethod write-expr :list
  [depth [& elems]]
  (mapcat #(write-expr depth %1) elems))

#+end_src

*** utility
#+begin_src clojure :tangle ./src/forge/compile/scad.cljc
;; utility
(defn indent
  [depth]
  (str/join (repeat depth "  ")))

(defn write-block
  [depth block]
  (mapcat #(write-expr (inc depth) %1) block))

(declare map-to-arg-string)

(defn make-arguments
  [args]
  (let [arg (first args)
        rest (rest args)
        piece (cond
               (map? arg) (map-to-arg-string arg)
               (coll? arg) (str "[" (make-arguments arg) "]")
               :else arg)]
    (if (empty? rest)
      piece
      (str/join ", " [piece (make-arguments rest)]))))

(defn map-to-arg-string
  [m]
  (str/join ", " (map (fn [[k v]] (str (name k) "=" (make-arguments [v])) ) m)))

#+end_src

*** 2d-impl
#+begin_src clojure :tangle ./src/forge/compile/scad.cljc
(defmethod write-expr :circle
  [depth [_ {:keys [r center]}]] 
  (list (indent depth) 
        "circle (r=" r ");\n"))

(defmethod write-expr :rect
  [depth [_ {:keys [x y center]}]]
  (list (indent depth)
        "square ([" x ", " y "]"
        (when center ", center=true") ");\n"))

(defmethod write-expr :polygon
  [depth [_ {:keys [pts paths convexity]}]]
  `(~@(indent depth) "polygon ("
    "points=[[" ~(str/join "], [" (map #(str/join ", " %1) pts)) "]]"
    ~@(when paths [", paths=[[" (str/join "], [" (map #(str/join "," %1) paths)) "]]"])
    ~@(when convexity [", convexity=" convexity])
    ");\n"))

(defmethod write-expr :project
  [depth [_ {:keys [cut]} & block]]
  (concat
   (list (indent depth) 
         "projection (cut = " cut ") {\n")
   (mapcat #(write-expr (inc depth) %1) block)
   (list (indent depth) "}\n")))

#+end_src

*** 3d-impl
#+begin_src clojure :tangle ./src/forge/compile/scad.cljc
(defmethod write-expr :sphere
  [depth [_ {:keys [r center]}]]
  (list (indent depth) 
        "sphere (r=" r ");\n"))

(defmethod write-expr :box
  [depth [_ {:keys [x y z center]}]]
  (list (indent depth)
        "cube ([" x ", " y ", " z "]"
        (when center ", center=true") ");\n"))

(defmethod write-expr :cylinder
  [depth [_ {:keys [h r r1 r2 center]}]]
  (concat
   (list (indent depth) 
         "cylinder (h=" h)
   (if r (list ", r=" r) (list ", r1=" r1 ", r2=" r2))
   (when center (list ", center=true"))
   (list ");\n")))

(defmethod write-expr :polyhedron
  [depth [_ {:keys [pts faces convexity]}]]
  `(~@(indent depth) "polyhedron ("
    "points=[[" ~(str/join "], [" (map #(str/join ", " %1) pts)) "]], "
    "faces=[[" ~(str/join "], [" (map #(str/join ", " %1) faces)) "]]"
    ~@(if (nil? convexity) [] [", convexity=" convexity])
    ");\n"))


(defmethod write-expr :extrude
  [depth [_ {:keys [height twist convexity center slices scale]} block]]
  (concat
   (list (indent depth) "linear_extrude (height=" height)
   (if (nil? twist) [] (list ", twist=" (to-deg twist)))
   (if (nil? convexity) [] (list ", convexity=" convexity))
   (if (nil? slices) [] (list ", slices=" slices))
   (cond
     (nil? scale) []
     (sequential? scale) (list ", scale=[" (first scale) ", " (second scale) "]")
     :else (list ", scale=" scale))
   (when center (list ", center=true"))
   (list "){\n")

   (mapcat #(write-expr (inc depth) %1) block)
   (list (indent depth) "}\n")))

(defmethod write-expr :revolve
  [depth [_ {:keys [convexity fn angle]} block]]
  (concat
   (list (indent depth) "rotate_extrude (")
   (str/join ", "
     (concat
       (if convexity [(str "convexity=" convexity)])
       (if angle [(str "angle=" angle)])
       (if fn [(str "$fn=" fn)])))
   (list ") {\n")
   (mapcat #(write-expr (inc depth) %1) block)
   (list (indent depth) "}\n")))

(defmethod write-expr :surface
  [depth [_ {:keys [filepath convexity center invert]}]]
  (concat
   (list (indent depth) "surface (file = \"" filepath "\""
         (when convexity (format ", convexity=%d" convexity))
         (when center ", center=true")
         (when invert ", invert=true")
         ");\n")))

#+end_src

*** transforms-impl
#+begin_src clojure :tangle ./src/forge/compile/scad.cljc
(defmethod write-expr :resize
  [depth [_ {:keys [x y z auto]} block]]
  (concat
   (list (indent depth) "resize ([" x ", " y ", " z "]")
   (list (when-not (nil? auto)
           (str " auto="
                (if (coll? auto)
                  (str "[" (str/join ", " (map true? auto)) "]")
                  (true? auto)))))
   "){\n"
   (mapcat #(write-expr (inc depth) %1) block)
   (list (indent depth) "}\n")))

(defmethod write-expr :translate
  [depth [_ {:keys [x y z]} block]]
  (concat
   (list (indent depth) "translate ([" x ", " y ", " z "]) {\n")
   (write-expr (inc depth) block)
   (list (indent depth) "}\n")))

(defmethod write-expr :rotate
  [depth [_ {:keys [a x y z]} block]]
  (if a
    (concat
     (list (indent depth) "rotate (a=" a ", v=[" x ", " y ", " z "]) {\n")
     (write-expr (inc depth) block)
     (list (indent depth) "}\n"))
    (concat
     (list (indent depth) "rotate ([" x "," y "," z "]) {\n")
     (write-expr (inc depth) block)
     (list (indent depth) "}\n"))))

(defmethod write-expr :scale
  [depth [_ {:keys [x y z]} block]]
  (concat
   (list (indent depth) "scale ([" x ", " y ", " z "]) {\n")
   (write-expr (inc depth) block)
   (list (indent depth) "}\n")))

(defmethod write-expr :mirror
  [depth [_ {:keys [x y z]} block]]
  (concat
   (list (indent depth) "mirror ([" x ", " y ", " z "]) {\n")
   (write-expr (inc depth) block)
   (list (indent depth) "}\n")))

(defmethod write-expr :hull
  [depth [_ _ block]]
  (concat
   (list (indent depth) "hull () {\n")
   (write-expr (inc depth) block)
   (list (indent depth) "}\n")))

(defmethod write-expr :offset
  [depth [_ {:keys [r delta chamfer] :or {chamfer false}} block]]
  (concat
   (list (indent depth) "offset (")
   (if r
     (list "r = " r)
     (list "delta = " delta))
   (when chamfer (list ", chamfer=true"))
   (list ") {\n")
   (write-expr (inc depth) block)
   (list (indent depth) "}\n")))

(defmethod write-expr :minkowski
  [depth [_ _ block]]
  (concat
   (list (indent depth) "minkowski () {\n")
   (write-expr (inc depth) block)
   (list (indent depth) "}\n")))

(defmethod write-expr :multmatrix
  [depth [_ {:keys [mtx]} block]]
  (let [w (fn [s] (str "[" s "]"))
        co (fn [c] (apply str (interpose "," c)))]
    (concat
     (list (indent depth) "multmatrix(")
     (w (co (map #(w (co %)) mtx)))
     (list ") {\n")
     (mapcat #(write-expr (inc depth) %1) block)
     (list (indent depth) "}\n"))))

#+end_src

*** boolean-impl
#+begin_src clojure :tangle ./src/forge/compile/scad.cljc
(defmethod write-expr :union
  [depth [_ _ block]]
  (concat
   (list (indent depth) "union () {\n")
   (write-block depth block)
   (list (indent depth) "}\n")))

(defmethod write-expr :difference
  [depth [_ _ block]]
  (concat
   (list (indent depth) "difference () {\n")
   (mapcat #(write-expr (inc depth) %1) block)
   (list (indent depth) "}\n")))

(defmethod write-expr :intersection
  [depth [_ _ block]]
  (concat
   (list (indent depth) "intersection () {\n")
   (mapcat #(write-expr (inc depth) %1) block)
   (list (indent depth) "}\n")))

#+end_src

*** other-impl
#+begin_src clojure :tangle ./src/forge/compile/scad.cljc
(defmethod write-expr :color
  [depth [_ [r g b a] block]]
  (concat
    (list (indent depth) "color ([" r ", " g ", " b ", " a"]) {\n")
    (write-block depth block)
    (list (indent depth) "}\n")))

(defmethod write-expr :group 
  [depth [_ _ block]]
  (concat
   (list (indent depth) "group() {\n")
   (mapcat #(write-expr (inc depth) %1) block)
   (list (indent depth) "}\n")))

#+end_src

*** write-scad
#+begin_src clojure :tangle ./src/forge/compile/scad.cljc
(defn write-scad [& block]
  (str/join (write-expr 0 block)))

#+end_src

*** tools
#+begin_src clojure :tangle ./src/forge/compile/scad.cljc
(defn png!
  [fname mdl-data]
  (let [scad (write-scad [#_(fn! 20) mdl-data])]
    (sh "openscad" "/dev/stdin"
        "--imgsize" "400,400"
        "--projection" "orthogonal"
        "--colorscheme" #_"greenscreen" "Nord"
        #_"--camera" #_"0,0,0,55,0,25,2900"
        "-o" fname
        :in scad)))

(defn cider-show
  [mdl-data]
  (let [fname "_imgtmp.png"]
    (do (png! fname mdl-data)
        (clojure.java.io/file fname))))

#+end_src

** svg
The initial idea for SVG is to represent all shapes with edges and faces using svg-clj.path/polygon-path fn.

Every elem-to-svg needs the element and a transform function (xf) which takes a list of 3D points and returns a list of 2D points which fit the desired ortho projection (isometric being default).

*** ns
#+begin_src clojure :tangle ./src/forge/compile/svg.cljc
(ns forge.compile.svg
  (:require [clojure.java.shell :refer [sh]]
            [clojure.string :as str]
            [svg-clj.elements :as svg]
            [svg-clj.path :as path]
            [svg-clj.transforms :as tf]
            [svg-clj.tools :as tools]
            [hiccup.core :refer [html]]
            [forge.proto :as f :refer [to-rad
                                       to-deg]]))

#+end_src

*** elem-to-svg
#+begin_src clojure :tangle ./src/forge/compile/svg.cljc
;; multimethod
(defmulti elem-to-svg
  (fn [element _]
    (if (keyword? (first element)) 
      (first element) 
      :list)))

(defmethod elem-to-svg :list 
  [[& args] xf]
  (map #(elem-to-svg % xf) args))

(defn block-to-svg [block xf]
  (map #(elem-to-svg % xf) block))

#+end_src

*** 2d-impl
#+begin_src clojure :tangle ./src/forge/compile/svg.cljc
(defmethod elem-to-svg :circle
  [[_ {:keys [r center origin rotation translation]}] xf]
  (let [rot (if rotation rotation [0 0 0])
        tr (if translation translation [0 0 0])
        pts (->> (f/regular-polygon-pts r 40)
                 (mapv #(conj % 0))
                 (mapv #(f/v+ origin %))
                 (mapv #(f/rotate-point % rot))
                 xf)]
    (-> (path/polygon-path pts)
        (tf/style {:fill "none"
                   :stroke "black"
                   :stroke-width "2px"}))))

(defmethod elem-to-svg :rect 
  [[_ {:keys [x y center origin rotation]}] xf]
  (let [pts (->> (if center
                   [ [(/ x -2.0) (/ y -2.0)]
                    [(/ x 2.0) (/ y -2.0)] 
                    [(/ x 2.0) (/ y 2.0)]
                    [(/ x -2.0) (/ y 2.0)] ]
                   [ [0 0] [x 0] [x y] [0 y] ])
                 (mapv #(f/v+ origin %))
                 (mapv #(f/rotate-point % rotation))
                 xf)]
    (-> (path/polygon-path pts)
        (tf/style {:fill "none"
                   :stroke "black"
                   :stroke-width "2px"}))))

(defmethod elem-to-svg :polygon
  [[_ {:keys [pts paths convexity]}] xf]
  (let [polygons (for [path paths]
                   (xf (map #(get pts %) path)))]
    (-> (apply path/merge-paths 
               (map path/polygon-path polygons))
        (tf/style {:fill "none"
                   :stroke "black"
                   :stroke-width "2px"}))))

#+end_src

*** transforms-impl
#+begin_src clojure :tangle ./src/forge/compile/svg.cljc
(defmethod elem-to-svg :translate 
  [[_ {:keys [xf-elem]} block] xf]
  (elem-to-svg xf-elem xf))

(defmethod elem-to-svg :rotate 
  [[_ {:keys [xf-elem]} block] xf]
  (elem-to-svg xf-elem xf))

#+end_src

*** proto
#+begin_src clojure :tangle ./src/forge/compile/svg.cljc
(def iso-euler-angles [35.264 45 0])
(def origin-angle-adjust-a [90 0 0])
(def origin-angle-adjust-b [0 -90 0])

(defn rotate-points
  [[ax ay az] pts]
  (mapv #(f/rotate-point % [ax ay az]) pts))

(defn isometric-xf
  [pts]
  (->> pts
       (rotate-points origin-angle-adjust-a)
       (rotate-points origin-angle-adjust-b)
       (rotate-points iso-euler-angles)
       (mapv #(into [] (drop-last %)))))

(defn top-xf
  [pts]
  (-> pts
      (rotate-points [0 0 0])))

(defn right-xf
  [pts]
  (-> pts
      (rotate-points [90 0 0])))

(defn write-svg
  [& mdl-data]
  (->> mdl-data
       (mapv #(elem-to-svg % isometric-xf))
       svg/g
       svg/svg
       #_html))

#+end_src

* scratch
A namespace for playing around with fns

#+begin_src clojure
(ns forge.scratch
  (:require [forge.model :as mdl]
            [forge.proto :as proto]
            [forge.compile.scad :as scad]
            [forge.compile.svg :as svg]))

(defn fillet-tool [r l]
  (-> (mdl/difference
       (mdl/box (* r 3) (* r 3) l)
       (mdl/cylinder r (* l 2))
       (-> (mdl/box (* r 3.1) (* r 3.1) (* l 2))
           (mdl/translate [(* r -1.5) 0 0]))
       (-> (mdl/box (* r 3.1) (* r 3.1) (* l 2))
           (mdl/translate [0 (* r -1.5) 0])))
      (mdl/translate [(- r) ( - r) 0])))

(def plate
  (let [[w l t] [56 85 1.5]
        fillet-r 2.5
        hole-r 1.35
        mount-hole (mdl/union
                    (mdl/cylinder hole-r (* 2 t))
                    (mdl/translate (mdl/cylinder 3 1) [0 0 1.1])
                    (mdl/translate (mdl/cylinder 3 1) [0 0 -1.1]))]
    (-> (mdl/difference
         ;; plate base
         (mdl/box w l t)
         ;; fillets
         (-> (fillet-tool fillet-r 4)
             (mdl/rotate [0 0 0])
             (mdl/translate [(/ w 2) (/ l 2) 0]))
         (-> (fillet-tool fillet-r 4)
             (mdl/rotate [0 0 (proto/to-rad 90)])
             (mdl/translate [(/ w -2) (/ l 2) 0]))
         (-> (fillet-tool fillet-r 4)
             (mdl/rotate [0 0 (proto/to-rad 180)])
             (mdl/translate [(/ w -2) (/ l -2) 0]))
         (-> (fillet-tool fillet-r 4)
             (mdl/rotate [0 0 (proto/to-rad 270)])
             (mdl/translate [(/ w 2) (/ l -2) 0]))
         ;; mount holes
         (-> mount-hole
             (mdl/translate [(- (/ w 2) 3.25) (- (/ l 2) 3.25) 0]))
         (-> mount-hole
             (mdl/translate [(+ (/ w -2) 3.25) (- (/ l 2) 3.25) 0]))
         (-> mount-hole
             (mdl/translate [(+ (/ w -2) 3.25) (+ (/ l -2) 23.25) 0]))
         (-> mount-hole
             (mdl/translate [(- (/ w 2) 3.25) (+ (/ l -2) 23.25) 0])))
        (mdl/translate [0 0 (/ t -2.0)]))))

#+end_src
