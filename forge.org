* ;;
#+Title: forge
#+SUBTITLE: build solid modeling programs
#+AUTHOR: adam-james
#+STARTUP: overview
#+EXCLUDE_TAGS: nx
#+PROPERTY: header-args :cache yes :noweb yes :results none :mkdirp yes :padline yes :async
#+HTML_DOCTYPE: html5
#+OPTIONS: toc:2 num:nil html-style:nil html-postamble:nil html-preamble:nil html5-fancy:t

** deps.edn
#+NAME: deps.edn
#+begin_src clojure :tangle ./deps.edn
{:deps 
 {org.clojure/clojure            {:mvn/version "1.10.3"}
  org.clojure/test.check         {:mvn/version "0.9.0"}
  org.clojure/math.numeric-tower {:mvn/version "0.0.4"}
  hiccup/hiccup                  {:mvn/version "2.0.0-alpha2"}
  same/ish                       {:mvn/version "0.1.4"}
  svg-clj/svg-clj                {:local/root "/Users/adam/dev/svg-clj"}}}

#+end_src

OCC works when clj is invoked with clj -A:base.

** readme
#+BEGIN_SRC markdown :tangle ./readme.md
# Forge

Forge is a library for 3D CAD data.

Currently presented here without a license as things are still highly experimental and subject to changes.

#+END_SRC

* design
** intro
*** Pitch
Forge is a powerful Design library that enhances the work of designers and engineers by providing a concise, powerful set of design documentation and creation tools.

It works with the following flow:
- create a text document
- write your specs, design ideas, scope, and any other necessary documentation in plain text
- enter code descriptions of all parts and assemblies in the same document, right with the documentation
- Forge 'renders' this text document to an html file
- view, interact with, change parameters, and export from this html file

*** Emphasis and Values
The design and implementation of Forge focuses heavily on:

- Simplicity
- Composition
- Discipline
- Documentation as Design
- Pragmatic Correctness and Completeness
- Open Source
- User Empowerment

*** Motivation
Design is a difficult task for the craftsperson, and the tools should be as integral to the design work as any final components. At the same time, effective design is communicative of purpose, intent, and method. Designs solve problems as elegantly as possible, taking into primary consideration the context in which the design will live. With such a broad yet critical task, designers must be given the power to create solutions and build abstractions at every layer of their process; from tools to final design.

Solid Modeling is fundamentally a method of communicating the form, function, and interactions of physical objects. Modern CAD programs are extremely powerful and expressive tools which facilitate effective capture of many design needs. Where CAD tools fall short is in expressiveness of parametric design needs, computational approaches to modeling, and reusability of complex and parametric assembly data.

Instead of focusing on the direct manipulation of 3D objects in a user interface, forge favours flexibility and specificity by embracing the functional programming approach. Visual aids are critical for the proper understanding of a solid model, but a visual approach alone is insufficient for fully describing advanced design ideas or parametric aspects of a design. Forge effectively blends the visual elements of design with the expressive power of programming to empower designers to more fully communicate design intent and to enhance problem solving in general.

*** What is Forge?
Forge is a tool that embraces the dynamic and evolving nature of complexity in design by enabling engineers and designers to directly program their designs.

Forge is a Clojure and ClojureScript library for building 3D modeling programs, inspired by [[https://libfive.com/][libfive]], [[http://www.openscad.org/][OpenSCAD]], and [[https://github.com/CadQuery/cadquery][CadQuery]].

*** Intended Workflow
The intended workflow of the Forge library is very simple and is meant to 'get out of the way' of designers and engineers.

The following workflow is assumed to be 'fuzzy' at the transition boundaries from one phase to the next. Additionally, it should be assumed that iteration loops between any number of steps may need to occur. For example, it is often the case in real-world projects that the spec and design phases change dynamically even as programming nears completion. 

**** Spec
Write a specification document capturing the problem being solved and the intended scope of the solution being designed.

**** Design
Document the design in words, pictures, existing 3d models, links to other Forge documents, etc.
For small projects, the spec and design steps can be combined, or even skipped altogether. It is, however, always recommended to at least provide a small explanation section prior to implementing any solutions, to give context to future users.

**** Program
Use all of the Clojure/Clojurescript ecosystem alongside the Forge library to implement scripts and programs that can produce a fully parametric solid model of all parts and assemblies for the design.

This phase can additionally be used to add analytic modelling capabilities and advanced engineering calculations into the model directly using the built in Forge engineering capabilities or pairing with external math, numerics, solver, and AI libraries. The limit is the user's imagination and confidence.

**** Render
Forge is used to read, parse, and compile the design document, which at this point is a full design journal of prose and code which all define the design.

The output of this render process is a powerful html document that fully embeds the working model code alongside the text explaining the design. This is presented to the user as an 'interactive essay' where every part and assembly is shown in 3D and can be manipulated live. All programmed parameters become available as interface elements such as sliders, radio buttons, and drop-down menus where the user can dynamically change the displayed design.

**** Export
From within the rendered html, once a user is satisfied with any parameter changes and is confident the code is 'production ready', it is possible to export final files.

If no commercial CAD software is available, Forge can serve as a perfectly viable commercial tool as it can fully render and export 2D drawing packages suitable for manufacturing.

If designers wish to add or change designs in a tool they are familiar with, commercial CAD export options exist: STEP files (generic, safe export option), SW vba script files, Inventor vba script files, and AutoCAD LISP files are all producible. These scripts, when run in their appropriate software, will render a fully native part/assembly file.

**** Iterate
The design of a solution is fully described in text and code, and so is quick to change, fast to load, and easy to manipulate. With Forge's 'watch and render' capabilities, a very tight design loop is formed where the designer can create changes to text and code and see them reflected live in the rendered document. 

This is excellent for design work which can be completed by an individual. Iteration however, often occurs over the course of days and weeks and includes many different stakeholders. Forge's intended workflow is designed so that the canonical design is always captured in the text. If a CAD file is lost, it can be re-produced easily from the text. If stakeholders make custom, one-time tweaks to CAD files or drawings, they do not 'filter back' and cause problems with the original design. 

The 'change arrow' always occurs one way. txt -> html -> CAD
This mono-directional change seems like a hinderance, but forces the user(s) to capture design intent at the lowest level, always ensuring correctness downstream.

** architecture
The Forge library is architected around an idea of *functional layering.* Layering begins with a *kernel* of necessary functionality and wraps on additional functionality. Each added layer depends upon prior layers, but adds value to the unit as a whole. This implies that:
 - a *kernel* is the minimum set of functionality that can provide value
 - any layer on its own provides no utility, due to its dependence on prior layers

The layering concept is useful at varying levels of abstraction and is used liberally throughout the Forge Library.

*** Code Units
Layering provides structure to *code units* which are well-designed sets of functions that provide utility in some context. 

Extending the idea of a code unit is a *design document* which is a document that fully captures the problem, and the design intent of the unit. 

It is not strictly necessary to realize every layer to produce a valid code unit, with the exception of the kernel. Nevertheless, a code unit becomes more valuable with each layer implemented.

With this in mind, the layers of a code unit are as follows:
 
 1. *design*
    A document explaining the need for the unit and the approach being taken to address it. A fully developed design will include elements familiar to engineers like a problem statement, assumptions, unknowns, constraints, and parameters.

 2. *kernel*
    The set of functions that implement the required functionality. The most direct realization of an algorithm or procedure for meeting the requirements.

 3. *guard*
    Validation functions or specs that ensure any data passed into the kernel is correctly shaped and logically correct according to the intended use cases. Error handling functions that protect and communicate errors that originate in the kernel.

 4. *instrumentation*
    The set of functions that perform useful measurement tasks such as logging, debugging, and timing.

 5. *optimization*
    The set of functions that can use additional logic to create functionally equivalent versions of data and/or functions that run more optimally than the default kernel.

 6. *interface*
    The set of functions that wrap all prior layers into a package that can be appropriately and easily used by users. Different users may use different interfaces such as dev. and user interfaces.

 7. *test*
    The set of functions which run unit tests on all prior layers as well as integration tests for the fully wrapped kernel.

*** Library Structure
The layering of the Forge Library begins at the *solid model* and extends up to the *test harness* layer.

The layers:
 1. design
 2. solid model
 3. guard
 4. analytic model
 5. optimizer
 6. interface
 7. test harness

**** design
The design of the Forge Library is captured in the form of a literate program. In fact, it lives in this very document. Additional notes and diagrams are added into the project's directory and linked into this document as needed.

**** solid model
The solid model is a *script* using the *domain specific language (DSL)* provided by ~forge.lang~ to describe the shape and dimensions of an object. This is the minimum required element for creating a useful design with Forge. The DSL is embedded within Clojure/Clojurescript permitting full use of the entire Clojure ecosystem of libraries.

User facing functions are geometric, transforms, constructive, topological, math, and utility functions which can all be used to accurately describe parts and assemblies. In all cases, the user is not required to consider the underlying implementation of any functions.

A solid model is *executable*. When run, a solid model program will produce an *enriched abstract syntax tree (AST)* which forms the main data structure on which all subsequent layers operate.

**** guard
The guard layer provides *validation* of data entering the solid model and *error handling* to properly manage errors that occur when the solid model is executed.

Beyond simple validation and error handling, Forge's guard layer consists of a parameter and constraint handling set of functions. These functions allow the user to specify many types of parametric relationships between dimensions and variables defined in the solid model, as well as constraints.

If no guards are explicitly designed, the constraints and parameters default to be fixed at the intial values programmed into the solid model.

**** analytic model
The analytic model provides advanced functionality for describing high level requirements which are typically derived from engineering analysis considerations.

The analytical model has two pathways for affecting the solid model: *interfacing* or *integrating*. 

Interfacing is the simpler approach as it adjusts the model strictly through the guard layer; the results from an analysis run will only ever change parameter and constraint values.

Integrating is a much more complex mode as it can directly alter the solid model's code. This may be desireable for highly complex logical transformations of a model based on a very involved analysis approach. It is more complex because changing the solid model necessarily requires that the analytic model has logic for updating the parameters and constraints in the guard layer.

Both modes of analytic interaction are fully supported and encouraged by the Forge library.

**** optimizer
The optimizer is capable of altering the AST to improve on various key metrics such as generation speed, memory use, renderability, exportability, and complexity.

The optimizer performs these improvements heuristically. It is important to allow the optimizer to be tuned appropriately for the use case because some optimizations may lead to lossy alterations. This is of particular importance for highly parametric designs as geometric simplification may accidentally erase design intent.

The main optimizations focus on AST simplification by swapping nested structures for volumetrically equivalent flat calls.

**** interface
The interface layer has a high degree of optionality as it contains diverse functionality:
 - graphical views
 - GUI forms
 - minimal viewers
 - web app producers
 - compilers/transpilers
 - exporters

All interface functionality is intended to be used as pieces for the designer to be able to build a program which can fully express the design intent of *all possible* variants of the design.

**** test harness
The guard layer is intended to handle data related validation and to enforce appropriate constraints and parameter limits, but it is not a sufficient layer for fully testing the entire design program. The test harness layer provides a suite of useful tests which can be run against any Forge prorgam.

The test harness also provides a simple interface for designers to define their own tests and run them with the rest of the test suite.

*** A Diagram
To keep it all straight.

#+begin_src text

   design
     doc
      |
      V
+-----------+
|   solid   |<--(ns forge.lang)<-+--(ns forge.brep)
|   model   |                     `-(ns forge.frep)
+-----------+
      |
      V
+-----------+
|   guard   |<--(ns forge.guard)
|           |
+-----------+
      |
      V
+-----------+
| analytic  |<--(ns forge.analytic)
|   model   |
+-----------+
      |
      V
+-----------+
| optimizer |<--(ns forge.optimize)
|           |
+-----------+
      |
      V                            ,-(ns forge.app)
+-----------+                     |--(ns forge.gui)
| interface |<--(ns forge.build)<-+--(ns forge.impl)
|           |                     |--(ns forge.view)
+-----------+                     |--(ns forge.compile)
      |                            `-(ns forge.web)
      V
+-----------+
|   test    |<--(ns forge.test)
|  harness  |
+-----------+
      |
      V
 integration

#+end_src
** notes
I need to productize fairly quickly.

Necessary features for acceptable 'paid prototyping':
- STEP export 
  - do this by creating a Server/Client Webapp. FreeCAD first as STEP backend
  - upgrade from FreeCAD to proper Kernel (OCCT...)
  - alternatively, use CadQuery 2.0 as the intermediate.
- WebGL 3D renders
- Drawing Export
  - PDF
  - Parametric SVGs in design docs
  - DXF

Very soon after initial contracts, I suspect I'll need:
- native export
  - Macro generators for VBA (SW and Inventor)
  - AutoLISP generators

- DesignDoc Editor App
  - let users design their own part/assembly docs with some basic notebook style tooling

Long term, I want to build my own CAD Kernel, native in Clojure so that CLJ/CLJS can be fully portable without any connection to a server. This will be useful for powerful app building -> custom CAD programs for very niche design industries.

* utils
Use the util namespace to place functions which may be used across the other namespaces. Currently the util namespace contains mostly geometry calculation functions like checks for lines and points.

** ns
#+begin_src clojure :tangle ./src/forge/utils.cljc
(ns forge.utils
  (:require [clojure.string :as str]
            [same :refer [ish? zeroish?]]))

#+end_src
** comparing-floats
This is a strangely complicated topic, and I want to implement my own functions to help compare float/double numbers to one another.

This is mostly necessary for comparing two equal-length collections of float values. This pops up a lot when doing geometry calculations due to vector and matrix operations, which are represented with [Clojure vectors] in Forge.

Since I will also need to check if float values are near zero, I'll have a special function specifically for that. This is necessary because of how floating point values are represented. The zero case is special, so I have a function for it.

NOTE: Provide more clear explanation about floating point comparisons AND my implementation choice. In particular, talk about relativeMax and why I did NOT use ULP methods.

The implementation is taken from:
[[https://floating-point-gui.de/errors/NearlyEqualsTest.java]]

This, like any float comparison implementation, is not guaranteed to be useful in all contexts.

It is sufficient for Forge for the following reasons:
- it is used near zero most often
- it is unlikely to be used when handling values much larger than 10,000 in magnitude due to typical scales of units in engineering projects.

#+begin_src clojure :tangle ./src/forge/utils.cljc
(defn nearly?
  "compare two float values for approximate equality.
   
   Default epsilon = 0.00001"
  ([^long a ^long b]
   (nearly? a b 0.00001))

  ([^long a ^long b ^long epsilon]
   (let [a (float a)
         b (float b)]
     (if (= a b)
       true
       (let [absA (Math/abs a)
             absB (Math/abs b)
             diff (Math/abs (- a b))
             min-f 1.17549435E-38
             max-f 3.4028235E38]
         (if (or (= a 0.0) 
                 (= b 0.0) 
                 (< (+ absA absB) min-f))
           (< diff (* epsilon min-f))
           (< (/ diff (Math/min (+ absA absB) max-f)) epsilon)))))))

(defn all-nearly?
  "check if all numbers are nearly equal to one another in two collections"
  [coll-a coll-b]
  (if (not (= (count coll-a) (count coll-b)))
    #?(:clj  (throw (Exception. "collections must be same size."))
       :cljs (throw (js/Error. "collections must be same size.")))
    (let [diffs (mapv #(float (Math/abs ^long (- %1 %2))) coll-a coll-b)]
      (empty? 
       (filter 
        false? 
        (map zeroish? diffs))))))

#+end_src

To make sure float checks work, I'm implementing unit tests.

The tests here are taken from:
[[https://floating-point-gui.de/errors/NearlyEqualsTest.java]]

and re-implemented with clojure.test library.

*** float-comparison-tests
#+begin_src clojure
(deftest nearly-test
  (testing "Regular large numbers"
    (is      (nearly? (float 1000000) (float 1000001)))
    (is      (nearly? (float 1000001) (float 1000000)))
    (is (not (nearly? (float 10000) (float 10001))))
    (is (not (nearly? (float 10001) (float 10000)))))
  (testing "Negative large numbers"
    (is      (nearly? (float -1000000) (float -1000001)))
    (is      (nearly? (float -1000001) (float -1000000)))
    (is (not (nearly? (float -10000) (float -10001))))
    (is (not (nearly? (float -10001) (float -10000)))))
  (testing "Numbers around 1"
    (is      (nearly? (float 1.0000001) (float 1.0000002)))
    (is      (nearly? (float 1.0000002) (float 1.0000001)))
    (is (not (nearly? (float 1.0001) (float 1.0002))))
    (is (not (nearly? (float 1.0002) (float 1.0001)))))
  (testing "Numbers around -1"
    (is      (nearly? (float -1.0000001) (float -1.0000002)))
    (is      (nearly? (float -1.0000002) (float -1.0000001)))
    (is (not (nearly? (float -1.0001) (float -1.0002))))
    (is (not (nearly? (float -1.0002) (float -1.0001)))))
  (testing "Numbers between 1 and 0"
    (is      (nearly? (float 0.000000001000001) (float 0.000000001000002)))
    (is      (nearly? (float 0.000000001000002) (float 0.000000001000001)))
    (is (not (nearly? (float 0.000000000001001) (float 0.000000000001002))))
    (is (not (nearly? (float 0.000000000001002) (float 0.000000000001001)))))
  (testing "Numbers between -1 and 0"
    (is      (nearly? (float -0.000000001000001) (float -0.000000001000002)))
    (is      (nearly? (float -0.000000001000002) (float -0.000000001000001)))
    (is (not (nearly? (float -0.000000000001001) (float -0.000000000001002))))
    (is (not (nearly? (float -0.000000000001002) (float -0.000000000001001)))))
  (testing "Small differences away from zero"
    (is (nearly? (float 0.3) (float 0.30000003)))
    (is (nearly? (float -0.3) (float -0.30000003))))
  (testing "Comparisons involving zero"
    (is      (nearly? (float 0.0) (float 0.0)))
    (is      (nearly? (float 0.0) (float -0.0)))
    (is      (nearly? (float -0.0) (float -0.0)))
    (is (not (nearly? (float 0.00000001) (float 0.0))))
    (is (not (nearly? (float 0.0) (float 0.00000001))))
    (is (not (nearly? (float -0.00000001) (float 0.0))))
    (is (not (nearly? (float 0.0) (float -0.00000001))))
    (is      (nearly? (float 0.0) (float 1e-40) (float 0.01)))
    (is      (nearly? (float 1e-40) (float 0.0) (float 0.01)))
    (is (not (nearly? (float 0.0) (float 1e-40) (float 0.000001))))
    (is (not (nearly? (float 1e-40) (float 0.0) (float 0.000001))))
    (is      (nearly? (float 0.0) (float -1e-40) (float 0.1)))
    (is      (nearly? (float -1e-40) (float 0.0) (float 0.1)))
    (is (not (nearly? (float 0.0) (float -1e-40) (float 0.00000001))))
    (is (not (nearly? (float -1e-40) (float 0.0) (float 0.00000001))))))

#+end_src

** vector-arithmetic
#+begin_src clojure :tangle ./src/forge/utils.cljc
(def v+ (partial mapv +))
(def v- (partial mapv -))
(def v* (partial mapv *))

#+end_src

** math-utils
#+begin_src clojure :tangle ./src/forge/utils.cljc
(defn to-deg
  [rad]
  (* rad (/ 180 Math/PI)))

(defn to-rad
  [deg]
  (* deg (/ Math/PI 180)))

(defn round
  [num places]
  (let [d (Math/pow 10 places)]
    (/ (Math/round (* num d)) d)))

(defn sign
  "returns -1 if x is less than 0, 0 if x is 0 and 1 if x is greater"
  [x]
  (cond
    (or (= 0.0 x) (= 0 x)) 0
    (< 0 x) 1
    (> 0 x) -1))

(defn average
  [& numbers]
  (let [n (count numbers)]
    (/ (apply + numbers) n)))

(defn sq
  [x]
  (* x x))

(defn clamp
  "clamps a value between lower bound and upper bound"
  [x lb ub]
  (cond
    (< x lb) lb
    (> x ub) ub
    :else x))

(defn add-z
  [pt]
  (conj (vec pt) 0))

(defn flip-y
  [pts]
  (map #(v* % [1 -1]) pts))

#+end_src

** list-manipulations
#+begin_src clojure :tangle ./src/forge/utils.cljc
(defn vec-diff
  "returns the collection difference of two vectors"
  [v1 v2]
  (vec (into #{} (concat v1 v2))))

(defn vec-inner-pop
  "pop the item at index from the collection"
  [coll ind]
  (into [] (conj (subvec coll 0 ind) (subvec coll (inc ind)))))

(defn push-new
  "push item onto vector if it doesn't already exist."
  [v n]
  (if (some #{n} v)
    v
    (conj v n)))

(defn concat-new
  "concat two vectors together pushing only unique items."
  [a b]
  (reduce push-new a b)) 

#_(defn position
  "returns index of first match to item in the src vector. Otherwise nil"
  [src item]
  (let [res (.indexOf src item)]
    (when (>= res 0)
      res)))

#_(defn link
  "Swap an item for it's index in a different list"
  [src item]
  (let [type-k (first item)
        vals (rest item)]
    (vec (conj (map #(position src %) vals) type-k))))

(defn unlink
  "Swap an item's idx for it's value in a different list"
  [src item]
  (let [type-k (first item)
        indices (rest item)]
    (vec (conj (map #((vec src) %) indices) type-k))))

#+end_src

** geometry-calculations
#+begin_src clojure :tangle ./src/forge/utils.cljc
(defn slope-2d
  [a b]
  (let [[x1 y1] a
        [x2 y2] b]
    (/ (- y2 y1) (- x2 x1))))

(defn perpendicular-2d
  [[x y]]
  [(- y) x])

(defn determinant-2d
  [a b]
  (- (* (first a) (second b))
     (* (second a) (first b))))

(defn dot*
  "calculates the dot product of two vectors"
  [a b]
  (reduce + (map * a b)))

(defn cross*
  "calculates cross product of two 3d-vectors"
  [a b]
  (let [[a1 a2 a3] a
        [b1 b2 b3] b
        i (- (* a2 b3) (* a3 b2))
        j (- (* a3 b1) (* a1 b3))
        k (- (* a1 b2) (* a2 b1))]
    [i j k]))

(defn distance
  "compute distance between two points"
  [a b]
  (let [v (v- b a)
        v2 (reduce + (v* v v))]
    (Math/sqrt ^double v2)))

(defn normalize
  "find the unit vector of a given vector"
  [v]
  (let [m (Math/sqrt ^double (reduce + (v* v v)))]
    (mapv / v (repeat m))))

(defn on-line?
  "determine if a point is on a capped line"
  [pt line]
  (let [[a b] line
        ap (v- a pt)
        bp (v- b pt)]
    (if (or (all-nearly? pt a) 
            (all-nearly? pt b))
      true
      (let [na (normalize ap)
            nb (normalize bp)]
        (and 
         (all-nearly? (cross* ap bp) [0 0 0]) 
         (not (all-nearly? na nb)))))))

(defn on-line-inf?
  "determine if a point is on an infinitely extending line"
  [pt line]
  (let [[a b] line
        ap (mapv - a pt)
        bp (mapv - b pt)]
    (all-nearly? (cross* ap bp) [0 0 0])))

(defn sin-cos-pair [theta]
  [(Math/sin ^long (to-rad theta))
   (Math/cos ^long (to-rad theta))])

(defn rot-pt-2d
  [[x y] theta]
  (let [[s-t c-t] (sin-cos-pair theta)]
    [(- (* x c-t) (* y s-t))
     (+ (* y c-t) (* x s-t))]))

;; this rotates a point around [0,0,0]
(defn rot-pt
  [[x y z] axis theta]
  (cond
    (= axis :x) (into [x] (rot-pt-2d [y z] theta))
    (= axis :y) (apply #(into [] [%2 y %1]) (rot-pt-2d [z x] theta))
    (= axis :z) (into (rot-pt-2d [x y] theta) [z])))

(defn rotate-point
  [pt [ax ay az]]
  (let [pt (if (< (count pt) 3)
             (conj pt 0)
             pt)]
    (-> pt
        (rot-pt :z az)
        (rot-pt :y ay)
        (rot-pt :x ax))))

(defn normal
  "find normal vector of plane given 3 points"
  [a b c]
  (let [ab (mapv - a b)
        ac (mapv - a c)]
    (if (on-line? c [a b]) nil (cross* ab ac))))

(defn on-plane?
  "determine if a point is on a plane"
  [pt plane]
  (let [a (map - pt (first plane))
        n (normal (first plane) (second plane) (nth plane 2))]
    (nearly? (Math/abs ^long (dot* a n)) 0)))

(defn plane-triple
  "gets a list of 3 points on a plane from a list of points"
  [pts]
  (if (< (count pts) 3) nil
    (let [[a b c] pts]
      (if (on-line? c [a b]) 
        (plane-triple (vec-inner-pop pts 2))
        [a b c]))))

(defn planar?
  "checks if all points in a list share a plane"
  [pts]
  (cond
    (< (count pts) 3) false
    (= (count pts) 3) (let [a (first pts)
                            b (second pts)
                            c (nth pts 2)]
                        (if (on-line? c [a b]) false true))
    :else (let [plane (plane-triple pts)
                chk-pts (vec-diff plane pts)]
            (every? #(= % true) (mapv #(on-plane? % plane) chk-pts)))))

(defn radius-from-pts
  "compute the radius of an arc defined by 3 points"
  [p1 p2 p3]
  (when-not (on-line? p1 [p2 p3])
    (let [a (distance p3 p2)
          b (distance p3 p1)
          c (distance p2 p1)
          s (/ (+ a b c) 2)
          sa ( - s a)
          sb ( - s b)
          sc ( - s c)
          rt (Math/sqrt (* s sa sb sc))
          R (/ (/ (* a b c) 4) rt)]
      R)))

;; https://math.stackexchange.com/questions/361412/finding-the-angle-between-three-points
(defn angle-from-pts
  [p1 p2 p3]
  (let [v1 (v- p2 p1)
        v2 (v- p2 p3)
        l1 (distance p1 p2)
        l2 (distance p3 p2)
        n (dot* v1 v2)
        d (Math/abs ^long (* l1 l2))]
    (when (not (= 0.0 (float d)))
      (to-deg (Math/acos ^long (/ n d))))))

;; https://math.stackexchange.com/a/1743505
(defn center-from-pts
  "compute the center point of an arc through 3 points"
  [p1 p2 p3]
  (when-not (on-line? p1 [p2 p3])
    (let [u1 (mapv - p2 p1)
          u2 (mapv - p3 p1)
          w1 (cross* (mapv - p3 p1) u1)
          u (normalize u1)
          w (normalize w1)
          v (cross* w u)
          [bx by] [(dot* u1 u) 0]
          [cx cy] [(dot* u2 u) (dot* u2 v)]
          h (/ (+ (sq (- cx (/ bx 2))) (sq cy) (- 0 (sq (/ bx 2)))) 
               (* 2 cy))]
      (v+ p1 
          (v* (repeat (/ bx 2)) u) 
          (v* (repeat h) v)))))

#+end_src

** generators
These are things like point list generators.

#+BEGIN_SRC clojure :tangle ./src/forge/utils.cljc
(defn regular-polygon-pts
  [r n]
  (let [angle (* 2 Math/PI (/ 1 n))]
    (for [step (range n)]
      [(* r (Math/cos (* step angle)))
       (* r (Math/sin (* step angle)))])))

#+END_SRC

** misc
#+BEGIN_SRC clojure :tangle ./src/forge/utils.cljc
(defn ext
  [fname]
  (last (str/split fname #"\.")))

#+END_SRC

* geom-computations
** ns
#+begin_src clojure :tangle ./src/forge/geom.cljc
(ns forge.geom
  (:require [forge.utils :as utils]
            [forge.delaunay :as delaunay]
            [clojure.string :as str]
            [same :refer [ish? zeroish?]]))

#+end_src

** area
#+begin_src clojure :tangle ./src/forge/geom.cljc
(defn triangle-area
  "compute the area of a triangle defined by three points"
  [a b c]
  ;; use Heron's formula
  (let [la (utils/distance b c)
        lb (utils/distance a c)
        lc (utils/distance a b)
        s (/ (+ la lb lc) 2)]
    (Math/sqrt (* s (- s la) (- s lb) (- s lc)))))

(defn polygon-area
  [pts]
  (let [tris (:triangles (delaunay/triangulate pts))]
    (->> pts
         (delaunay/triangulate)
         (:triangles)
         (map #(apply triangle-area %))
         (reduce +))))

#+end_src

** bounds
#+begin_src clojure :tangle ./src/forge/geom.cljc
(defn bb-corners-2d
  [pts]
  (let [xs (map first pts)
        ys (map last pts)
        xmax (apply max xs)
        ymax (apply max ys)
        xmin (apply min xs)
        ymin (apply min ys)]
    [[xmin ymin]
     [xmax ymax]]))

(defn bb-center-2d
  [pts]
  (let [xs (map first pts)
        ys (map last pts)
        xmax (apply max xs)
        ymax (apply max ys)
        xmin (apply min xs)
        ymin (apply min ys)]
    [(+ (/ (- xmax xmin) 2.0) xmin)
     (+ (/ (- ymax ymin) 2.0) ymin)]))

(defn midpoint
  [pts]
  (let [axes (count (first pts))
        splits (for [axis (range 0 axes)]
                 (map #(nth % axis) pts))]
    (mapv #(apply utils/average %) splits)))

(defn bounding-box-corners
  [shape]
  (let [xs (map #(nth % 0)
                (sort-by #(nth % 0) (:vertices shape)))
        ys (map #(nth % 1)
                (sort-by #(nth % 1) (:vertices shape)))
        zs (map #(nth % 2)
                (sort-by #(nth % 2) (:vertices shape)))]
    [[(first xs) (first ys) (first zs)]
     [(last xs) (last ys) (last zs)]]))

(declare polygon)
(declare extrude)
(defn bounding-volume-proto
  [shape]
  (let [[a z] (bounding-box-corners shape)
        b [(first z) (second a) (last a)]
        c [(first z) (second z) (last a)]
        d [(first a) (second z) (last a)]
        s1 (polygon [a b c d])
        h (Math/abs (- (last z) (last a)))]
    (extrude s1 h)))

#+end_src

** estimators
Some properties are needed during calculations. The simplest way to ge them is with estimators. These should improve over time, but for now can 'brute force' things a bit.

#+begin_src clojure :tangle ./src/forge/geom.cljc
(defn estimate-path-length
  [path [t1 t2] step]
  (let [samples (range t1 (+ t2 step) step)
        pts (partition 2 1 (map path samples))]
    (reduce + (map (partial apply utils/distance) pts))))

;; this breaks somewhat often. Consider a case where the match is
;; a very tiny difference in parameter space. It's easy to pass over it
;; there's surely a more refined approach, perhaps a combination of several algorithms?
(defn close?
  [p1 p2]
  (let [[x1 y1 z1] p1
        [x2 y2 z2] p2]
    (and (utils/nearly? (+ 1 (Math/abs (- x1 x2))) 1.0)
         (utils/nearly? (+ 1 (Math/abs (- y1 y2))) 1.0)
         (utils/nearly? (+ 1 (Math/abs (- z1 z2))) 1.0))))

(defn estimate-parameter
  [f pt step]
  (let [[x y z] pt
        samples (into [] (range 0 (+ 1 step) step))
        pts (mapv f samples)
        close? (partial close? pt)]
    (get samples
         (count (take-while #(not (= (first (filter close? pts)) %)) pts)))))

#+end_src

** polygon-intersection
HUGE NOTE: The nearly function needs serious checking. It will be necessary to work very well because I need 'close enough' predicates often when working with geometry checks.

#+begin_src clojure :tangle ./src/forge/geom.cljc
(defn line-intersection
  [[a b] [c d]]
  (let [[ax ay] a
        [bx by] b
        [cx cy] c
        [dx dy] d
        xdiff [(- ax bx) (- cx dx)]
        ydiff [(- ay by) (- cy dy)]
        div (utils/determinant-2d xdiff ydiff)]
    (when (not (zeroish? (Math/abs div))) 
      (let [d [(utils/determinant-2d a b) (utils/determinant-2d c d)]
            x (/ (utils/determinant-2d d xdiff) div)
            y (/ (utils/determinant-2d d ydiff) div)]
        [x y]))))

(defn line-segment-intersection
  [[a b] [c d]]
  (let [pt (line-intersection [a b] [c d])]
    (when (and pt
               (utils/on-line? (utils/add-z pt) (mapv utils/add-z [a b]))
               (utils/on-line? (utils/add-z pt) (mapv utils/add-z [c d])))
      pt)))

(defn identical-polygons?
  [pga pgb]
  (= (into #{} pga)
     (into #{} pgb)))

(defn- close-pts
  [pts]
  (vec (take (inc (count pts)) (cycle pts))))

(defn polygon-intersection
  [pga pgb]
  (when (not (identical-polygons? pga pgb))
    (let [lines-a (partition 2 1 (close-pts pga))
          lines-b (partition 2 1 (close-pts pgb))
          s (for [la lines-a
                  lb lines-b]
              (line-segment-intersection la lb))]
      (->> s
           (filter (complement nil?))
           (into #{})
           (vec)))))

#+end_src

continue the algorithm...

 - point inside?
   - line to right... count intersections even = outside, odd = inside, 0 = outside (but only works for convex polygons)
     - need to consider parallel lines and vertices changing the intersection count (for concanve polygon)

#+begin_src clojure :tangle ./src/forge/geom.cljc
(defn pt-inside-convex?
  [pts pt]
  (let [m (mapv float (midpoint pts))
        xs (polygon-intersection pts [m pt])]
    ;; pt inside when count intersection = 0
    ;; pt inside when intersection = pt
    (or (= 0 (count xs))
        (utils/all-nearly? (first xs) pt))))

(defn pt-inside-convex-strict?
  [pts pt]
  (let [m (mapv float (midpoint pts))
        xs (polygon-intersection pts [m pt])]
    (utils/all-nearly? (first xs) pt)))

(defn quadrant
  [x y]
  (let [mask [(pos? x) (pos? y)]]
    (cond (= mask [ true  true]) 1
          (= mask [false  true]) 2
          (= mask [false false]) 3
          (= mask [ true false]) 4)))
#+end_src

The angle-from-pts2 implementation has an issue with ambiguity of quadrant. take [1 0] and [0 1] (and [-1 0] and [0 -1]). The zero isn't positive or negative so causes incorrect quadrant classification which breaks the conditional branch logic.

#+begin_src clojure :tangle ./src/forge/geom.cljc
(defn angle-from-pts2 
  "Angle following RHR from p3p2 to p1p2"
  [p1 p2 p3]
  (let [[ax ay] (utils/v- p1 p2)
        [bx by] (utils/v- p3 p2)
        qa (quadrant ax ay)
        qb (quadrant bx by)
        theta-a (utils/to-deg (Math/atan2 ay ax))
        theta-b (utils/to-deg (Math/atan2 by bx))]
    (cond 
      ;; la and lb both in same quadrant, always < 90deg
      (= qa qb) (- theta-b theta-a)
      ;; qa greater than qb and 2 away [4 2] or [3 1]
      (= 2 (- qa qb)) (- 360 theta-b theta-a)
      ;; qb greater than qa and 2 away [2 4] or [1 3]
      (= 2 (- qb qa)) (- theta-b theta-a)
      (or
       (= [qa qb] [2 1])
       (= [qa qb] [4 3])) (- 180 (Math/abs theta-b) (Math/abs theta-a))
      (or
       (= [qa qb] [1 2])
       (= [qa qb] [3 4])) (+ 180 (Math/abs theta-b) (Math/abs theta-a))
      (or
       (= [qa qb] [3 2])
       (= [qa qb] [1 4])) (+ (Math/abs theta-b) (Math/abs theta-a))
      (or
       (= [qa qb] [2 3])
       (= [qa qb] [4 1])) (+ 180 (Math/abs theta-b) (Math/abs theta-a)))))

(defn acute?
  [p1 p2 p3]
  (< (angle-from-pts2 p1 p2 p3) 180.0))      

(defn line?
  [[a b c]]
  (utils/on-line-inf? (utils/add-z a) (mapv utils/add-z [b c])))

(defn contains-value?
  [coll val]
  (when (some #{val} coll) true))

(defn vecdiff
  [va vb]
  (into [] (filter (complement (partial contains-value? vb)) va))) 

(defn simplify-segments
  [pts]
  (let [triples (partition 3 1 (take (+ 2 (count pts)) (cycle pts)))
        removable (map second (filter line? triples))]
    (vecdiff pts removable)))

;; can I use reduce instead?
;; other recursion scheme?
#+end_src

This clip-ears algo doesn't work in all cases. For example, the shape:

[2 2] [12 2] [5 7] [12 12] [2 12]

incorrectly clips to these 3 triangles:

- [2 2] [12 2] [5 7] (this is ok)
- [2 2] [5 7] [12 12] (INVALID, line [2 2] [12 12] is outside original poly)
- [2 2] [12 12] [2 12] (INVALID, line [2 2] [2 12] is outisde original poly)

This is related to the fact that I don't check for angles at all.

Idea is that I can take any point to clip as long as its angle is less than 180 degrees. If it is greater, try next point, etc. Eventually, you can clip all ears away as remaining lines will eventually be less than 180 degrees.

My angles-from-pts fn needs to be changed because it will only report the smaller angle between lines. I need the angle from line 1 to line 2 even if it is > 180, otherwise I can't detect incorrect triangles.

#+begin_src clojure :tangle ./src/forge/geom.cljc
(defn clip-ears
  ([pts]
   (clip-ears pts []))
  
  ([pts acc]
   (let [spts (simplify-segments pts)
         tris (->> (cycle spts)
                   (partition 3 1)
                   (take (count spts))
                   (filter #(apply acute? %))
                   (mapv #(into [] %)))
         tri (first (for [tri tris]
                      (let [xpts (remove (into #{} tri) (into #{} spts))
                            clear (= 0 (count (filter #(pt-inside-convex? tri %) xpts)))]
                        (when clear tri))))
         npts (if tri 
                (->> spts
                     (filter (complement #{(second tri)}))
                     (into []))
                (->> spts
                     (cycle)
                     (drop 1)
                     (take (count spts))
                     (into [])))
         acc (if tri (conj acc tri) acc)]
     (if (> (count npts) 2)
       (recur npts acc)
       acc))))

(defn pt-inside?
  [pts pt]
  (let [tris (clip-ears pts)]
    (->> tris
         (map #(pt-inside-convex? % pt))
         (filter true?)
         (empty?)
         (not))))

#+end_src

- get intersectin points of polygons
- if zero, done if one, done, else, continue
- remove pgb points that are inside pga
- remove pga points that are inside pgb
- trim pga lines to intersectin points
- trim pgb lines to intersection points
- combine pga pts, intersectin points, and pgb points
  - order matters... not sure how to preserve that yet.

#+begin_src clojure :tangle ./src/forge/geom.cljc
(defn trim
  "Trim line a using line b."
  [la lb]
  (let [x (line-segment-intersection la lb)]
    (when x
      [[(first la) x]
       [x (second la)]])))

(defn trim-at-pt
  [[a b] pt]
  (when (and
         (not= a pt)
         (not= b pt)
         (utils/on-line? (utils/add-z (mapv float pt)) (mapv utils/add-z [a b])))
    [[a pt]
     [pt b]]))

(defn trim-at-pts
  [[a b] pts]
  (let [pts (filter #(utils/on-line? % (mapv utils/add-z [a b])) (mapv utils/add-z pts))]
    (when (first pts)
      (->> pts
           (sort-by (partial utils/distance a))
           (mapv #(into [] (drop-last %)))
           (concat [a])
           (apply vector)
           (#(conj % b))
           (partition 2 1)
           (mapv vec)))))

#+end_src

- instead of creating lists of points, create lists of line segments that make each polygon

- for segments with intersections, just trim them and only keep the trimmed parts

- flatten the list of all these segments together

- then, remove all segments that lie inside either of the originals

- re-order the line list by 'chaining' (reverse of (partition 2 1))...

- map drop-last over list of lines... should give a correct ordering of pts

#+begin_src clojure :tangle ./src/forge/geom.cljc
(defn polygon->lines 
  [pg]
  (->> pg
       (cycle)
       (take (inc (count pg)))
       (partition 2 1)))

(defn endpoint?
  [l pt]
  (or (= (first l) pt)
      (= (second l) pt)))

(defn on-perimeter?
  [pg pt]
  (let [pt (utils/add-z pt)
        pg (mapv utils/add-z pg)
        lines (polygon->lines pg)]
    (> (count (filter (partial utils/on-line? pt) lines)) 0)))

(defn order-lines
  ([lines]
   (let [start (first (sort-by (comp second first) lines))]
     (order-lines lines start [start])))

  ([lines [_ b] sorted]
   (let [next (first (filter #(= b (first %)) lines))]
     (if (= (count lines) (count sorted))
       (mapv first sorted)
       (recur lines next (conj sorted next))))))
#+end_src

*** polygon-union
#+begin_src clojure :tangle ./src/forge/geom.cljc
(defn polygon-union
  [pga pgb]
  (let [xs (polygon-intersection pga pgb)
        ;; trim lines at intersection points
        ls (apply concat 
                  (for [l (mapv vec (mapcat polygon->lines [pga pgb]))]
                    (let [trims (->> #_(map #(trim-at-pts l [%]) xs)
                                     [(trim-at-pts l xs)]
                                     (filter #(not (nil? %))))]
                      (if (> (count trims) 0)
                        (apply concat trims)
                        [l]))))
        ;; remove degenerate lines (= pta ptb)
        ls (filter #(not (= (first %) (second %))) ls)
        ;; get lines that are not in polygon a
        a (filter #(not (pt-inside? pga (midpoint %))) ls)
        ;; get lines that are not in polygon b
        b (filter #(not (pt-inside? pgb (midpoint %))) ls)
        ;; get lines with midpoints on both perimeters
        c (filter #(and (on-perimeter? pga (midpoint %))
                        (on-perimeter? pgb (midpoint %))) ls)]
    (->> (concat a b c)
         (filter (complement nil?))
         (into #{})
         (order-lines))))

#+end_src

*** polygon-difference
#+begin_src clojure :tangle ./src/forge/geom.cljc
(defn polygon-difference
  "Polygon B Cuts Polygon A"
  [pga pgb]
  (let [xs (polygon-intersection pga pgb)
        ;; trim lines at intersection points
        ls (apply concat 
                  (for [l (mapv vec (mapcat polygon->lines [pga pgb]))]
                    (let [trims (->> #_(map #(trim-at-pts l [%]) xs)
                                     [(trim-at-pts l xs)]
                                     (filter #(not (nil? %))))]
                      (if (> (count trims) 0)
                        (apply concat trims)
                        [l]))))
        ;; remove degenerate lines (= pta ptb)
        ls (filter #(not (= (first %) (second %))) ls)
        ;; get lines that are in polygon a
        a (filter #(pt-inside? pga (midpoint %)) ls)
        ;; get lines that are in polygon b
        b (filter #(pt-inside? pgb (midpoint %)) ls)
        ;; get lines with midpoints on both perimeters
        c (filter #(and (on-perimeter? pga (midpoint %))
                        (on-perimeter? pgb (midpoint %))) ls)]
    (->> (concat a b c)
         (filter (complement nil?))
         (into #{})
         (order-lines))))

#+end_src

- there are cases where a segment has >1 intersection point along itself. Currently, it gets 'passed over' once a single trim has occurred on it. Technically, need some sort of iteration or recursion over this so that new trimmed segments are also checked for trims with other intersections

- perform trim on list of line segments. Iterate. When prev.list = latest list, stop iteration (this means all trims are complete)


- maikerusan123 suggests create a fn that will trim a line into any N segments given any N pts along it (basically, upgrade trim-at-pt to trim-at-pts)

** offset
#+begin_src clojure :tangle ./src/forge/geom.cljc
(defn offset-edge
  [[a b] d]
  (let [p (utils/perpendicular-2d (utils/v- b a))
        pd (utils/v* (utils/normalize p) (repeat (- d)))
        xa (utils/v+ a pd)
        xb (utils/v+ b pd)]
    [xa xb]))

(defn cycle-pairs
  [pts]
  (let [n (count pts)]
    (vec (take n (partition 2 1 (cycle pts))))))

(defn every-other
  [v]
  (let [n (count v)]
    (map #(get v %) (filter even? (range n)))))

(defn wrap-list-once
  [s]
  (conj (drop-last s) (last s)))

(defn offset
  [pts d]
  (let [edges (cycle-pairs pts)
        opts (mapcat #(offset-edge % d) edges)
        oedges (every-other (cycle-pairs opts))
        edge-pairs (cycle-pairs oedges)]
    (wrap-list-once (map #(apply line-intersection %) edge-pairs))))

#+end_src
* delaunay
This is (for now) a copy from:

 https://github.com/trystan/delaunay-triangulation

 I have to change this to work on 3D points. It currently drops any Z values.

#+BEGIN_SRC clojure :tangle ./src/forge/delaunay.cljc
(ns forge.delaunay
  (:require [clojure.set]))

;; move these to geom ns?
(def abs #?(:clj #(Math/abs %)
            :cljs #(js/Math.abs %)))

(def pow #?(:clj #(Math/pow %1 %2)
            :cljs #(Math/pow %1 %2)))


(defn rand-int-pt
  ([n]
   (rand-int-pt n n))

  ([nx ny]
   [(rand-int nx) (rand-int ny)]))

(defn random-points
  ([n]
   (random-points n n))

  ([nx ny]
   (repeatedly #(rand-int-pt nx ny))))

(defn grid-points
  [cell-x cell-y n-xcells n-ycells]
  (for [nx (range n-xcells)
        ny (range n-ycells)]
    [(* cell-x nx) (* cell-y ny)]))

;; https://gist.github.com/mutoo/5617691
(defn circumscribe-triangle [[[ax ay] [bx by] [cx cy]]]
  (let [A (- bx ax)
        B (- by ay)
        C (- cx ax)
        D (- cy ay)
        E (+ (* A (+ ax bx)) (* B (+ ay by)))
        F (+ (* C (+ ax cx)) (* D (+ ay cy)))
        G (* 2 (- (* A (- cy by)) (* B (- cx bx))))]
    (when (> (abs G) 0.000001)
      (let [cx (/ (- (* D E) (* B F)) G)
            cy (/ (- (* A F) (* C E)) G)
            dx (- cx ax)
            dy (- cy ay)
            r  (+ (pow dx 2) (pow dy 2))]
        {:x cx :y cy :radius-squared r}))))

(defn edges [[p1 p2 p3]] [[p1 p2] [p2 p3] [p3 p1]])

(defn contains-point? [{:keys [x y radius-squared]} [px py]]
  (let [distance-squared (+ (pow (- x px) 2) (pow (- y py) 2))]
    (< distance-squared radius-squared)))

(defn outer-edges [triangles]
  (let [all-edges    (mapcat edges triangles)
        matches      (fn [edge] (filter #{edge (reverse edge)} all-edges))
        appears-once (fn [edge] (= (count (matches edge)) 1))]
    (filter appears-once all-edges)))

(defn make-new-triangles [containers point]
  (->> containers
       outer-edges
       (map (fn [[p1 p2]] [p1 p2 point]))
       set))

(defn add-point-to-triangles [triangles point]
  (let [containers    (filter #(contains-point? (circumscribe-triangle %) point) triangles)
        new-triangles (make-new-triangles containers point)]
    (clojure.set/union (clojure.set/difference triangles containers) new-triangles)))

(defn bounds [points]
  (let [minx (->> points (map first) (apply min) (+ -1000))
        maxx (->> points (map first) (apply max) (+ 1000))
        miny (->> points (map second) (apply min) (+ -1000))
        maxy (->> points (map second) (apply max) (+ 1000))]
    [[minx maxy] [maxx maxy] [minx miny] [maxx miny]]))

;; http://paulbourke.net/papers/triangulate/
(defn triangulate [points]
  (let [points (map (fn [[x y]] [(float x) (float y)]) points)
        [tl tr bl br] (bounds points)
        initial #{[tl tr bl] [bl tr br]}
        with-bounds (reduce add-point-to-triangles initial points)
        triangles (remove #(some #{tl tr bl br} %) with-bounds)]
    {:points points
     :triangles triangles
     :edges (distinct (mapcat edges triangles))}))

#+END_SRC
* frep
** ns
#+begin_src clojure :tangle ./src/forge/frep.cljc
(ns forge.frep
  (:require [clojure.core.matrix :as m]
            [clojure.core.matrix.operators :as mo]
            [com.climate.claypoole :as cp]
            [forge.utils :as utils]
            [forge.geom :as geom]
            [forge.delaunay :as delaunay]
            [svg-clj.elements :as svg]
            [svg-clj.transforms :as tf]
            [svg-clj.tools :as tools]
            [clojure.string :as str]
            [same :refer [ish? zeroish?]]))

#+end_src

** union
#+BEGIN_SRC clojure :tangle ./src/forge/frep.cljc
(defn union [f g]
  (fn [pt]
    (let [a (f pt)
          b (g pt)]
      (min a b))))

#+END_SRC

** difference
#+BEGIN_SRC clojure :tangle ./src/forge/frep.cljc
(defn difference [f g]
  (fn [pt]
    (let [a (f pt)
          b (* -1 (g pt))]
      (max a b))))

#+END_SRC

** intersection
#+BEGIN_SRC clojure :tangle ./src/forge/frep.cljc
(defn intersection [f g]
  (fn [pt]
    (let [a (f pt)
          b (g pt)]
      (max a b))))

#+END_SRC

** pt
#+BEGIN_SRC clojure :tangle ./src/forge/frep.cljc
(defn pt
  ([x y]
   (fn [pt]
     (utils/distance [x y] pt)))
  ([x y z]
   (fn [pt]
     (utils/distance [x y z] pt))))

#+END_SRC

** line
#+BEGIN_SRC clojure :tangle ./src/forge/frep.cljc
(defn line
  [a b]
  (fn [pt]
    (let [pa (utils/v- pt a)
          ba (utils/v- b a)
          h (utils/clamp (/ (utils/dot* pa ba) (utils/dot* ba ba)) 0 1)]
      (utils/distance (utils/v- pa (utils/v* ba (repeat h))) [0 0 0]))))

#+END_SRC

** polyline
#+BEGIN_SRC clojure :tangle ./src/forge/frep.cljc
(defn polyline
  [pts]
  (let [lines (->> (partition 2 1 pts)
                   (map #(apply line %)))]
    (reduce union lines)))

#+END_SRC

** triangle
[[https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm]]

#+BEGIN_SRC clojure :tangle ./src/forge/frep.cljc
(defn triangle
  [a b c]
  (fn [pt]
    (let [[e0 e1 e2] (map #(apply utils/v- %) [[b a] [c b] [a c]])
          [v0 v1 v2] (map (partial utils/v- pt) [a b c])
          xf (fn [v e] 
               (utils/v- v (map * e (repeat (utils/clamp (/ (utils/dot* v e) (utils/dot* e e)) 0 1)))))
          [pq0 pq1 pq2] (map #(apply xf %) [[v0 e0] [v1 e1] [v2 e2]])
          s (utils/sign (- (* (first e0) (second e2)) (* (second e0) (first e2))))
          d1 (min (utils/dot* pq0 pq0)
                  (utils/dot* pq1 pq1)
                  (utils/dot* pq2 pq2))
          d2 (min (* s (- (* (first v0) (second e0)) (* (second v0) (first e0))))
                  (* s (- (* (first v1) (second e1)) (* (second v1) (first e1))))
                  (* s (- (* (first v2) (second e2)) (* (second v2) (first e2)))))]
      (* -1 (Math/sqrt d1) (utils/sign d2)))))

#+END_SRC

** rect
#+BEGIN_SRC clojure :tangle ./src/forge/frep.cljc
(defn rect
  [l w]
  (let [b [(/ l 2.0) (/ w 2.0)]]
    (fn [pt]
      (let [abs-pt (mapv #(Math/abs ^long %) pt)  
            d (utils/v- abs-pt b)]
        (+ (utils/distance (mapv #(max % 0) d) (repeat 0))
           (min (apply max d) 0))))))

#+END_SRC

** circle
#+BEGIN_SRC clojure :tangle ./src/forge/frep.cljc
(defn circle
  [r]
  (fn [pt]
    (- (utils/distance pt (repeat 0)) r)))

#+END_SRC

** polygon
My frep-polygon uses a triangulation/union approach. This did break for me in some cases, so I am going to test an alternate implementation. I will port this code:


https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm  (go to polygon - exact section)
https://www.shadertoy.com/view/wdBXRW


Every polygon function must work on & paths, not just a single list of points. This is to allow multi-shape paths (eg. a circle with a hole.)

As well, any polygon union should effectively produce the same polygon that would result from providing each path into one polygon call. That is...

(= (union (polygon pts-a) (polygon pts-b)) (polygon pts-a pts-b))


#+begin_src c

float sdPolygon( in vec2[N] v, in vec2 p )

{
    float d = dot(p-v[0],p-v[0]);
    float s = 1.0;

    for( int i=0, j=N-1; i<N; j=i, i++ )
    {
        vec2 e = v[j] - v[i];
        vec2 w =    p - v[i];
        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );
        d = min( d, dot(b,b) );

        bvec3 c = bvec3(p.y >= v[i].y,
                        p.y < v[j].y,
                        e.x * w.y > e.y * w.x);
        if( all(c) || all(not(c)) ) s*=-1.0;  
    }
    return s*sqrt(d);
}

#+end_src


alt conditional for checkign c

(or (every? identity c) (every? not c))


#+BEGIN_SRC clojure :tangle ./src/forge/frep.cljc









(defn polygon
  [pts]
  (let [tris (map #(apply triangle %) (geom/clip-ears pts))] 
    (reduce union tris)))












(defn polygon
  [pts]
  (fn [[px py :as pt]]
    (let [pts (vec pts)
          n (count pts)
          d1 (utils/dot* (utils/v- pt (first pts))
                           (utils/v- pt (first pts)))]
      (loop [i 0
             j (dec n)
             d d1
             s 1]
        (if (< i n)
          (let [[vix viy :as vi] (get pts i)
                [vjx vjy :as vj] (get pts j)
                [ex ey :as e] (utils/v- vj vi)
                [wx wy :as w] (utils/v- pt vi)
                [bx by :as b] (utils/v-
                               w
                               (mapv #(* % (utils/clamp 
                                            (/ (utils/dot* w e)
                                               (utils/dot* e e)) 0.0 1.0)) e))
                d (min d (utils/dot* b b))
                c [(>= py viy)
                   ( < py vjy)
                   ( > (* ex wy) (* ey wx))]
                s (if (= (count (into #{} c)) 1) (* s -1) (* s 1))]
            (recur (inc i) i d s))
          (* s (Math/sqrt d)))))))












#+END_SRC

** sphere
#+BEGIN_SRC clojure :tangle ./src/forge/frep.cljc
(defn sphere
  [r]
  (fn [pt]
    (- (utils/distance pt [0 0 0]) r)))

#+END_SRC

** cylinder
#+BEGIN_SRC clojure :tangle ./src/forge/frep.cljc
(defn cylinder [r h]
  (fn [pt]
    (let [[x y z] pt]
      (max (- (Math/sqrt (+ (utils/sq x) (utils/sq y))) r)
           (- z (/ h 2)) (- (/ h -2) z)))))

#+END_SRC

** box
#+BEGIN_SRC clojure :tangle ./src/forge/frep.cljc
(defn box [l w h]
  (fn [pt]
    (let [[x y z] pt
          [lh wh hh] (map #(/ % 2) [l w h])]
      (max (- x lh) (- (- lh) x)
           (- y wh) (- (- wh) y)
           (- z hh) (- (- hh) z)))))

#+END_SRC

** extrude
#+BEGIN_SRC clojure :tangle ./src/forge/frep.cljc
(defn extrude
  [frep h]
  (fn [pt]
    (let [d (frep (drop-last pt))
          w (- (Math/abs ^long (- (last pt) (/ h 2))) (/ h 2))]
      (+ (min (max d w) 0)
         (utils/distance [0 0] [(max d 0) (max w 0)])))))

#+END_SRC

** revolve
#+BEGIN_SRC clojure :tangle ./src/forge/frep.cljc
(defn revolve
  [f]
  (fn [pt]
    (let [q [(utils/distance [0 0] [(first pt) (second pt)])
             (last pt)]]
      (f q))))

#+END_SRC

** translate
#+BEGIN_SRC clojure :tangle ./src/forge/frep.cljc
(defn translate
  [f pos]
  (fn [pt]
    (f (utils/v+ pt pos))))

#+END_SRC

** rotate
#+BEGIN_SRC clojure :tangle ./src/forge/frep.cljc
(defn rotate
  [f angles]
  (fn [pt]
    (f (utils/rotate-point pt angles))))

#+END_SRC

** scale
#+BEGIN_SRC clojure :tangle ./src/forge/frep.cljc
(defn scale
  [f scales]
  (fn [pt]
    (f (utils/v* pt scales))))

#+END_SRC

** tools
- tried pcalls and it has similar performance to the pmap approach in prep-fn-grid.

- a hexagon of radius 50 takes about 6seconds to render (2d). this is still too slow... so I haven't moved to making a fast 3D renderer yet.

#+begin_src clojure :tangle ./src/forge/frep.cljc
(defn prep-fn-grid
  [x1 y1 x2 y2 f]
  (let [pts (for [x (range x1 (inc x2))
                  y (range y1 (inc y2))] [x y])]
    (cp/pmap 10 #(vector % (f %)) pts)))

(defn render-pt
  [[pt dist]]
  (let [dist (utils/round dist 4)
        r 1
        a (utils/round 
           (- 1 (Math/abs ^double (/ (utils/clamp dist (- r) r) r))) 3)]
    (when (< -1000000 dist r)
      (svg/g 
       (-> (svg/rect 1 1)
           (tf/translate [0.5 0.5])
           (tf/translate pt)
           (tf/style {:fill (if (< dist 0)
                              "slategray"
                              "none")
                      :opacity 1 #_(if (< dist (- r)) 1 a)}))
       (-> (svg/rect 1 1)
           (tf/translate [0.5 0.5])
           (tf/translate pt)
           (tf/style {:fill (if (> dist (- r))
                              "#ffeeff"
                              "none")
                      :opacity a}))))))

(defn prep-fn-grid6
  [x1 y1 x2 y2 f]
  (cp/pfor 10 [x (range x1 (inc x2))
               y (range y1 (inc y2))]
           (render-pt [[x y] (f [x y])])))

(defn cider-show6
  [frep]
  (let [render (remove nil? (prep-fn-grid6 -200 -200 200 200 frep))]
    (when (not (empty? render))
      (svg-clj.tools/cider-show render))))

(defn cider-show
  [frep]
  (let [grid (prep-fn-grid -200 -200 200 200 frep)
        render (remove nil? (cp/pmap 10 render-pt grid))]
    (when (not (empty? render))
      (svg-clj.tools/cider-show render))))

(defn idx-grid
  [x1 y1 x2 y2]
  (m/array :ndarray
   (for [x (range x1 x2)]
     (for [y (range y1 y2)]
       {:x x :y y}))))

(defn array-frep
  [frep]
  (fn [pt _]
    (frep pt)))

(defn render-pt2
  [pt dist]
  (let [dist (utils/round dist 4)
        r 10
        a (utils/round 
           (- 1 (Math/abs ^double (/ (utils/clamp dist (- r) r) r))) 3)]
    (when (< -1000000 dist r)
      {:result
      (svg/g 
       (-> (svg/rect 1 1)
           (tf/translate [0.5 0.5])
           (tf/translate pt)
           (tf/style {:fill (if (< dist 0)
                              "slategray"
                              "none")
                      :opacity 1 #_(if (< dist (- r)) 1 a)}))
       (-> (svg/rect 1 1)
           (tf/translate [0.5 0.5])
           (tf/translate pt)
           (tf/style {:fill (if (> dist (- r))
                              "#ffeeff"
                              "none")
                      :opacity a})))})))

(defn render-pt3
  [frep pt dist]
  (let [dist (utils/round (frep pt) 4)
        r 10
        a (utils/round 
           (- 1 (Math/abs ^double (/ (utils/clamp dist (- r) r) r))) 3)]
    (when (< -1000000 dist r)
      {:result
      (svg/g 
       (-> (svg/rect 1 1)
           (tf/translate [0.5 0.5])
           (tf/translate pt)
           (tf/style {:fill (if (< dist 0)
                              "slategray"
                              "none")
                      :opacity 1 #_(if (< dist (- r)) 1 a)}))
       (-> (svg/rect 1 1)
           (tf/translate [0.5 0.5])
           (tf/translate pt)
           (tf/style {:fill (if (> dist (- r))
                              "#ffeeff"
                              "none")
                      :opacity a})))})))

(defn cider-show2
  [frep]
  (let [pixels (m/new-array :ndarray [400 400])]
    (do (m/emap-indexed! (array-frep (translate frep [-200 -200])) pixels)
        (m/emap-indexed! render-pt2 pixels)
        (let [spixels (pmap :result (filter some? (apply concat pixels)))]
          (when (not (empty? spixels))
            (svg-clj.tools/cider-show spixels))))))

(defn cider-show3
  [frep]
  (let [pixels (m/new-array :ndarray [400 400])
        f (translate frep [-200 -200])
        spixels (->> pixels
                     (m/emap-indexed (array-frep f))
                     (m/emap-indexed render-pt2)
                     (apply concat)
                     (filter some?)
                     (pmap :result))]
    (when (not (empty? spixels))
      (svg-clj.tools/cider-show spixels))))

(defn cider-show4
  [frep]
  (let [frep (translate frep [-200 -200])
        pixels (m/new-array :ndarray [400 400])]
    (do (m/emap-indexed! (partial render-pt3 frep) pixels)
        (let [spixels (pmap :result (filter some? (apply concat pixels)))]
          (when (not (empty? spixels))
            (svg-clj.tools/cider-show spixels))))))

(defn render-pt5
  [f pt]
  (let [dist (utils/round (f pt) 4)
        r 10
        a (utils/round 
           (- 1 (Math/abs ^double (/ (utils/clamp dist (- r) r) r))) 3)]
    (when (< -1000000 dist r)
      (svg/g 
       (-> (svg/rect 1 1)
           (tf/translate [0.5 0.5])
           (tf/translate pt)
           (tf/style {:fill (if (< dist 0)
                              "slategray"
                              "none")
                      :opacity 1 #_(if (< dist (- r)) 1 a)}))
       (-> (svg/rect 1 1)
           (tf/translate [0.5 0.5])
           (tf/translate pt)
           (tf/style {:fill (if (> dist (- r))
                              "#ffeeff"
                              "none")
                      :opacity a}))))))

(defn render5
  [w h frep render-fn]
  (let [xf (partial render-fn (translate frep [(/ w -2.0) (/ h -2.0)]))
        pts (for [x (range w)
                  y (range h)] [x y])]
    (doall (pmap xf pts))))

(defn cider-show5
  [frep]
  (let [render (filter some? (render5 400 400 frep render-pt5))]
    (when (not (empty? render))
      (svg-clj.tools/cider-show render))))

#+end_src


#+begin_src clojure :tangle ./src/forge/frep.cljc
(def iso-euler-angles [35.264 45 0])
(def origin-angle-adjust-a [90 0 0])
(def origin-angle-adjust-b [0 -90 0])

(defn isometric-xf
  [frep]
  (-> frep
      #_(rotate origin-angle-adjust-b)
      #_(rotate origin-angle-adjust-a)
      (rotate iso-euler-angles)
      (rotate [0 0 45])))

(defn cider-show-3d
  [frep]
  (let [frep (isometric-xf frep)
        render
        (filter 
         some?
         (for [x (range -200 201 1)
               y (range -200 201 1)
               z (range -200 201 1)]
           (let [r 0.5
                 pt [x y z]
                 dist (frep pt)
                 a (utils/round 
                    (- 1 (/ (utils/clamp dist 0 r) r)) 3)]
             (when (< (- r) dist r)
               (-> (svg/rect 1 1)
                   (tf/translate [0.5 0.5])
                   (tf/translate (drop-last pt))
                   (tf/style {:fill (if (> dist 0)
                                      "hotpink"
                                      "skyblue")
                              :opacity (if (< dist 0) 1 a)}))))))]
    (when (not (empty? render))
      (svg-clj.tools/cider-show render))))

(defn slice
  [frep z]
  (fn [pt]
    (frep (conj pt z))))

(def a (-> (utils/regular-polygon-pts 80 8)
           (polygon)))

(def b (-> a
           (extrude 100)))
#+end_src


#+begin_src clojure :tangle ./src/forge/frep.cljc
(defn march
  [f [x y]]
  (let [frep (isometric-xf f)
        from (conj [x y] -200)
        dir [0 0 1]
        max-steps 50
        min-dist 0.0001]
    (loop [n-steps 0
           total-dist 0]
      (let [pt (utils/v+ from [0 0 total-dist])
            d (utils/round (frep pt) 4)]
        (if (or (> n-steps max-steps)
                (< d min-dist))
          (- 1.0 (/ n-steps max-steps))
          (recur (inc n-steps) (+ total-dist d)))))))

(defn render-pixel
  [[pt a]]
  (when (> a 0.0001)
    (-> (svg/rect 1 1)
        (tf/translate [0.5 0.5])
        (tf/translate pt)
        (tf/style {:fill "slategray"
                   :opacity a}))))

(defn render-frep
  [x1 y1 x2 y2 f]
  (cp/pfor 10 [x (range x1 (inc x2))
               y (range y1 (inc y2))]
           (render-pixel [[x y] (f [x y])])))

(defn cider-show-3d
  [frep]
  (let [f (partial march frep)
        render (remove nil? (render-frep -200 -200 200 200 f))]
    (when (not (empty? render))
      (svg-clj.tools/cider-show render))))

(def asdf
  (let [base (box 200 200 200)]
    (-> (difference
         (box 80 80 80)
         (sphere 50))
        (rotate [0 0 85]))))

#+end_src

* brep
** ns
#+begin_src clojure :tangle ./src/forge/brep.cljc
(ns forge.brep
  (:require [forge.utils :as utils]
            [forge.geom :as geom]
            [forge.delaunay :as delaunay]
            [clojure.string :as str]
            [same :refer [ish? zeroish?]]))

#+end_src
** utils
#+begin_src clojure :tangle ./src/forge/brep.cljc
(defn remap-within
  [f [start end] x]
  (when (and (>= x start) (< x end))
    (let [step (- end start)
          t (/ (- x start) step)]
      (f t))))

#+end_src

** line
#+BEGIN_SRC clojure :tangle ./src/forge/brep.cljc
(defn line
  [a b]
  (fn [t]
    (cond
      (= t :tag) :line
      (= (float t) 0.0) a
      (= (float t) 1.0) b
      :else
      (utils/v+ a (utils/v* (utils/v- b a) (repeat t))))))

#+END_SRC

** polyline
#+BEGIN_SRC clojure :tangle ./src/forge/brep.cljc
(defn polyline
  [pts]
  (let [step (/ 1.0 (dec (count pts)))
        intervals (partition 2 1 (range 0 (+ 1 step) step))
        lines (map (partial apply line) (partition 2 1 pts))]
    (fn [t]
      (cond 
        (= t :tag) :polyline
        (= (float t) 0.0) (first pts)
        (= (float t) 1.0) (last pts)
        :else
        (first (filter some?
                       (map #(remap-within %1 %2 t) lines intervals)))))))

#+END_SRC

** circle
#+BEGIN_SRC clojure :tangle ./src/forge/brep.cljc
;;https://mathforum.org/library/drmath/view/63755.html
(defn curve-circle
  [a b c]
  (let [n (utils/normalize (utils/normal a b c))
        r (utils/radius-from-pts a b c)
        cp (utils/center-from-pts a b c)
        u (utils/normalize (mapv - a cp))
        v (utils/cross* n u)]
    (fn [t]
      (cond
        (= t :tag) :circle
        (or (< t 0.0) (> t 1.0)) nil
        (= (float t) 0.0) a
        (= (float t) 1.0) a
        :else
        (let [t (* 2 Math/PI t)]
          (utils/v+ cp
              (utils/v* (repeat (* r (Math/cos t))) u)
              (utils/v* (repeat (* r (Math/sin t))) v)))))))

(defn surface-circle
  [a b c]
  (let [cp (utils/center-from-pts a b c)
        c1 (curve-circle a b c)]
    (fn [u v]
      (let [c2 (line cp (c1 u))]
        (c2 v)))))

#+END_SRC

** ellipse
#+BEGIN_SRC clojure :tangle ./src/forge/brep.cljc
(defn curve-ellipse
  [rx ry]
  (fn [t]
    (let [t (* 2 Math/PI t)
          x (* rx (Math/cos t))
          y (* ry (Math/sin t))]
      [x y])))

#+END_SRC

** arc
There are 2 angle-from-pts functions. They don't both work here, even though I think they should... angle-from-pts2 causes this function to nil out in many cases.

angle-from-pts only reports the small angle no matter what, so that isn't always going to produce the correct arc.

#+BEGIN_SRC clojure :tangle ./src/forge/brep.cljc
(defn curve-arc
  [a b c]
  (let [f (curve-circle a b c)
        cp (utils/center-from-pts a b c)
        angle (utils/angle-from-pts a cp c)]
    (fn [t]
      (let [t (* t (/ angle 360.0))]
        (f t)))))

#+END_SRC

** polygon
My frep-polygon uses a triangulation/union approach. This did break for me in some cases, so I am going to test an alternate implementation. I will port this code:


https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm  (go to polygon - exact section)
https://www.shadertoy.com/view/wdBXRW


Every polygon function must work on & paths, not just a single list of points. This is to allow multi-shape paths (eg. a circle with a hole.)

As well, any polygon union should effectively produce the same polygon that would result from providing each path into one polygon call. That is...

(= (union (polygon pts-a) (polygon pts-b)) (polygon pts-a pts-b))

#+BEGIN_SRC clojure :tangle ./src/forge/brep.cljc
(defn curve-polygon
  [pts]
  (polyline (conj (vec pts) (first pts))))

#+END_SRC

** bezier
Eventually I want to generalize bezier fn to take any number of control points, but for the time being it's easier to implement cubic/quadratic bezier curves, as they have simplified algorithms.

#+BEGIN_SRC clojure :tangle ./src/forge/brep.cljc
(defn- quadratic-bezier
  [a b c]
  (fn [t]
    (let [l1 (line a b)
          l2 (line b c)
          l3 (line (l1 t) (l2 t))]
      (l3 t))))

(defn bezier
  [pts]
  (if (= 3 (count pts))
    (apply quadratic-bezier pts)
    (let [lines (map #(apply line %) (partition 2 1 pts))] 
      (fn [t]
        (let [npts (map #(% t) lines)]
          ((bezier npts) t))))))

#+END_SRC

** triangle
[[https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm]]

#+BEGIN_SRC clojure :tangle ./src/forge/brep.cljc
(defn surface-triangle
  [a b c]
  (let [l1 (line b a)
        l2 (line c a)]
    (fn [u v]
      (let [l3 (line (l1 v) (l2 v))]
        (l3 u)))))

#+END_SRC

** sphere
#+BEGIN_SRC clojure :tangle ./src/forge/brep.cljc
(defn sphere
  [r]
  (fn [u v]
    (let [[u v] (map #(* 2 Math/PI %) [u v])
          x (* r (Math/sin u) (Math/cos v))
          y (* r (Math/sin u) (Math/sin v))
          z (* r (Math/cos u))]
      [x y z])))

#+END_SRC

** torus
#+BEGIN_SRC clojure :tangle ./src/forge/brep.cljc
(defn surface-torus
  [R r]
  (fn [u v]
    (let [[u v] (map #(* 2 Math/PI %) [u v])
          x (* (+ R (* r (Math/cos u))) (Math/cos v))
          y (* (+ R (* r (Math/cos u))) (Math/sin v))
          z (* r (Math/sin u))]
      [x y z])))

#+END_SRC

** cylinder
#+BEGIN_SRC clojure :tangle ./src/forge/brep.cljc
(defn surface-cylinder
  [r h]
  (fn [u v]
    (let [u (* 2 Math/PI u)
          v (* h v)
          x (* r (Math/cos u))
          y (* r (Math/sin u))
          z v]
      [x y z])))

#+END_SRC

** translate
#+BEGIN_SRC clojure :tangle ./src/forge/brep.cljc
(defn translate
  [f pos]
  (comp #(utils/v+ pos %) f))

#+END_SRC

** rotate
#+BEGIN_SRC clojure :tangle ./src/forge/brep.cljc
(defn brep-rotate
  [f angles]
  (comp #(utils/rotate-point % angles) f))

#+END_SRC

** scale
#+BEGIN_SRC clojure :tangle ./src/forge/brep.cljc
(defn scale
  [f scales]
  (comp #(utils/v* scales %) f))

#+END_SRC

** extrude
#+BEGIN_SRC clojure :tangle ./src/forge/brep.cljc
(defn curve-extrude
  [c h]
  (fn [u v]
    (let [c2 (line (c u) (utils/v+ (c u) [0 0 h]))]
      (c2 v))))

(defn surface-extrude
  [s h]
  (fn [u v w]
    (let [c1 (line (s u v) (utils/v+ (s u v) [0 0 h]))]
      c1 v)))

#+END_SRC
* model
The model is two concepts:

1. The tree
 - uses hiccup style structures [:tag {:props props} content]
 - follows similarly to what svg-clj does with its structure except it does not 'bake' transforms into the elements, but rather wraps them in the relevant tagged vector

2. The map
 - uses a map structure to represent everything about a single element
 - all transforms and combinations are 'baked' into the map so you have no history but you do have all the necessary parts to fully describe the current state of the mdoel.

You can always create a map from a tree, but you cannot guarantee that you can get the same tree from a map. It is one way and destructive. This is why you want to save both representations. 

It may be useful for some compile targets to have the ability to use both a tree and map approach. For example, turning sub-sections of a tree during traversal into a map representation to quickly get needed geometric data.

The map should have:
- BREP structure (collection of vertices, edges, faces, shells, solids)
- FREP structure (single fn taking [x y z] returning distance to surface of the whole object)

** ns
The namespace declaration.
#+begin_src clojure :tangle ./src/forge/model.cljc
(ns forge.model
  (:require [forge.utils :as utils]
            [forge.geom :as geom]
            [forge.brep :as brep]
            [forge.frep :as frep]))

#+end_src

** utils
#+begin_src clojure :tangle ./src/forge/model.cljc
(def pi Math/PI)
(def tau (* 2 pi))
#+end_src

** 2D
#+begin_src clojure :tangle ./src/forge/model.cljc
(defn pt
  ([x y]
   [:pt {:x x :y y}])
  ([x y z]
   [:pt {:x x :y y :z z}]))

(defn line
  [a b]
  [:line {:a a :b b}])

(defn polyline
  [pts]
  [:polyline {:pts pts}])

(defn rect
  [w h]
  [:rect {:w w :h h :center true}])

(defn circle
  [r]
  [:circle {:r r}])

(defn ellipse
  [rx ry]
  [:ellipse {:rx rx :ry ry}])

(defn polygon
  ([pts]
   [:polygon {:pts (vec pts) :paths [(vec (range (count pts)))]}])
  ([pts paths]
   [:polygon {:pts (vec pts) :paths paths}]))

(defn slice
  [elem z]
  [:slice {:z z} elem])

#+end_src

** 3D
#+begin_src clojure :tangle ./src/forge/model.cljc
(defn sphere
  [r]
  [:sphere {:r r}])

(defn box
  [x y z]
  [:box {:x x :y y :z z :center true}])

(defn cylinder
  ([r h]
   [:cylinder {:r r :h h :center true}])
  ([r1 r2 h]
   [:cylinder {:r1 r1 :r2 r2 :h h :center true}]))

(defn polyhedron
  [pts faces]
  [:polyhedron {:pts pts :faces faces}])

(defn extrude
  [elem h]
  [:extrude {:h h} elem])

(defn revolve
  [elem a]
  [:revolve {:a a} elem])

#+end_src

** boolean
#+begin_src clojure :tangle ./src/forge/model.cljc
(defn union
  [& elems]
  [:union {} elems])

(defn intersection
  [& elems]
  [:intersection {} elems])

(defn difference
  [& elems]
  [:difference {} elems])

#+end_src

** transforms
*** translate
#+begin_src clojure :tangle ./src/forge/model.cljc
(defn translate
  [elem [x y z]]
  [:translate {:x x :y y :z z} elem])

#+end_src

*** rotate
#+begin_src clojure :tangle ./src/forge/model.cljc
(defn rotate
  ([elem [x y z]]
   [:rotate {:x x :y y :z z} elem])

  ([elem a [x y z]]
   [:rotate {:a a :x x :y y :z z} elem]))

#+end_src

*** scale
#+begin_src clojure :tangle ./src/forge/model.cljc
(defn scale
  [elem [x y z]]
  [:scale {:x x :y y :z z} elem])

#+end_src

*** style
#+begin_src clojure :tangle ./src/forge/model.cljc
(defn style
  [[k props & content] style-map]
  (into [k (merge props style-map)] content))

#+end_src

*** group
#+begin_src clojure :tangle ./src/forge/model.cljc
(defn group
  [& elems]
  [:group {} elems])

#+end_src

*** mirror
#+begin_src clojure :tangle ./src/forge/model.cljc
(defn mirror
  [elem [x y z]]
  [:mirror {:x x :y y :z z} elem])

#+end_src

*** color
#+begin_src clojure :tangle ./src/forge/model.cljc
(defn color
  [elem [r g b a]]
  [:color {:r r :g g :b b :a a} elem])

#+end_src

*** hull
#+begin_src clojure :tangle ./src/forge/model.cljc
(defn hull
  [elem]
  [:hull {} elem])

#+end_src

*** offset
#+begin_src clojure :tangle ./src/forge/model.cljc
(defn offset
  [elem d]
  [:offset {:d d} elem])

#+end_src

*** minkowski
#+begin_src clojure :tangle ./src/forge/model.cljc
(defn minkowski
  [& elems]
  [:minkowski {} elems])

#+end_src

*** multmatrix
#+begin_src clojure :tangle ./src/forge/model.cljc
(defn multmatrix
  [elem mtx]
  [:multmatrix {:mtx mtx} elem])

#+end_src

** fig
Forge Internal Geometry

keys:
 - frep
 - brep
   - vertices
   - curves
   - faces
   - surfaces
   - shells
   - solids
 - tree


#+begin_src clojure :tangle ./src/forge/model.cljc
;; multimethod
(defmulti fig
  (fn [element]
    (if (keyword? (first element)) (first element) :list)))

(defmethod fig :list
  [[& elems]]
  (map fig elems))

(defmethod fig :pt [[_ {:keys [] :as props}]])
(defmethod fig :line [[_ {:keys [] :as props}]])
(defmethod fig :polyline [[_ {:keys [] :as props}]])
(defmethod fig :rect [[_ {:keys [] :as props}]])
(defmethod fig :circle [[_ {:keys [] :as props}]])
(defmethod fig :polygon [[_ {:keys [] :as props}]])
(defmethod fig :project [[_ {:keys [] :as props}]])

(defmethod fig :sphere [[_ {:keys [] :as props}]])
(defmethod fig :box [[_ {:keys [] :as props}]])
(defmethod fig :cylinder [[_ {:keys [] :as props}]])
(defmethod fig :polyhedron [[_ {:keys [] :as props}]])
(defmethod fig :extrude [[_ {:keys [] :as props}]])
(defmethod fig :revolve [[_ {:keys [] :as props}]])

(defmethod fig :union [[_ {:keys [] :as props}]])
(defmethod fig :intersection [[_ {:keys [] :as props}]])
(defmethod fig :difference [[_ {:keys [] :as props}]])

(defmethod fig :group [[_ {:keys [] :as props}]])
(defmethod fig :translate [[_ {:keys [] :as props}]])
(defmethod fig :rotate [[_ {:keys [] :as props}]])
(defmethod fig :scale [[_ {:keys [] :as props}]])

#+end_src

* importers
Use parsers to read-in various file types into the model representation.

Then, any number of file inputs can be used in the definition of an object.

For example, 2D drawings can be produced as SVG and read into forge and manipulated using Forge geom tools. Then, you can directly reference them in model creation and output a model to whatever compiler target you wish.

Likewise, you can also use native lang. files as modules in a design. So, if you have a multi file scad design, you can read each scad file in and trust that it is accurately represented with forge-model data and proceed as if it were built directly with forge.
** image
This is just copy pasted from scad-drawing project. The intent here is to have a tool that takes a png filename and gives a set of points/paths which can be used as the basis for sketch elements, and used in Forge models as if native fns had created the points/paths.

*** ns
#+begin_src clojure :tangle ./src/forge/import/image.clj
(ns forge.import.image
  (:require [clojure.java.shell :refer [sh]]
            [clojure.string :as str]
            [clojure.data.xml :as xml]
            [clojure.core :exclude [import]]
            [svg-clj.elements :as svg]
            [svg-clj.path :as path]
            [svg-clj.transforms :as tf]
            [svg-clj.utils :refer [s->v
                                   svg-str->elements]]
            [forge.model :as mdl]
            [forge.utils :as utils]))

#+end_src

*** img->svg
This part of the library has an external dependency on vtracer:

[[https://github.com/visioncortex/vtracer]]

#+begin_src clojure :tangle ./src/forge/import/image.clj
(defn img->str 
  [fname]
  "Ingest image file `fname` and transform it into a hiccup data structure."
  (let [new-fname (str (first (str/split fname #"\.")) ".svg")]
    (sh "vtracer" 
        "--mode" "polygon"
        "--colormode" "bw"
        "--segment_length" "3.5"
        "--input" fname
        "--output" new-fname)
    (let [svg-str (slurp new-fname)]
      (sh "rm" new-fname)
      (-> svg-str
          (str/replace #"<\?xml.+>" "")
          str/trim))))

(defn- closed?
  [path]
  (let [d (get-in path [1 :d])]
    (-> d
        str/trim
        str/upper-case
        (str/ends-with? "Z"))))

(defn re-center
  [seq]
  (let [group (svg/g seq)
        ctr (mapv float (tf/centroid group))]
    (->> seq
         (map #(tf/translate % (utils/v* [-1 -1] ctr))))))

#+end_src

*** svg->mdl
Methods for converting all SVG elements into equivalent forge model elements/transforms.

Elements being converted:
 - circle
 - ellipse
 - line
 - polygon
 - polyline
 - path
 - rect
 - g

#+begin_src clojure :tangle ./src/forge/import/image.clj
(defmulti svg->mdl
  (fn [element]
    (if (keyword? (first element))
      (first element)
      :list)))

(defn- clean-props
  [props]
  (let [removable [:cx :cy :transform :width :height :x :y :d :fill-rule]]
    (apply dissoc (concat [props] removable))))

(defn- parse-transform
  [tf-str]
  (let [xf (svg-clj.utils/str->xf-map tf-str)
        tr (:translate xf)
        rot (:rotate xf)
        angle (last rot)]
    [(fn [elem]
       (cond-> elem
         rot (mdl/rotate [0 0 angle])
         tr (mdl/translate tr)))
     xf]))

(defmethod svg->mdl :list
  [elems]
  (map svg->mdl elems))

(defmethod svg->mdl :default [_] nil)

(defmethod svg->mdl :circle
  [[_ {:keys [cx cy r] :as props}]]
  (let [xf-props (clean-props props)]
    (cond-> (mdl/circle r)
      true (mdl/style xf-props)
      (and (not= cx 0)
           (not= cy 0)) (mdl/translate [cx cy 0]))))

(defmethod svg->mdl :ellipse
  [[_ {:keys [cx cy rx ry] :as props}]]
  (let [xf-props (clean-props props)]
    (cond-> (mdl/ellipse rx ry)
      true (mdl/style xf-props)
      (and (not= cx 0)
           (not= cy 0)) (mdl/translate [cx cy 0]))))

(defmethod svg->mdl :line
  [[_ {:keys [x1 y1 x2 y2] :as props}]]
  (let [xf-props (clean-props props)]
    (-> (mdl/line [x1 y1 0] [x2 y2 0])
        (mdl/style xf-props))))

(defmethod svg->mdl :polyline
  [[_ {:keys [points] :as props}]]
  (let [xf-props (clean-props props)
        pts (->> points
                 s->v
                 (partition 2))]
    (-> (mdl/polyline pts)
        (mdl/style xf-props))))

(defmethod svg->mdl :polygon
  [[_ {:keys [points] :as props}]]
  (let [xf-props (clean-props props)
        pts (->> points
                 s->v
                 (partition 2))]
    (-> (mdl/polygon pts)
        (mdl/style xf-props))))

(defmethod svg->mdl :rect
  [[_ {:keys [width height x y transform] :as props}]]
  (let [[xf xf-map] (parse-transform transform)
        angle (last (get xf-map :rotate [0]))
        xf-props (clean-props props)
        pos (-> (utils/v+ [x y] [(/ width 2.0) (/ height 2.0)])
                (utils/rotate-point [0 0 angle]))]
    (-> (mdl/rect width height)
        xf
        (mdl/style xf-props)
        (mdl/translate (conj pos 0)))))

(defmethod svg->mdl :g
  [[_ props & elems]]
  (let [xf-props (clean-props props)]
    [:group xf-props (map svg->mdl elems)]))

(defn- bb-area
  [elem]
  (reduce * (tf/bb-dims elem)))

(defn path->pts
  [path-elem]
  (let [cmds (path/path-string->commands (get-in path-elem [1 :d]))]
    (into [] (filter some? (map :input cmds)))))

(defn- svg-path-elem->polygon
  [path-elem]
  (let [pgs (->> path-elem
                 tf/split-path 
                 (sort-by bb-area)
                 (map path->pts)
                 (map mdl/polygon)
                 reverse)]
    (if (> (count pgs) 1)
      (apply mdl/difference pgs)
      (first pgs))))

(defn- svg-path-elem->polyline2
  [path-elem]
  (let [pgs (->> path-elem
                 #_tf/split-path 
                 #_(sort-by bb-area)
                 path->pts
                 mdl/polyline)]
    pgs))

(defn- svg-path-elem->polyline
  [path-elem]
  (let [pgs (->> path-elem
                 tf/split-path 
                 (sort-by bb-area)
                 (map path->pts)
                 (map mdl/polyline)
                 reverse)]
    (if (> (count pgs) 1)
      (apply mdl/difference pgs)
      (first pgs))))

(defmethod svg->mdl :path
  [[_ props :as elem]]
  (let [xf-props (clean-props props)
        xf-elem elem (tf/decurve elem)]
    (-> (if (closed? elem)
          (svg-path-elem->polygon xf-elem)
          (svg-path-elem->polyline xf-elem))
        (mdl/style xf-props))))

#+end_src

*** import
#+begin_src clojure :tangle ./src/forge/import/image.clj
(defn line-drawing
  [fname & {:keys [r]}]
  (-> fname
      img->str
      svg-str->elements
      (->> (drop 2))
      re-center
      (->> (mapcat tf/split-path))
      (->> (map path->pts))
      (->> (map #(mdl/polyline %)))
      mdl/union))

(defn import-png
  [fname]
  (-> fname
      img->str
      svg-str->elements
      (->> (drop 2))
      re-center
      (->> (map svg-path-elem->polygon))
      mdl/union))

(defn import-svg
  [fname]
  (let [data (-> (slurp fname) svg-str->elements)
        elems (if (= :svg (first data)) (drop 2 data) data)]
    (->> elems
         (map svg->mdl)
         (filter some?))))

(defn import
  [fname]
  (let [fext (utils/ext fname)
        f (get {"svg" import-svg
                "png" import-png} fext)]
    (f fname)))

#+end_src

[[./_tmp.svg]]

* compiler
A collection of methods for exporting models.

** scad
This is based off of Matthew Farrell's work on scad-clj. The code is modified in the following ways:

- uses some different names
  - cube -> box
  - extrude-linear -> extrude
  - extrude-rotate -> revolve

- uses vectors instead of lists (more hiccup-like) as the expr data structure

- some scad specifics are removed. This is to have 1-1 language for all compilation targets
  - fn! is not used because it does not have an equivalent in FreeCAD, SolidWorks, etc.

*** ns
#+begin_src clojure :tangle ./src/forge/compile/scad.cljc
(ns forge.compile.scad
  (:require [clojure.java.shell :refer [sh]]
            [clojure.string :as str]
            [forge.utils :as utils]
            [svg-clj.utils :refer [svg-str->elements]]
            [forge.model :as mdl]))

#+end_src

*** write-expr
#+begin_src clojure :tangle ./src/forge/compile/scad.cljc
;; multimethod
(defmulti write-expr
  (fn [depth element]
    (if (keyword? (first element)) (first element) :list)))

(defmethod write-expr :list
  [depth [& elems]]
  (mapcat #(write-expr depth %1) elems))

#+end_src

*** utility
#+begin_src clojure :tangle ./src/forge/compile/scad.cljc
;; utility
(defn indent
  [depth]
  (str/join (repeat depth "  ")))

(defn write-block
  [depth block]
  (mapcat #(write-expr (inc depth) %1) block))

(declare map-to-arg-string)

(defn make-arguments
  [args]
  (let [arg (first args)
        rest (rest args)
        piece (cond
               (map? arg) (map-to-arg-string arg)
               (coll? arg) (str "[" (make-arguments arg) "]")
               :else arg)]
    (if (empty? rest)
      piece
      (str/join ", " [piece (make-arguments rest)]))))

(defn map-to-arg-string
  [m]
  (str/join ", " (map (fn [[k v]] (str (name k) "=" (make-arguments [v])) ) m)))

#+end_src

*** 2d-impl
#+begin_src clojure :tangle ./src/forge/compile/scad.cljc
(defmethod write-expr :circle
  [depth [_ {:keys [r center]}]] 
  (list (indent depth) 
        "circle (r=" r ");\n"))

(defmethod write-expr :rect
  [depth [_ {:keys [w h center]}]]
  (list (indent depth)
        "square ([" w ", " h "]"
        (when center ", center=true") ");\n"))

(defmethod write-expr :polygon
  [depth [_ {:keys [pts paths convexity]}]]
  `(~@(indent depth) "polygon ("
    "points=[[" ~(str/join "], [" (map #(str/join ", " %1) pts)) "]]"
    ~@(when paths [", paths=[[" (str/join "], [" (map #(str/join "," %1) paths)) "]]"])
    ~@(when convexity [", convexity=" convexity])
    ");\n"))

(defmethod write-expr :slice
  [depth [_ {:keys [z]} elem]]
  (concat
   (list (indent depth)
         "projection(cut=true){\n")
   (write-expr (inc depth) (-> elem (mdl/translate [0 0 (- z)])))
   (list (indent depth) "}\n")))

#+end_src

*** 3d-impl
#+begin_src clojure :tangle ./src/forge/compile/scad.cljc
(defmethod write-expr :sphere
  [depth [_ {:keys [r center]}]]
  (list (indent depth) 
        "sphere (r=" r ");\n"))

(defmethod write-expr :box
  [depth [_ {:keys [x y z center]}]]
  (list (indent depth)
        "cube ([" x ", " y ", " z "]"
        (when center ", center=true") ");\n"))

(defmethod write-expr :cylinder
  [depth [_ {:keys [h r r1 r2 center]}]]
  (concat
   (list (indent depth) 
         "cylinder (h=" h)
   (if r (list ", r=" r) (list ", r1=" r1 ", r2=" r2))
   (when center (list ", center=true"))
   (list ");\n")))

(defmethod write-expr :polyhedron
  [depth [_ {:keys [pts faces convexity]}]]
  `(~@(indent depth) "polyhedron ("
    "points=[[" ~(str/join "], [" (map #(str/join ", " %1) pts)) "]], "
    "faces=[[" ~(str/join "], [" (map #(str/join ", " %1) faces)) "]]"
    ~@(if (nil? convexity) [] [", convexity=" convexity])
    ");\n"))

(defmethod write-expr :extrude
  [depth [_ {:keys [h]} elem]]
  (concat
   (list (indent depth) 
         "linear_extrude(height=" h
         "){\n")
   (write-expr (inc depth) elem)
   (list (indent depth) 
         "}\n")))

(defmethod write-expr :revolve
  [depth [_ {:keys [a]} elem]]
  (concat
   (list (indent depth)
         "rotate_extrude(angle=" a
         "){\n")
   (write-expr (inc depth) elem)
   (list (indent depth) 
         "}\n")))

#+end_src

*** transforms-impl
#+begin_src clojure :tangle ./src/forge/compile/scad.cljc
(defmethod write-expr :translate
  [depth [_ {:keys [x y z]} elem]]
  (concat
   (list (indent depth) "translate ([" x ", " y ", " z "]) {\n")
   (write-expr (inc depth) elem)
   (list (indent depth) "}\n")))

(defmethod write-expr :rotate
  [depth [_ {:keys [a x y z]} elem]]
  (if a
    (concat
     (list (indent depth) "rotate (a=" a ", v=[" x ", " y ", " z "]) {\n")
     (write-expr (inc depth) elem)
     (list (indent depth) "}\n"))
    (concat
     (list (indent depth) "rotate ([" x "," y "," z "]) {\n")
     (write-expr (inc depth) elem)
     (list (indent depth) "}\n"))))

(defmethod write-expr :scale
  [depth [_ {:keys [x y z]} elem]]
  (concat
   (list (indent depth) "scale ([" x ", " y ", " z "]) {\n")
   (write-expr (inc depth) elem)
   (list (indent depth) "}\n")))

(defmethod write-expr :mirror
  [depth [_ {:keys [x y z]} elem]]
  (concat
   (list (indent depth) "mirror ([" x ", " y ", " z "]) {\n")
   (write-expr (inc depth) elem)
   (list (indent depth) "}\n")))

(defmethod write-expr :hull
  [depth [_ _ elem]]
  (concat
   (list (indent depth) "hull () {\n")
   (write-expr (inc depth) elem)
   (list (indent depth) "}\n")))

(defmethod write-expr :offset
  [depth [_ {:keys [d]} elem]]
  (concat 
   (list (indent depth) "offset (r = " d "){\n")
   (write-expr (inc depth) elem)
   (list (indent depth) "}\n")))

(defmethod write-expr :minkowski
  [depth [_ _ elems]]
  (concat
   (list (indent depth) "minkowski () {\n")
   (write-expr (inc depth) elems)
   (list (indent depth) "}\n")))

(defmethod write-expr :multmatrix
  [depth [_ {:keys [mtx]} elem]]
  (let [w (fn [s] (str "[" s "]"))
        co (fn [c] (apply str (interpose "," c)))]
    (concat
     (list (indent depth) "multmatrix(")
     (w (co (map #(w (co %)) mtx)))
     (list ") {\n")
     (mapcat #(write-expr (inc depth) %1) elem)
     (list (indent depth) "}\n"))))

#+end_src

*** boolean-impl
#+begin_src clojure :tangle ./src/forge/compile/scad.cljc
(defmethod write-expr :union
  [depth [_ _ elems]]
  (concat
   (list (indent depth) "union () {\n")
   (write-block depth elems)
   (list (indent depth) "}\n")))

(defmethod write-expr :difference
  [depth [_ _ elems]]
  (concat
   (list (indent depth) "difference () {\n")
   (mapcat #(write-expr (inc depth) %1) elems)
   (list (indent depth) "}\n")))

(defmethod write-expr :intersection
  [depth [_ _ elems]]
  (concat
   (list (indent depth) "intersection () {\n")
   (mapcat #(write-expr (inc depth) %1) elems)
   (list (indent depth) "}\n")))

#+end_src

*** other-impl
#+begin_src clojure :tangle ./src/forge/compile/scad.cljc
(defmethod write-expr :color
  [depth [_ {:keys [r g b a]} elem]]
  (concat
    (list (indent depth) "color (["
          (/ r 255.0) ", "
          (/ g 255.0) ", "
          (/ b 255.0) ", "
          (utils/clamp a 0.0 1.0) "]) {\n")
    (write-expr depth elem)
    (list (indent depth) "}\n")))

(defmethod write-expr :group 
  [depth [_ _ elems]]
  (concat
   (list (indent depth) "group() {\n")
   (write-expr (inc depth) elems)
   (list (indent depth) "}\n")))

#+end_src

*** composites
#+begin_src clojure :tangle ./src/forge/compile/scad.cljc
(defn- scad-line
  [a b & {:keys [r]}]
  (let [r (if r r 2)
        a (if (< (count a) 3) (forge.utils/add-z a) a)
        b (if (< (count b) 3) (forge.utils/add-z b) b)]
    (if (= a b)
      (-> (mdl/sphere r) (mdl/translate a))
      (let [[dx dy dz] (utils/v- a b)
            norm (utils/distance b a)
            rotate-angle (utils/to-deg (Math/acos (/ dz norm)))
            rotate-axis [(- dy) dx 0]]
        (-> (mdl/union
             (-> (mdl/sphere r) (mdl/translate a))
             (-> (mdl/sphere r) (mdl/translate b))
             (-> (mdl/cylinder r norm)
                 (mdl/translate [0 0 (/ norm 2)])
                 (mdl/rotate rotate-angle rotate-axis)
                 (mdl/translate b)))
            (mdl/color [0 0 0 1]))))))

(defn- scad-polyline
  [pts & {:keys [r]}]
  (apply mdl/union
   (map #(scad-line (first %) (second %) :r r)
        (partition 2 1 pts))))

(defn- linecube
  [x y z]
  (mdl/union
   (-> (mdl/box x y z) (mdl/color [0 1 0 1]))
   (-> (mdl/union
        (mdl/line [0 0 0] [x 0 0])
        (mdl/line [x 0 0] [x y 0])
        (mdl/line [x y 0] [0 y 0])
        (mdl/line [0 y 0] [0 0 0])
        (mdl/line [0 0 0] [0 0 z])
        (mdl/line [x 0 0] [x 0 z])
        (mdl/line [x y 0] [x y z])
        (mdl/line [0 y 0] [0 y z])
        (mdl/line [0 0 z] [x 0 z])
        (mdl/line [x 0 z] [x y z])
        (mdl/line [x y z] [0 y z])
        (mdl/line [0 y z] [0 0 z]))
       (mdl/translate [(/ x -2.0) (/ y -2.0) (/ z -2.0)]))))

(defmethod write-expr :line
  [depth [_ {:keys [a b]}]]
  (write-expr depth (scad-line a b)))

(defmethod write-expr :polyline
  [depth [_ {:keys [pts]}]]
  (write-expr depth (scad-polyline pts)))

#+end_src

*** write
#+begin_src clojure :tangle ./src/forge/compile/scad.cljc
(defn write [& block]
  (str/join (write-expr 0 block)))

#+end_src

*** tools
If you need to display images in the CIDER Repl, you have to make sure that cider-repl-use-content-types is true

~(setq cider-repl-use-content-types t)~

Which you can toggle with:

~M-x cider-repl-toggle-content-types~

**** TODO: fix openscad alias issue with sh call

#+begin_src clojure :tangle ./src/forge/compile/scad.cljc
(defn png!
  [fname mdl-data]
  (let [scad (write [#_(fn! 20) mdl-data])]
    (sh "/usr/local/bin/openscad" "/dev/stdin"
        "--imgsize" "400,400"
        "--projection" "orthogonal"
        #_"--colorscheme" #_"greenscreen" #_"Nord"
        #_"--camera" #_"0,0,0,55,0,25,2900"
        "-o" fname
        :in scad)))

(defn cider-show
  [mdl-data]
  (let [fname "_tmp.png"]
    (do (png! fname mdl-data)
        (clojure.java.io/file fname))))

(defn mdl->svg
  [mdl]
  (let [scad (str "$fn=200;\n" (write mdl))
        fname (str (gensym "tmp") ".svg")]
    (do (sh "openscad" "/dev/stdin" "-o" fname :in scad)
        (let [svg-str (slurp fname)]
          (do (sh "rm" fname)
              (rest 
               (svg-str->elements svg-str)))))))
#+end_src

** freecad-script
*** ns
#+begin_src clojure :tangle ./src/forge/compile/freecad.cljc
(ns forge.compile.freecad
  (:require [clojure.java.shell :refer [sh]]
            [clojure.string :as str]
            [clojure.core.matrix]
            [forge.utils :as utils]
            [forge.model :as mdl]))

#+end_src

*** utils
#+begin_src clojure :tangle ./src/forge/compile/freecad.cljc
(defn get-name
  [s]
  (-> s
      str/split-lines
      last
      (str/split #"=")
      first
      str/trim))

(defn vecstr
  [v]
  (str "Vector(" (str/join ", " v) ")"))

(defn mtxstr
  [[& vs]]
  (str "Matrix(" (str/join ", " (apply concat vs)) ")"))

(defn vecrot
  [v]
  (vec (concat (drop 1 v) (take 1 v))))

#+end_src

*** write-expr
#+begin_src clojure :tangle ./src/forge/compile/freecad.cljc
(defmulti write-expr
  (fn [[form & args]]
    (if (keyword? form) form :list)))

(defmethod write-expr :default
  [[form & args]]
  ["//(" form args ")"])

(defmethod write-expr :list
  [forms]
  (str/join "\n" (map write-expr forms)))

(defn write-block
  [block]
  (mapcat write-expr block))

(declare map-to-arg-string)

(defn make-arguments [args]
  (let [arg (first args)
        rest (rest args)
        piece (cond
               (map? arg) (map-to-arg-string arg)
               (coll? arg) (str "[" (make-arguments arg) "]")
               :else arg)]
    (if (empty? rest)
      piece
      (str/join ", " [piece (make-arguments rest)]))))

(defn map-to-arg-string [m]
  (str/join ", " (map (fn [[k v]] (str (name k) "=" (make-arguments [v])) ) m)))

#+end_src

*** boilerplate
The postamble has some filepath code which I found from here:

[[https://stackoverflow.com/a/595317]] (user jon-w)

#+begin_src clojure :tangle ./src/forge/compile/freecad.cljc
(def fcs-preamble
  "import FreeCAD
from FreeCAD import Base, Vector, Matrix, Placement, Rotation
from math import pi, sin, cos

import Part
import Sketcher
import Import
import sys, os

doc = FreeCAD.activeDocument()
doc_name = \"freecad_clj\"

def clear_doc():
    for obj in doc.Objects:
        doc.removeObject(obj.Name)

def setview():
    FreeCAD.Gui.SendMsgToActiveView(\"ViewFit\")
    FreeCAD.Gui.activeDocument().activeView().viewAxometric()

if doc is None:
    FreeCAD.newDocument(doc_name)
    FreeCAD.setActiveDocument(doc_name)
    doc = FreeCAD.activeDocument()
else:
    clear_doc()

# EPS= tolerance to use to cut the parts
EPS = 0.10
EPS_C = EPS * -0.5\n\n")

(def fcs-postamble
  "doc.recompute()

pathname = os.path.dirname(sys.argv[0])
stepname = os.path.abspath(pathname) + \"/out.step\"
fcname = os.path.abspath(pathname) + \"/out.FCStd\"

#Import.export(doc.RootObjects, stepname)
#doc.saveAs(fcname)")

#+end_src

*** 2D
**** circle
 Start with a circle.

 doc.addObject('Sketcher::SketchObject','sk1')
 doc.sk1.addGeometry(Part.Circle(App.Vector(0.000000,0.000000,0),App.Vector(0,0,1),10),False)
 doc.recompute()

 #+begin_src clojure :tangle ./src/forge/compile/freecad.cljc
 (defmethod write-expr :circle
   [[_ {:keys [r]}]]
   (let [name (gensym "sk_circle_")]
     (str name " = " "Part.makeCircle(" r  ")")))

 #+end_src

**** polygon
 geoList = []
 geoList.append(Part.LineSegment(App.Vector(-5.235079,-4.280038,0),App.Vector(4.496150,-4.280038,0)))
 geoList.append(Part.LineSegment(App.Vector(4.496150,-4.280038,0),App.Vector(4.496150,6.009032,0)))
 geoList.append(Part.LineSegment(App.Vector(4.496150,6.009032,0),App.Vector(-5.235079,6.009032,0)))
 geoList.append(Part.LineSegment(App.Vector(-5.235079,6.009032,0),App.Vector(-5.235079,-4.280038,0)))


 Sketcher.Constraint('Coincident',1,2,2,1)
 App.ActiveDocument.sk_7085.addConstraint(conList)

 App.ActiveDocument.sk_7085.addGeometry(geoList,False)

 #+begin_src clojure :tangle ./src/forge/compile/freecad.cljc
 (defn line-segment
   [[a b]]
   (str "Part.LineSegment(" (str/join ", " (map vecstr [a b])) ")"))

 (defn coincident-constraint
   [[ia ib]]
   (str "Sketcher.Constraint('Coincident'," ia ",2," ib ",1)"))

 (defn build-polygon-old
   [pts]
   (let [name (gensym "sk_")
         indices (partition 2 1 (conj (vec (range (count pts))) 0))
         lines (partition 2 1 (conj pts (first pts)))]
     (apply str [name " = doc.addObject('Sketcher::SketchObject','" name "')\n"
                 "doc." name ".addGeometry(["
                 (str/join "," (map line-segment lines))
                 "],False)\n\n"
                 "doc." name ".addConstraint(["
                 (str/join "," (map coincident-constraint indices))
                 "])\n"])))

 (defn build-polygon
   [pts]
   (let [pts (conj pts (first pts))]
     (str "Part.makePolygon(["
          (str/join ", " (map vecstr pts))
          "])")))

 (defmethod write-expr :polygon
   [[_ {:keys [pts]}]]
   (let [name (gensym "sk_polygon_")]
     (str name " = " (build-polygon pts))))

 #+end_src

**** square
 Use the polygon fn to create a square.

 #+begin_src clojure :tangle ./src/forge/compile/freecad.cljc
 (defmethod write-expr :square
   [[_ {:keys [x y]}]]
   (let [pts [[(/ x -2) (/ y -2) 0] [(/ x 2)  (/ y -2) 0]
              [(/ x 2)  (/ y 2)  0] [(/ x -2) (/ y 2)  0]]
         name (gensym "sk_sq_")]
     (str name " = " (build-polygon pts))))

 #+end_src

*** 3D
**** sphere
 doc.addObject("Part::Sphere","Sphere")
 doc.getObject("Sphere").Radius = '10'

 #+begin_src clojure :tangle ./src/forge/compile/freecad.cljc
 (defmethod write-expr :sphere
   [[_ {:keys [r]}]]
   (let [name (gensym "sphere_")]
     (str name " = " "Part.makeSphere(" r ")")))

 #+end_src

**** cube
 doc.addObject("Part::Box","Box")
 doc.getObject("Box").Placement = App.Placement(App.Vector(-25.4,0,0),App.Rotation(App.Vector(0,0,1),0))

 #+begin_src clojure :tangle ./src/forge/compile/freecad.cljc
 (defmethod write-expr :cube
   [[_ {:keys [x y z]}]]
   (let [name (gensym "cube_")
         pos (map #(/ % -2.0) [x y z])]
     (str name " = " "Part.makeBox(" (str/join ", " [x y z]) ")"
          ".translate(" (vecstr pos) ")")))

 #+end_src

**** cylinder
 App.ActiveDocument.addObject("Part::Cylinder","Cylinder")

 #+begin_src clojure :tangle ./src/forge/compile/freecad.cljc
 (defmethod write-expr :cylinder
   [[_ {:keys [r h]}]]
   (let [name (gensym "cylinder_")
         pos (map #(/ % -2) [0 0 h])]
     (str name " = " "Part.makeCylinder(" (str/join ", " [r h]) ")"
          ".translate(" (vecstr pos) ")")))

 #+end_src

**** polyhedron
 #+begin_src clojure :tangle ./src/forge/compile/freecad.cljc
 (defn build-face
   [pts]
   (str "Part.Face(" (build-polygon pts) ")"))

 (defmethod write-expr :polyhedron
   [[_ {:keys [pts faces]}]]
   (let [name (gensym "polyhedron_")
         get-pts (fn [face] (mapv #(get (vec pts) %) face))
         faces (mapv get-pts faces)]
     (str name " = " "Part.makeSolid(Part.makeShell(" 
          (str/join ", " faces) "))")))

 #+end_src

**** extrude-linear
 Part.Face(Part.Wire(a)).extrude(FreeCAD.Base.Vector(0,0,10))

 #+begin_src clojure :tangle ./src/forge/compile/freecad.cljc
 (defmethod write-expr :extrude-linear
   [[_ {:keys [height]} form]]
   (let [sk (write-expr form)
         name (gensym "extrude_")
         sk-name (get-name sk)]
     (str sk "\n"
          name " = " "Part.Face(Part.Wire(" sk-name "))"
          ".extrude(" (vecstr [0 0 height]) ")")))

 #+end_src

**** extrude-rotate
 #+begin_src clojure :tangle ./src/forge/compile/freecad.cljc
 (defmethod write-expr :extrude-rotate
   [[_ {:keys [angle]} form]]
   (let [angle (if angle angle 360)
         sk (write-expr form)
         name (gensym "revolve_")
         sk-name (get-name sk)]
     (str sk "\n"
          name " = " "Part.Face(Part.Wire(" sk-name "))"
          ".rotate(" (vecstr [0 0 0]) "," (vecstr [1 0 0]) ", 90" ")"
          ".revolve(" (vecstr [0 0 0]) "," (vecstr [0 0 1]) "," angle ")")))

 #+end_src

*** transforms
**** rotation-matrix
 This is here as reference for if/when I improve how transforms are done. For instance, I could optimize output by baking all transforms down into a single matrix multiplication.

 #+begin_src clojure :tangle ./src/forge/compile/freecad.cljc
 (defn v* [a b] (mapv * a b))

 (defn normalize
   "find the unit vector of a given vector"
   [v]
   (let [m (Math/sqrt (reduce + (v* v v)))]
     (mapv / v (repeat m))))

 ;; rotation matrices sourced from:
 ;; https://sites.google.com/site/glennmurray/Home/rotation-matrices-and-formulas/rotation-about-an-arbitrary-axis-in-3-dimensions
 ;; zyx-rotation-matrix from section 3
 ;; axis-rotation-matrix from section 5.2

 (defn axis-rotation-matrix [a [x y z]]
   (let [[u v w] (normalize [x y z])
         c #(Math/cos %)
         s #(Math/sin %)]
     [[(+ (* u u) (* (- 1 (* u u)) (c a)))
       (- (* v u (- 1 (c a))) (* w (s a)))
       (+ (* w u (- 1 (c a))) (* v (s a)))
       0]

      [(+ (* u v (- 1 (c a))) (* w (s a)))
       (+ (* v v) (* (- 1 (* v v)) (c a)))
       (- (* w v (- 1 (c a))) (* u (s a)))
       0]

      [(- (* u w (- 1 (c a))) (* v (s a)))
       (+ (* v w (- 1 (c a))) (* u (s a)))
       (+ (* w w) (* (- 1 (* w w)) (c a)))
       0]

      [0 0 0 1]]))

 #+end_src

**** translate
 #+begin_src clojure :tangle ./src/forge/compile/freecad.cljc
 (defn build-translate
   [[x y z] form]
   (str form ".translate(" (vecstr [x y z]) ")"))

 (defmethod write-expr :translate
   [[_ {:keys [x y z]} forms]]
   (let [xforms (mapcat str/split-lines (map write-expr forms))]
     (str/join "\n" (map #(build-translate [x y z] %) xforms))))

 #+end_src

**** rotate
 #+begin_src clojure :tangle ./src/forge/compile/freecad.cljc
 (defn build-rotate
   [a [x y z] form]
   (str form ".rotate(" (vecstr [0 0 0]) ", " (vecstr [x y z]) ", " a ")"))

 (defmethod write-expr :rotatev
   [[_ {:keys [a x y z]} forms]]
   (let [xforms (mapcat str/split-lines (map write-expr forms))]
     (str/join "\n" (map #(build-rotate a [x y z] %) xforms))))

 (defmethod write-expr :rotatec
   [[_ {:keys [x y z]} forms]]
   (let [xforms (map #(->> %
                           (rotate z [0 0 1])
                           (rotate y [0 1 0])
                           (rotate x [1 0 0])) forms)]
     (str/join "\n" (map write-expr xforms))))

 #+end_src

**** color
 #+begin_src clojure :tangle ./src/forge/compile/freecad.cljc
 (defmethod write-expr :color
   [[_ {:keys [a x y z]} forms]]
   (str/join "\n" (map write-expr forms)))

 #+end_src

*** boolean-ops
**** difference
 Difference takes two elements: the base and the tool. THe base is what remains, the tool is the section that gets cut away.

 doc.addObject("Part::Cut","Cut_Name")
 doc.Cut_Name.Base = doc.cube_5771
 doc.Cut_Name.Tool = doc.cylinder_5772
 doc.hide("cube_5771")
 doc.hide("cylinder_5772")

 #+begin_src clojure :tangle ./src/forge/compile/freecad.cljc
 (defn build-cut
   [str-a str-b]
   (let [name (gensym "difference_")]
     (str str-a "\n"
          str-b "\n"
          name " = " (get-name str-a) ".cut(" (get-name str-b) ")")))

 (defmethod write-expr :difference
   [[_ _ forms]]
   (let [xforms (mapcat str/split-lines (map write-expr forms))]
     (str (reduce build-cut xforms) ".removeSplitter()")))

 #+end_src

**** union
 Union takes two elements: the base and the tool. THe base is what remains, the tool is the section that gets cut away.

 doc.addObject("Part::Fuse","Union_Name")
 doc.Union_Name.Base = doc.cube_5771
 doc.Union_Name.Tool = doc.cylinder_5772

 #+begin_src clojure :tangle ./src/forge/compile/freecad.cljc
 (defn build-fuse
   [str-a str-b]
   (let [name (gensym "union_")]
     (str str-a "\n"
          str-b "\n"
          name " = " (get-name str-a) ".fuse(" (get-name str-b) ")")))

 (defmethod write-expr :union
   [[_ _ forms]]
   (let [xforms (mapcat str/split-lines (map write-expr forms))]
     (str (reduce build-fuse xforms) ".removeSplitter()")))

 #+end_src

**** intersection
 Intersection takes two elements: the base and the tool. THe base is what remains, the tool is the section that gets cut away.

 doc.addObject("Part::MultiCommon","intersection_Name")
 doc.intersection_Name.Shapes = [doc.cube_5771, doc.cylinder_5772]

 #+begin_src clojure :tangle ./src/forge/compile/freecad.cljc
 (defn build-common
   [str-a str-b]
   (let [name (gensym "intersection_")]
     (str str-a "\n"
          str-b "\n"
          name " = " (get-name str-a) ".common(" (get-name str-b) ")")))

 (defmethod write-expr :intersection
   [[_ _ forms]]
   (let [xforms (mapcat str/split-lines (map write-expr forms))]
     (str (reduce build-common xforms) ".removeSplitter()")))

 #+end_src

*** write-fcs
FreeCAD command line tool is basically just a python interactive shell. So, you can actually use the python CLI flags just fine.

 ~python -c "print('Hello')"~

 Will print 'Hello' because the interpreter executes the string as python code.

 So, I can do the same thing with freecad -c. Then, to export a STEP file, I can actually pass the whole script as a string, bypassing the need to write/del files.

 #+begin_src clojure :tangle ./src/forge/compile/freecad.cljc
 (defn write-fcs
   [& blocks]
   (let [block-strs (map write-expr blocks)
         names (map #(str "Part.show(" (get-name %) ", '" (gensym "fcs_") "')") block-strs)]
     (str/join "\n"
      (concat
       [fcs-preamble]
       block-strs
       names
       [fcs-postamble]))))

 (defn ->step
   [block]
   (sh "freecad" "-c" (write-fcs block)))

 #+end_src

** svg
The initial idea for SVG is to represent all shapes with edges and faces using svg-clj.path/polygon-path fn.

Every elem-to-svg needs the element and a transform function (xf) which takes a list of 3D points and returns a list of 2D points which fit the desired ortho projection (isometric being default).

*** ns
#+begin_src clojure :tangle ./src/forge/compile/svg.cljc
(ns forge.compile.svg
  (:require [clojure.java.shell :refer [sh]]
            [clojure.string :as str]
            [svg-clj.elements :as svg]
            [svg-clj.path :as path]
            [svg-clj.transforms :as tf]
            [svg-clj.tools :as tools]
            [hiccup.core :refer [html]]
            [forge.utils :as utils]))

#+end_src

*** elem-to-svg
#+begin_src clojure :tangle ./src/forge/compile/svg.cljc
;; multimethod
(defmulti elem-to-svg
  (fn [element _]
    (if (keyword? (first element)) 
      (first element) 
      :list)))

(defmethod elem-to-svg :list 
  [[& args] xf]
  (map #(elem-to-svg % xf) args))

#+end_src

*** 2d-impl
#+begin_src clojure :tangle ./src/forge/compile/svg.cljc
(defmethod elem-to-svg :circle
  [[_ {:keys [r center origin rotation translation]}] xf]
  (let [rot (if rotation rotation [0 0 0])
        tr (if translation translation [0 0 0])
        pts (->> (utils/regular-polygon-pts r 40)
                 (mapv #(conj % 0))
                 (mapv #(utils/v+ origin %))
                 (mapv #(utils/rotate-point % rot))
                 xf)]
    (-> (path/polygon-path pts)
        (tf/style {:fill "none"
                   :stroke "black"
                   :stroke-width "2px"}))))

(defmethod elem-to-svg :rect 
  [[_ {:keys [x y center origin rotation]}] xf]
  (let [pts (->> (if center
                   [ [(/ x -2.0) (/ y -2.0)]
                    [(/ x 2.0) (/ y -2.0)] 
                    [(/ x 2.0) (/ y 2.0)]
                    [(/ x -2.0) (/ y 2.0)] ]
                   [ [0 0] [x 0] [x y] [0 y] ])
                 (mapv #(utils/v+ origin %))
                 (mapv #(utils/rotate-point % rotation))
                 xf)]
    (-> (path/polygon-path pts)
        (tf/style {:fill "none"
                   :stroke "black"
                   :stroke-width "2px"}))))

(defmethod elem-to-svg :polygon
  [[_ {:keys [pts paths convexity]}] xf]
  (let [polygons (for [path paths]
                   (xf (map #(get pts %) path)))]
    (-> (apply path/merge-paths 
               (map path/polygon-path polygons))
        (tf/style {:fill "none"
                   :stroke "black"
                   :stroke-width "2px"}))))

#+end_src

*** transforms-impl
#+begin_src clojure :tangle ./src/forge/compile/svg.cljc
(defmethod elem-to-svg :translate 
  [[_ {:keys [xf-elem]} block] xf]
  (elem-to-svg xf-elem xf))

(defmethod elem-to-svg :rotate 
  [[_ {:keys [xf-elem]} block] xf]
  (elem-to-svg xf-elem xf))

#+end_src

*** write
#+begin_src clojure :tangle ./src/forge/compile/svg.cljc
(def iso-euler-angles [35.264 45 0])
(def origin-angle-adjust-a [90 0 0])
(def origin-angle-adjust-b [0 -90 0])

(defn rotate-points
  [[ax ay az] pts]
  (mapv #(utils/rotate-point % [ax ay az]) pts))

(defn isometric-xf
  [pts]
  (->> pts
       (rotate-points origin-angle-adjust-a)
       (rotate-points origin-angle-adjust-b)
       (rotate-points iso-euler-angles)
       (mapv #(into [] (drop-last %)))))

(defn top-xf
  [pts]
  (-> pts
      (rotate-points [0 0 0])))

(defn right-xf
  [pts]
  (-> pts
      (rotate-points [90 0 0])))

(defn write
  [& mdl-data]
  (->> mdl-data
       (mapv #(elem-to-svg % isometric-xf))
       svg/g
       svg/svg
       #_html))

#+end_src

* scratch
A namespace for playing around with fns

#+begin_src clojure
(ns forge.scratch
  (:require [forge.model :as mdl]
            [forge.utils :as utils]
            [forge.brep :as brep]
            [forge.import.image :as img]
            [forge.compile.scad :as scad]))

(def a (-> (mdl/circle 20) 
           (mdl/extrude 100)))
(def b (-> (mdl/circle 20)
           (mdl/translate [40 0 0])
           (mdl/revolve 360)))
(def c (-> (utils/regular-polygon-pts 30 8)
           (mdl/polygon)
           (mdl/translate [180 0 0])
           (mdl/revolve 180)))
(def d (-> (img/import "sk.svg")))

(def e (-> (for [t (range 0 1.1 0.1)]
             ((brep/bezier [[0 0 0] [400 400 400] [700 50 200] [300 -200 100] [30 -500 -100]]) t))
           (mdl/polyline)))

(scad/cider-show b)
#_(scad/cider-show d)
(scad/cider-show d)
(spit "forge.scad" (scad/write c))

#+end_src
